<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>綠幕視窗</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #00FF00;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Microsoft JhengHei', sans-serif;
        }

        /* 可拖曳可縮放容器 */
        .draggable {
            position: absolute;
            cursor: move;
            user-select: none;
        }

        /* 初始化期間隱藏所有元素，防止閃爍 */
        body.initializing .draggable:not(.debug-panel):not(.window-controls) {
            opacity: 0 !important;
            visibility: hidden !important;
            transition: none !important;
        }

        /* 初始化完成後的淡入效果 */
        body:not(.initializing) .draggable {
            transition: opacity 0.3s ease;
        }

        /* 8個調整點 */
        .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #fff;
            border: 2px solid #4ecca3;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
        }

        .draggable:hover .resize-handle,
        .debug-mode .resize-handle {
            opacity: 1;
        }

        /* 四個角 */
        .resize-handle.nw { top: -6px; left: -6px; cursor: nw-resize; }
        .resize-handle.ne { top: -6px; right: -6px; cursor: ne-resize; }
        .resize-handle.sw { bottom: -6px; left: -6px; cursor: sw-resize; }
        .resize-handle.se { bottom: -6px; right: -6px; cursor: se-resize; }

        /* 四個邊 */
        .resize-handle.n { top: -6px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .resize-handle.s { bottom: -6px; left: 50%; transform: translateX(-50%); cursor: s-resize; }
        .resize-handle.w { left: -6px; top: 50%; transform: translateY(-50%); cursor: w-resize; }
        .resize-handle.e { right: -6px; top: 50%; transform: translateY(-50%); cursor: e-resize; }

        /* 轉盤容器 */
        .wheel-container {
            top: 150px;
            left: 50%;
            transform: translateX(-50%);
            width: 350px;
            height: 350px;
        }

        .wheel-container.hidden {
            display: none;
        }

        #wheelCanvas {
            width: 100%;
            height: 100%;
        }

        /* 影片容器 */
        .video-container {
            position: absolute;
            width: 300px;
            height: 200px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .video-container.hidden {
            display: none !important;
            visibility: hidden !important;
            opacity: 0 !important;
            pointer-events: none !important;
        }

        .video-container .thumbnail-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            z-index: 1;
        }

        .video-container.playing .thumbnail-video {
            display: none !important;
            visibility: hidden !important;
        }

        .video-container .video-player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            z-index: 2;
            display: none;
            visibility: hidden;
        }

        .video-container.playing .video-player {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            z-index: 999 !important;
        }

        /* 調試面板 */
        .debug-panel {
            position: fixed;
            top: 0;
            right: -280px;
            width: 280px;
            height: 100vh;
            background: rgba(22, 27, 34, 0.98);
            border-left: 2px solid rgba(78, 204, 163, 0.5);
            padding: 15px;
            transition: right 0.3s ease;
            z-index: 1000;
            overflow-y: auto;
            color: #f0f6fc;
        }

        .debug-panel.visible {
            right: 0;
        }

        .debug-panel h3 {
            color: #4ecca3;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: 600;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .debug-hint-text {
            font-size: 10px;
            font-weight: 400;
            opacity: 0.5;
        }

        .debug-quick-actions {
            display: flex;
            gap: 6px;
            margin-bottom: 12px;
        }

        .debug-btn-mini {
            flex: 1;
            padding: 6px 8px;
            font-size: 11px;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 6px;
            color: #f0f6fc;
            cursor: pointer;
            transition: all 0.2s;
        }

        .debug-btn-mini:hover {
            background: rgba(255,255,255,0.15);
            border-color: rgba(78, 204, 163, 0.5);
        }

        .debug-section {
            margin-bottom: 12px;
        }

        .debug-section h4 {
            color: #00d9ff;
            margin-bottom: 10px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: default;
        }

        .debug-section.collapsible h4 {
            cursor: pointer;
            padding: 5px 0;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .debug-section.collapsible h4:hover {
            background: rgba(255,255,255,0.05);
        }

        .debug-section.collapsible .collapse-icon {
            font-size: 10px;
            transition: transform 0.2s;
        }

        .debug-section.collapsible.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .debug-section.collapsible.collapsed .section-content {
            display: none;
        }

        /* 顯示控制網格 */
        .debug-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }

        .debug-chip {
            padding: 8px 10px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            color: #8b949e;
        }

        .debug-chip:hover {
            background: rgba(255,255,255,0.1);
        }

        .debug-chip.active {
            background: rgba(78, 204, 163, 0.2);
            border-color: rgba(78, 204, 163, 0.5);
            color: #4ecca3;
        }

        /* 按鈕網格 */
        .debug-btn-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 6px;
        }

        .debug-btn {
            padding: 8px 12px;
            background: linear-gradient(135deg, #4ecca3, #3db892);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .debug-btn.compact {
            padding: 8px 6px;
            font-size: 11px;
        }

        .debug-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(78, 204, 163, 0.4);
        }

        .debug-btn.danger {
            background: linear-gradient(135deg, #e94560, #d63950);
        }

        .debug-btn.secondary {
            background: linear-gradient(135deg, #6c757d, #5a6268);
        }

        .debug-btn:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.5;
        }

        .debug-btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .video-list.compact {
            max-height: 200px;
            overflow-y: auto;
        }

        .video-list.compact .video-item {
            padding: 8px;
            gap: 8px;
            margin-bottom: 6px;
        }

        .video-list.compact .video-thumbnail {
            width: 50px;
            height: 38px;
        }

        .video-list.compact .video-name {
            font-size: 12px;
            margin-bottom: 2px;
        }

        .video-list.compact .video-type {
            font-size: 10px;
        }

        .video-list.compact .video-actions {
            flex-direction: row;
            gap: 4px;
        }

        .video-list.compact .video-actions button {
            padding: 4px 8px;
            font-size: 10px;
            min-width: auto;
        }

        .debug-toggle {
            position: relative;
            width: 44px;
            height: 24px;
            background: #21262d;
            border-radius: 12px;
            cursor: pointer;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .debug-toggle.active {
            background: #4ecca3;
        }

        .debug-toggle::after {
            content: '';
            position: absolute;
            width: 18px;
            height: 18px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: left 0.2s;
        }

        .debug-toggle.active::after {
            left: 23px;
        }

        /* 影片列表 */
        .video-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .video-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            margin-bottom: 10px;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .video-item.hidden-item {
            opacity: 0.5;
        }

        .video-thumbnail {
            width: 80px;
            height: 60px;
            background: #000;
            border-radius: 6px;
            overflow: hidden;
            flex-shrink: 0;
            position: relative;
        }

        .video-thumbnail video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-thumbnail .no-video {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 24px;
        }

        .video-info {
            flex: 1;
            min-width: 0;
        }

        .video-name {
            font-size: 13px;
            font-weight: bold;
            color: #f0f6fc;
            margin-bottom: 4px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .video-type {
            font-size: 11px;
            color: #8b949e;
        }

        .video-actions {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .video-actions button {
            padding: 5px 10px;
            font-size: 11px;
            min-width: 60px;
        }

        .empty-list {
            text-align: center;
            color: #8b949e;
            padding: 30px;
            font-size: 13px;
        }

        .video-list.compact .empty-list {
            padding: 15px 10px;
            font-size: 11px;
        }

        .refresh-btn {
            font-size: 12px;
            padding: 4px 8px;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: #8b949e;
            cursor: pointer;
            border-radius: 4px;
        }

        .refresh-btn:hover {
            background: rgba(255,255,255,0.1);
            color: #f0f6fc;
        }

        /* 視窗控制列 */
        .window-controls {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 32px;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 10px;
            z-index: 9999;
            -webkit-app-region: drag;
            opacity: 0.3;
            transition: opacity 0.3s;
        }

        /* 3秒後自動隱藏 */
        .window-controls.auto-hide {
            opacity: 0;
        }

        .window-controls:hover,
        .window-controls.auto-hide:hover,
        .debug-mode .window-controls {
            opacity: 1;
        }

        .window-controls .title {
            color: #fff;
            font-size: 12px;
            pointer-events: none;
        }

        .window-controls .buttons {
            display: flex;
            gap: 8px;
            -webkit-app-region: no-drag;
        }

        .window-controls .btn {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .window-controls .btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .window-controls .btn.close:hover {
            background: #e94560;
        }

        /* 提示 */
        .debug-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 13px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .debug-hint.visible {
            opacity: 1;
        }

        /* 右鍵選單 */
        .context-menu {
            display: none;
            position: fixed;
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 8px 0;
            min-width: 180px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 1000;
        }

        .context-menu.visible {
            display: block;
        }

        .context-menu-item {
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }

        .context-menu-item:hover {
            background: rgba(78, 204, 163, 0.2);
        }

        .context-menu-item .checkmark {
            width: 16px;
            color: #4ecca3;
        }

        .context-menu-item .menu-icon {
            width: 20px;
            text-align: center;
        }

        .context-menu-header {
            padding: 8px 16px;
            color: #8b949e;
            font-size: 12px;
            font-weight: 600;
        }

        .context-menu-divider {
            height: 1px;
            background: rgba(255,255,255,0.1);
            margin: 4px 0;
        }

        /* 滾動條 */
        .debug-panel::-webkit-scrollbar,
        .video-list::-webkit-scrollbar {
            width: 6px;
        }

        .debug-panel::-webkit-scrollbar-track,
        .video-list::-webkit-scrollbar-track {
            background: transparent;
        }

        .debug-panel::-webkit-scrollbar-thumb,
        .video-list::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
        }

        /* 全屏進場影片容器 */
        .entry-container {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 2000;
            background: transparent;
        }

        .entry-container.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .entry-video {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* 隨機影片專用容器（可拖曳縮圖版） */
        .random-video-box {
            position: absolute;
            width: 300px;
            height: 200px;
            left: 50px;
            top: 400px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 215, 0, 0.5);
            border-radius: 8px;
            overflow: hidden;
            z-index: 100;
        }

        .random-video-box.hidden {
            display: none !important;
        }

        .random-video-box.playing .random-video-placeholder {
            display: none;
        }

        .random-video-box.playing .random-video-player {
            display: block;
        }

        .random-video-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 165, 0, 0.2));
        }

        .random-video-icon {
            font-size: 48px;
            margin-bottom: 8px;
        }

        .random-video-label {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: bold;
        }

        .random-video-player {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* 抓鴨子影片容器 */
        .duck-video-box {
            position: absolute;
            width: 300px;
            height: 200px;
            left: 400px;
            top: 400px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 193, 7, 0.6);
            border-radius: 8px;
            overflow: hidden;
            z-index: 100;
        }

        .duck-video-box.hidden {
            display: none !important;
        }

        .duck-video-box.playing .duck-video-placeholder {
            display: none;
        }

        .duck-video-box.playing .duck-video-player {
            display: block;
        }

        .duck-video-placeholder {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.2), rgba(255, 152, 0, 0.2));
        }

        .duck-video-icon {
            font-size: 48px;
            margin-bottom: 8px;
        }

        .duck-video-label {
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: bold;
        }

        .duck-video-player {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            /* GPU 加速 */
            transform: translateZ(0);
            will-change: contents;
        }

        /* 鴨子計數顯示 */
        .scalable-box {
            overflow: visible;
        }

        .scalable-box .scalable-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            white-space: nowrap;
        }

        .duck-counter-box {
            position: absolute;
            width: 200px;
            height: 100px;
            left: 50px;
            top: 50px;
            z-index: 200;
        }

        .duck-counter-box .scalable-content {
            min-width: 200px;
            height: 100px;
            padding: 0 25px;
            background: rgba(0, 0, 0, 0.5);
            border: 5px solid rgba(255, 193, 7, 0.9);
            border-radius: 20px;
            gap: 12px;
            box-shadow: 0 4px 20px rgba(255, 193, 7, 0.3);
        }

        .duck-counter-box.hidden {
            display: none !important;
        }

        .duck-counter-icon {
            font-size: 48px;
            animation: duckBounce 2s ease-in-out infinite;
            filter: hue-rotate(180deg);
        }

        @keyframes duckBounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .duck-counter-value {
            font-size: 64px;
            font-weight: bold;
            color: #ffc107;
            text-shadow: 0 0 20px rgba(255, 193, 7, 0.8), 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-family: 'Arial Black', sans-serif;
        }

        .duck-counter-add {
            position: absolute;
            top: -10px;
            right: -10px;
            font-size: 32px;
            font-weight: bold;
            color: #ff6b6b;
            text-shadow: 0 0 10px rgba(255, 107, 107, 0.8), 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-family: 'Arial Black', sans-serif;
            opacity: 0;
            pointer-events: none;
        }

        .duck-counter-add.show {
            animation: duckAddPop 1.5s ease-out forwards;
        }

        @keyframes duckAddPop {
            0% {
                opacity: 0;
                transform: translateY(10px) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translateY(-5px) scale(1.2);
            }
            40% {
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-30px) scale(0.8);
            }
        }

        /* 保底計數顯示 */
        .pity-counter-box {
            position: absolute;
            width: 180px;
            height: 80px;
            left: 50px;
            top: 170px;
            z-index: 200;
        }

        .pity-counter-box .scalable-content {
            min-width: 180px;
            height: 80px;
            padding: 0 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 4px solid rgba(147, 51, 234, 0.9);
            border-radius: 16px;
            flex-direction: column;
            gap: 4px;
            box-shadow: 0 4px 20px rgba(147, 51, 234, 0.3);
        }

        .pity-counter-box.hidden {
            display: none !important;
        }

        .pity-counter-label {
            font-size: 22px;
            font-weight: bold;
            color: #c084fc;
            text-shadow: 0 0 10px rgba(192, 132, 252, 0.5);
        }

        .pity-counter-value {
            font-size: 28px;
            font-weight: bold;
            color: #a855f7;
            text-shadow: 0 0 15px rgba(168, 85, 247, 0.8), 2px 2px 4px rgba(0, 0, 0, 0.8);
            font-family: 'Arial Black', sans-serif;
        }

        .pity-counter-value.stage2 {
            color: #f59e0b;
            text-shadow: 0 0 15px rgba(245, 158, 11, 0.8), 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .pity-counter-stage {
            font-size: 12px;
            color: #fbbf24;
            text-shadow: 0 0 8px rgba(251, 191, 36, 0.5);
        }

        /* 排行榜顯示 */
        .leaderboard-box {
            position: absolute;
            width: 280px;
            height: 120px;
            right: 50px;
            top: 50px;
            z-index: 200;
        }

        .leaderboard-box.hidden {
            display: none !important;
        }

        /* 霓虹邊框動畫 */
        @keyframes neonPulse {
            0%, 100% {
                box-shadow: 0 0 5px #ffc107, 0 0 10px #ffc107, 0 0 20px #ffc107, 0 0 40px #ff9800;
            }
            50% {
                box-shadow: 0 0 10px #ffc107, 0 0 20px #ffc107, 0 0 40px #ffc107, 0 0 80px #ff9800;
            }
        }

        @keyframes neonAvatarPulse {
            0%, 100% {
                box-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff, 0 0 15px #00ffff;
            }
            50% {
                box-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff, 0 0 30px #00ffff;
            }
        }

        .leaderboard-box .scalable-content {
            min-width: 320px;
            height: 100px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(20, 10, 40, 0.95));
            border: 2px solid transparent;
            border-image: linear-gradient(135deg, #ffc107, #ff6b6b, #a855f7) 1;
            border-radius: 12px;
            gap: 6px;
            padding: 10px 15px;
            flex-direction: column;
        }

        .leaderboard-box .scalable-content.neon-border {
            animation: neonPulse 2s ease-in-out infinite;
            box-shadow: 0 0 15px rgba(255, 193, 7, 0.4), inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .lb-row {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .lb-icon {
            font-size: 18px;
            width: 24px;
            text-align: center;
            filter: drop-shadow(0 0 5px currentColor);
        }

        .lb-icon.gold { color: #ffc107; }
        .lb-icon.purple { color: #a855f7; }

        .lb-avatar-mini {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: 2px solid;
            object-fit: cover;
            flex-shrink: 0;
        }

        .lb-avatar-mini.gold-border { border-color: #ffc107; box-shadow: 0 0 8px rgba(255, 193, 7, 0.5); }
        .lb-avatar-mini.purple-border { border-color: #a855f7; box-shadow: 0 0 8px rgba(168, 85, 247, 0.5); }

        .lb-avatar-mini.placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            font-size: 20px;
        }

        .lb-name {
            font-size: 13px;
            color: #fff;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
        }

        .lb-value {
            font-size: 18px;
            font-weight: bold;
            font-family: 'Arial Black', sans-serif;
            white-space: nowrap;
            text-shadow: 0 0 10px currentColor, 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .lb-value.gold { color: #ffc107; }
        .lb-value.purple { color: #a855f7; }

        /* 排行榜更新動畫 */
        @keyframes lbUpdate {
            0% { transform: scale(1); }
            30% { transform: scale(1.15); filter: brightness(1.5); }
            100% { transform: scale(1); filter: brightness(1); }
        }

        .lb-row.updating {
            animation: lbUpdate 0.5s ease-out;
        }

        .lb-row.updating .lb-value {
            animation: lbUpdate 0.5s ease-out;
        }

        .leaderboard-header {
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(255, 193, 7, 0.3), rgba(245, 158, 11, 0.2));
            border-bottom: 2px solid rgba(255, 193, 7, 0.5);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .leaderboard-title {
            font-size: 18px;
            font-weight: bold;
            color: #ffc107;
            text-shadow: 0 0 10px rgba(255, 193, 7, 0.5);
        }

        .leaderboard-tabs-gs {
            display: flex;
            gap: 4px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
        }

        .leaderboard-tab-gs {
            flex: 1;
            padding: 6px 10px;
            border: none;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .leaderboard-tab-gs:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .leaderboard-tab-gs.active {
            background: linear-gradient(135deg, #ffc107, #f59e0b);
            color: #1a1a24;
            font-weight: bold;
        }

        .leaderboard-scroll {
            flex: 1;
            overflow-y: auto;
            padding: 8px 12px;
        }

        .leaderboard-scroll.hidden {
            display: none;
        }

        .lb-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 10px;
            margin-bottom: 6px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            transition: all 0.2s;
        }

        .lb-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .lb-item.top-1 {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.3), rgba(255, 193, 7, 0.15));
            border: 1px solid rgba(255, 215, 0, 0.5);
        }

        .lb-item.first-only {
            padding: 12px 15px;
            margin-bottom: 0;
        }

        .lb-item.first-only .lb-rank {
            font-size: 28px;
        }

        .lb-item.first-only .lb-avatar {
            width: 48px;
            height: 48px;
        }

        .lb-item.first-only .lb-name {
            font-size: 18px;
        }

        .lb-item.first-only .lb-score {
            font-size: 20px;
        }

        .lb-item.top-2 {
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.2), rgba(169, 169, 169, 0.1));
            border: 1px solid rgba(192, 192, 192, 0.4);
        }

        .lb-item.top-3 {
            background: linear-gradient(135deg, rgba(205, 127, 50, 0.2), rgba(184, 115, 51, 0.1));
            border: 1px solid rgba(205, 127, 50, 0.4);
        }

        .lb-rank {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.7);
            flex-shrink: 0;
        }

        .lb-item.top-1 .lb-rank {
            background: linear-gradient(135deg, #ffd700, #ffb300);
            color: #1a1a24;
            font-size: 16px;
        }

        .lb-item.top-2 .lb-rank {
            background: linear-gradient(135deg, #c0c0c0, #a9a9a9);
            color: #1a1a24;
        }

        .lb-item.top-3 .lb-rank {
            background: linear-gradient(135deg, #cd7f32, #b8732d);
            color: #1a1a24;
        }

        .lb-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
            background: rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .lb-avatar.placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .lb-info {
            flex: 1;
            min-width: 0;
        }

        .lb-name {
            font-size: 14px;
            font-weight: 500;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .lb-score {
            font-weight: bold;
            font-size: 16px;
            color: #ffc107;
            white-space: nowrap;
            text-shadow: 0 0 8px rgba(255, 193, 7, 0.5);
        }

        .lb-empty {
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            padding: 20px;
            font-size: 14px;
        }

        /* 禮物圖顯示區域 */
        .gift-image-display {
            position: absolute;
            z-index: 250;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            min-width: 100px;
            min-height: 50px;
            overflow: hidden;
        }

        .gift-image-display .gift-image-wrapper {
            transform-origin: top left;
            display: inline-block;
        }

        .gift-image-display .gift-image-content {
            display: grid;
            border-radius: 16px;
            overflow: hidden;
        }

        .gift-image-display .gift-image-grid-item {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .gift-image-display .gift-image-grid-item img {
            object-fit: contain;
        }

        .gift-image-display .gift-label {
            white-space: nowrap;
            /* 加強文字邊緣，避免色度摳像後模糊 */
            text-shadow:
                -2px -2px 0 #000,
                2px -2px 0 #000,
                -2px 2px 0 #000,
                2px 2px 0 #000,
                0 0 8px rgba(0,0,0,0.8);
            -webkit-text-stroke: 1px rgba(0,0,0,0.5);
            font-weight: bold;
        }

        /* 里程碑慶祝容器 */
        .milestone-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            display: none;
            pointer-events: none;
        }

        .milestone-overlay.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .milestone-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            z-index: 1;
        }

        .milestone-content {
            position: relative;
            z-index: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            animation: milestonePopIn 0.5s ease-out;
        }

        @keyframes milestonePopIn {
            0% {
                transform: scale(0.5);
                opacity: 0;
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .milestone-avatar {
            width: 150px;
            height: 150px;
            border-radius: 50%;
            border: 5px solid gold;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.5);
            object-fit: cover;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
        }

        .milestone-avatar.placeholder {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 60px;
            background: linear-gradient(135deg, #ffd700, #ff8c00);
        }

        .milestone-badge {
            padding: 10px 30px;
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            border-radius: 30px;
            font-size: 24px;
            font-weight: bold;
            color: #1a1a2e;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 20px rgba(255, 215, 0, 0.5);
        }

        .milestone-title {
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8), 0 4px 8px rgba(0, 0, 0, 0.5);
            text-align: center;
        }

        .milestone-name {
            font-size: 36px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.6), 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .milestone-amount {
            font-size: 64px;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 30px rgba(255, 215, 0, 1), 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        .milestone-amount span {
            font-size: 48px;
        }

        /* 可拖曳進場影片容器 */
        .entry-video-container {
            position: absolute;
            width: 400px;
            height: 300px;
            overflow: hidden;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            top: 100px;
            left: 100px;
        }

        .entry-video-container.hidden {
            display: none !important;
            visibility: hidden !important;
        }

        .entry-video-container .entry-thumbnail {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            z-index: 1;
        }

        .entry-video-container.playing .entry-thumbnail {
            display: none !important;
        }

        .entry-video-container .entry-player {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            z-index: 2;
            display: none;
        }

        .entry-video-container.playing .entry-player {
            display: block !important;
        }

        .entry-audio {
            display: none;
        }

        /* 鎖鏈影片容器（左/中/右） */
        .chain-video-container {
            position: fixed;
            width: 300px;
            height: 400px;
            overflow: hidden;
            background: transparent;
            z-index: 3000;
            display: none;
        }

        .chain-video-container.left {
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
        }

        .chain-video-container.center {
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .chain-video-container.right {
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
        }

        .chain-video-container.active {
            display: block;
        }

        .chain-video-container video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* 進場文字容器 */
        .entry-text-container {
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            min-width: 200px;
            min-height: 60px;
            width: fit-content !important;  /* 確保寬度自動適應文字 */
            max-width: none !important;     /* 移除最大寬度限制 */
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2500;  /* 比影片容器(2000)更高，確保文字在上面 */
            white-space: nowrap;            /* 防止換行 */
        }

        .entry-text-container.hidden {
            display: none !important;
        }

        .entry-text {
            font-weight: bold;
            text-shadow:
                3px 3px 6px rgba(0,0,0,0.8),
                -1px -1px 0 rgba(0,0,0,0.5),
                1px -1px 0 rgba(0,0,0,0.5),
                -1px 1px 0 rgba(0,0,0,0.5),
                1px 1px 0 rgba(0,0,0,0.5);
            white-space: nowrap;
            animation: entryTextFadeIn 0.5s ease-out;
        }

        @keyframes entryTextFadeIn {
            from {
                opacity: 0;
                transform: scale(0.8) translateY(20px);
            }
            to {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        @keyframes entryTextFadeOut {
            from {
                opacity: 1;
                transform: scale(1);
            }
            to {
                opacity: 0;
                transform: scale(1.1);
            }
        }

        .entry-text.fade-out {
            animation: entryTextFadeOut 0.5s ease-in forwards;
        }

        /* 盲盒容器 */
        .giftbox-container {
            position: absolute;
            top: 150px;
            right: 50px;
            width: 200px;
            height: 200px;
            z-index: 50;
        }

        .giftbox-container.hidden {
            display: none;
        }

        .giftbox-box {
            position: relative;
            width: 100%;
            height: 100%;
            perspective: 1000px;
        }

        .giftbox-base {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 140px;
            height: 100px;
            background: linear-gradient(135deg, #e94560, #c13550);
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .giftbox-base::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 100%;
            background: linear-gradient(135deg, #ffd93d, #f5c800);
        }

        .giftbox-lid {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 40px;
            background: linear-gradient(135deg, #e94560, #c13550);
            border-radius: 10px 10px 0 0;
            transform-origin: bottom center;
            transition: transform 0.5s ease;
        }

        .giftbox-lid::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 30px;
            background: linear-gradient(135deg, #ffd93d, #f5c800);
            border-radius: 50% 50% 0 0;
        }

        .giftbox-box.opening .giftbox-lid {
            transform: translateX(-50%) rotateX(-120deg);
        }

        .giftbox-box.rolling {
            animation: box-shake 0.15s ease-in-out infinite;
        }

        @keyframes box-shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-3px) rotate(-1deg); }
            75% { transform: translateX(3px) rotate(1deg); }
        }

        .giftbox-result {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%) scale(0);
            padding: 15px 30px;
            background: linear-gradient(135deg, #4ecca3, #38b892);
            color: white;
            font-size: 24px;
            font-weight: bold;
            border-radius: 10px;
            white-space: nowrap;
            opacity: 0;
            transition: all 0.3s ease;
            box-shadow: 0 5px 20px rgba(78, 204, 163, 0.5);
        }

        .giftbox-box.rolling .giftbox-result {
            transform: translateX(-50%) scale(1);
            opacity: 1;
            animation: roll-flip 0.1s ease-out;
        }

        @keyframes roll-flip {
            0% {
                transform: translateX(-50%) scale(0.8) translateY(10px);
                opacity: 0.5;
            }
            100% {
                transform: translateX(-50%) scale(1) translateY(0);
                opacity: 1;
            }
        }

        .giftbox-box.showing-result .giftbox-result {
            transform: translateX(-50%) scale(1.2);
            opacity: 1;
            animation: result-bounce 0.5s ease-out, result-glow 1.5s ease-in-out infinite;
        }

        @keyframes result-bounce {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.4); }
            100% { transform: translateX(-50%) scale(1.2); }
        }

        @keyframes result-glow {
            0%, 100% {
                box-shadow: 0 5px 20px rgba(78, 204, 163, 0.5),
                            0 0 30px rgba(255, 255, 255, 0.3);
            }
            50% {
                box-shadow: 0 5px 30px rgba(78, 204, 163, 0.8),
                            0 0 50px rgba(255, 255, 255, 0.5),
                            0 0 80px rgba(78, 204, 163, 0.4);
            }
        }

        /* 盲盒彩帶效果 */
        .giftbox-confetti {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .confetti-piece {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(200px) rotate(720deg);
                opacity: 0;
            }
        }

        /* 盲盒倒數計時 */
        .giftbox-countdown {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%) scale(0);
            font-size: 72px;
            font-weight: bold;
            color: #ffd93d;
            text-shadow: 0 0 20px rgba(255, 217, 61, 0.8), 0 4px 8px rgba(0,0,0,0.5);
            opacity: 0;
            z-index: 10;
        }

        .giftbox-countdown.active {
            animation: countdown-pop 1s ease-out;
        }

        @keyframes countdown-pop {
            0% {
                transform: translateX(-50%) scale(0);
                opacity: 0;
            }
            30% {
                transform: translateX(-50%) scale(1.3);
                opacity: 1;
            }
            100% {
                transform: translateX(-50%) scale(1);
                opacity: 0;
            }
        }

        /* 盲盒影片容器 */
        .giftbox-video-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            z-index: 100;
        }

        .giftbox-video-container.active {
            display: block;
        }

        .giftbox-video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* 盲盒自動顯示狀態 */
        .giftbox-container.auto-hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transform: scale(0.8);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out, visibility 0s 0.3s;
        }

        .giftbox-container.auto-hidden.triggered {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transform: scale(1);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out, visibility 0s 0s;
        }

        /* ========== 鎖鏈對抗 ========== */
        .chain-battle-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9000;
            display: none;
            pointer-events: none;
        }

        .chain-battle-overlay.active {
            display: block;
            pointer-events: auto;  /* 鎖定期間攔截所有點擊 */
            cursor: not-allowed;
        }

        /* 鎖定期間禁用所有拖曳元素 */
        body.chain-locked .draggable {
            pointer-events: none !important;
        }

        body.chain-locked .debug-panel {
            pointer-events: none !important;
            opacity: 0.5;
        }

        /* 鎖鏈邊框效果 */
        .chain-border {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 20px solid transparent;
            border-image: repeating-linear-gradient(
                45deg,
                #666 0px,
                #666 10px,
                #888 10px,
                #888 20px,
                #aaa 20px,
                #aaa 30px
            ) 20;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.5);
            animation: chainPulse 0.5s ease-in-out infinite;
        }

        @keyframes chainPulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        /* 四角鎖鏈圖示 */
        .chain-corner {
            position: absolute;
            font-size: 60px;
            filter: drop-shadow(0 0 10px rgba(255, 100, 0, 0.8));
            animation: chainSwing 0.3s ease-in-out infinite alternate;
        }

        .chain-corner.tl { top: 30px; left: 30px; }
        .chain-corner.tr { top: 30px; right: 30px; }
        .chain-corner.bl { bottom: 30px; left: 30px; }
        .chain-corner.br { bottom: 30px; right: 30px; }

        @keyframes chainSwing {
            0% { transform: rotate(-5deg); }
            100% { transform: rotate(5deg); }
        }

        /* 中央計數器 */
        .chain-counter-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        .chain-title {
            font-size: 36px;
            color: #ff6b35;
            text-shadow:
                0 0 20px rgba(255, 107, 53, 0.8),
                2px 2px 4px #000;
            margin-bottom: 20px;
            font-weight: bold;
            white-space: nowrap;
        }

        .chain-counter {
            font-size: 120px;
            font-weight: bold;
            color: #fff;
            text-shadow:
                0 0 30px rgba(255, 50, 50, 1),
                0 0 60px rgba(255, 50, 50, 0.8),
                4px 4px 8px #000;
            font-family: 'Arial Black', sans-serif;
            animation: counterPulse 0.2s ease-in-out infinite;
            min-width: 200px;
        }

        @keyframes counterPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .chain-hint {
            font-size: 24px;
            color: #ffd700;
            text-shadow: 2px 2px 4px #000;
            margin-top: 20px;
            white-space: nowrap;
        }

        .chain-hint .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #ffd700;
            border-radius: 8px;
            padding: 5px 20px;
            margin: 0 5px;
            font-weight: bold;
        }

        /* 掙脫成功動畫 */
        .chain-battle-overlay.breaking .chain-border {
            animation: chainBreak 0.5s ease-out forwards;
        }

        .chain-battle-overlay.breaking .chain-corner {
            animation: chainFlyAway 0.5s ease-out forwards;
        }

        .chain-battle-overlay.breaking .chain-counter {
            color: #00ff00;
            text-shadow:
                0 0 30px rgba(0, 255, 0, 1),
                0 0 60px rgba(0, 255, 0, 0.8);
        }

        @keyframes chainBreak {
            0% { opacity: 1; border-width: 20px; }
            100% { opacity: 0; border-width: 0px; }
        }

        @keyframes chainFlyAway {
            0% { opacity: 1; transform: scale(1); }
            100% { opacity: 0; transform: scale(2) rotate(180deg); }
        }

        /* 增加鎖鏈動畫 */
        .chain-counter.adding {
            animation: counterAdd 0.3s ease-out;
            color: #ff0000 !important;
        }

        @keyframes counterAdd {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* 減少鎖鏈動畫 */
        .chain-counter.removing {
            animation: counterRemove 0.1s ease-out;
            color: #00ff00 !important;
        }

        @keyframes counterRemove {
            0% { transform: scale(1); }
            50% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }

        /* 勝利文字 */
        .chain-victory {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #00ff00;
            text-shadow:
                0 0 30px rgba(0, 255, 0, 1),
                0 0 60px rgba(0, 255, 0, 0.8),
                4px 4px 8px #000;
            font-weight: bold;
            display: none;
            animation: victoryPop 0.5s ease-out;
            white-space: nowrap;
        }

        .chain-battle-overlay.victory .chain-victory {
            display: block;
        }

        .chain-battle-overlay.victory .chain-counter-container {
            display: none;
        }

        @keyframes victoryPop {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        /* 鎖鏈飄動數字容器 */
        .chain-floating-numbers {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 10001;
        }

        /* 鎖鏈飄動數字 */
        .chain-floating-number {
            position: absolute;
            font-size: 48px;
            font-weight: bold;
            font-family: "Microsoft YaHei", sans-serif;
            text-shadow: 0 0 20px currentColor, 0 2px 4px rgba(0,0,0,0.5);
            animation: chainFloatUp 1.5s ease-out forwards;
            white-space: nowrap;
        }

        .chain-floating-number.add {
            color: #ff4500;
        }

        .chain-floating-number.remove {
            color: #4ade80;
        }

        @keyframes chainFloatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            50% {
                opacity: 1;
                transform: translateY(-60px) scale(1.2);
            }
            100% {
                opacity: 0;
                transform: translateY(-120px) scale(0.8);
            }
        }
    </style>
</head>
<body class="initializing">
    <!-- 視窗控制列 (滑鼠移到頂部顯示) -->
    <div class="window-controls" id="windowControls">
        <span class="title">綠幕視窗 (按 Tab 調整設定)</span>
        <div class="buttons">
            <button class="btn" onclick="minimizeWindow()" title="最小化">─</button>
            <button class="btn" onclick="toggleMaximize()" title="最大化/還原">□</button>
            <button class="btn close" onclick="closeWindow()" title="關閉">✕</button>
        </div>
    </div>

    <!-- 全屏進場容器 -->
    <div class="entry-container" id="entryContainer">
        <video class="entry-video" id="entryVideo"></video>
        <audio class="entry-audio" id="entryAudio"></audio>
    </div>

    <!-- 鎖鏈對抗音效 -->
    <audio id="chainSoundLock" src="sounds/chain_lock.mp3" preload="auto"></audio>
    <audio id="chainSoundRattle" src="sounds/chain_rattle.mp3" preload="auto"></audio>
    <audio id="chainSoundVictory" src="sounds/chain_victory.mp3" preload="auto"></audio>

    <!-- 鎖鏈對抗 -->
    <div class="chain-battle-overlay" id="chainBattleOverlay">
        <div class="chain-border"></div>
        <div class="chain-corner tl">⛓️</div>
        <div class="chain-corner tr">⛓️</div>
        <div class="chain-corner bl">⛓️</div>
        <div class="chain-corner br">⛓️</div>
        <div class="chain-counter-container">
            <div class="chain-title">⛓️ 鎖鏈對抗 ⛓️</div>
            <div class="chain-counter" id="chainCounter">20</div>
            <div class="chain-hint">主播按 <span class="key">空白鍵</span> 掙脫！</div>
        </div>
        <div class="chain-victory">🎉 掙脫成功！</div>
        <div class="chain-floating-numbers" id="chainFloatingNumbers"></div>
    </div>

    <!-- 隨機影片專用容器（可拖曳縮圖版） -->
    <div class="draggable random-video-box hidden" id="randomVideoContainer">
        <div class="random-video-placeholder">
            <span class="random-video-icon">🎲</span>
            <span class="random-video-label">隨機影片</span>
        </div>
        <video class="random-video-player" id="randomVideoPlayer"></video>
        <div class="resize-handle nw"></div>
        <div class="resize-handle n"></div>
        <div class="resize-handle ne"></div>
        <div class="resize-handle w"></div>
        <div class="resize-handle e"></div>
        <div class="resize-handle sw"></div>
        <div class="resize-handle s"></div>
        <div class="resize-handle se"></div>
    </div>

    <!-- 抓鴨子影片容器 -->
    <div class="draggable duck-video-box hidden" id="duckVideoContainer">
        <div class="duck-video-placeholder">
            <span class="duck-video-icon">🦆</span>
            <span class="duck-video-label">抓鴨子</span>
        </div>
        <video class="duck-video-player" id="duckVideoPlayer" preload="auto" playsinline disablepictureinpicture></video>
        <div class="resize-handle nw"></div>
        <div class="resize-handle n"></div>
        <div class="resize-handle ne"></div>
        <div class="resize-handle w"></div>
        <div class="resize-handle e"></div>
        <div class="resize-handle sw"></div>
        <div class="resize-handle s"></div>
        <div class="resize-handle se"></div>
    </div>

    <!-- 鴨子計數顯示 -->
    <div class="draggable duck-counter-box scalable-box hidden" id="duckCounterBox" data-base-width="200" data-base-height="100">
        <div class="scalable-content">
            <span class="duck-counter-icon">🦆</span>
            <span class="duck-counter-value" id="duckCounterValue">0</span>
            <span class="duck-counter-add" id="duckCounterAdd"></span>
        </div>
        <div class="resize-handle nw"></div>
        <div class="resize-handle n"></div>
        <div class="resize-handle ne"></div>
        <div class="resize-handle w"></div>
        <div class="resize-handle e"></div>
        <div class="resize-handle sw"></div>
        <div class="resize-handle s"></div>
        <div class="resize-handle se"></div>
    </div>

    <!-- 保底計數顯示 -->
    <div class="draggable pity-counter-box scalable-box hidden" id="pityCounterBox" data-base-width="180" data-base-height="80">
        <div class="scalable-content">
            <span class="pity-counter-label">🎰 保底進度</span>
            <span class="pity-counter-value" id="pityCounterValue">0 / 1000</span>
            <span class="pity-counter-stage" id="pityCounterStage"></span>
        </div>
        <div class="resize-handle nw"></div>
        <div class="resize-handle n"></div>
        <div class="resize-handle ne"></div>
        <div class="resize-handle w"></div>
        <div class="resize-handle e"></div>
        <div class="resize-handle sw"></div>
        <div class="resize-handle s"></div>
        <div class="resize-handle se"></div>
    </div>

    <!-- 排行榜 -->
    <div class="draggable leaderboard-box scalable-box hidden" id="leaderboardBox" data-base-width="320" data-base-height="100">
        <div class="scalable-content lb-simple neon-border" id="gsLeaderboardSimple">
            <div class="lb-row">
                <span class="lb-icon gold">👑</span>
                <div class="lb-avatar-mini gold-border placeholder">🦆</div>
                <span class="lb-name">---</span>
                <span class="lb-value gold">0🦆</span>
            </div>
            <div class="lb-row">
                <span class="lb-icon purple">⭐</span>
                <div class="lb-avatar-mini purple-border placeholder">🦆</div>
                <span class="lb-name">---</span>
                <span class="lb-value purple">0🦆</span>
            </div>
        </div>
        <div class="resize-handle nw"></div>
        <div class="resize-handle n"></div>
        <div class="resize-handle ne"></div>
        <div class="resize-handle w"></div>
        <div class="resize-handle e"></div>
        <div class="resize-handle sw"></div>
        <div class="resize-handle s"></div>
        <div class="resize-handle se"></div>
    </div>

    <!-- 禮物圖顯示區域 -->
    <div class="draggable gift-image-display" id="giftImageDisplay" style="display: none;">
        <div class="gift-image-wrapper" id="giftImageWrapper">
            <div class="gift-image-content" id="giftImageContent"></div>
        </div>
        <div class="resize-handle nw"></div>
        <div class="resize-handle n"></div>
        <div class="resize-handle ne"></div>
        <div class="resize-handle w"></div>
        <div class="resize-handle e"></div>
        <div class="resize-handle sw"></div>
        <div class="resize-handle s"></div>
        <div class="resize-handle se"></div>
    </div>

    <!-- 里程碑慶祝 -->
    <div class="milestone-overlay" id="milestoneOverlay">
        <video class="milestone-video" id="milestoneVideo" muted></video>
        <div class="milestone-content">
            <div class="milestone-badge" id="milestoneBadge">🏆 累計第一</div>
            <img class="milestone-avatar" id="milestoneAvatar" src="" alt="">
            <div class="milestone-title">🎉 恭喜 🎉</div>
            <div class="milestone-name" id="milestoneName">用戶名稱</div>
            <div class="milestone-amount"><span id="milestoneAmount">10,000</span>🦆</div>
        </div>
    </div>

    <!-- 進場文字 -->
    <div class="draggable entry-text-container hidden" id="entryTextContainer">
        <span class="entry-text" id="entryText"></span>
        <div class="resize-handle nw"></div>
        <div class="resize-handle n"></div>
        <div class="resize-handle ne"></div>
        <div class="resize-handle w"></div>
        <div class="resize-handle e"></div>
        <div class="resize-handle sw"></div>
        <div class="resize-handle s"></div>
        <div class="resize-handle se"></div>
    </div>

    <!-- 進場影片容器 -->
    <div class="draggable entry-video-container hidden" id="entryVideoContainer">
        <video class="entry-thumbnail" id="entryThumbnail" muted preload="metadata"></video>
        <video class="entry-player" id="entryPlayer"></video>
        <audio class="entry-player-audio" id="entryPlayerAudio"></audio>
        <div class="resize-handle nw"></div>
        <div class="resize-handle n"></div>
        <div class="resize-handle ne"></div>
        <div class="resize-handle w"></div>
        <div class="resize-handle e"></div>
        <div class="resize-handle sw"></div>
        <div class="resize-handle s"></div>
        <div class="resize-handle se"></div>
    </div>

    <!-- 鎖鏈影片容器（左） -->
    <div class="chain-video-container left" id="chainVideoLeft">
        <video id="chainVideoPlayerLeft" muted></video>
    </div>

    <!-- 鎖鏈影片容器（中） -->
    <div class="chain-video-container center" id="chainVideoCenter">
        <video id="chainVideoPlayerCenter" muted></video>
    </div>

    <!-- 鎖鏈影片容器（右） -->
    <div class="chain-video-container right" id="chainVideoRight">
        <video id="chainVideoPlayerRight" muted></video>
    </div>

    <!-- 轉盤 -->
    <div class="draggable wheel-container hidden" id="wheelContainer">
        <canvas id="wheelCanvas" width="350" height="350"></canvas>
        <div class="resize-handle nw"></div>
        <div class="resize-handle n"></div>
        <div class="resize-handle ne"></div>
        <div class="resize-handle w"></div>
        <div class="resize-handle e"></div>
        <div class="resize-handle sw"></div>
        <div class="resize-handle s"></div>
        <div class="resize-handle se"></div>
    </div>

    <!-- 盲盒 -->
    <div class="draggable giftbox-container hidden" id="giftboxContainer">
        <div class="giftbox-box" id="giftboxBox">
            <div class="giftbox-confetti" id="giftboxConfetti"></div>
            <div class="giftbox-base"></div>
            <div class="giftbox-lid"></div>
            <div class="giftbox-result" id="giftboxResult"></div>
            <div class="giftbox-countdown" id="giftboxCountdown">3</div>
        </div>
        <div class="giftbox-video-container" id="giftboxVideoContainer">
            <video class="giftbox-video" id="giftboxVideo"></video>
        </div>
        <div class="resize-handle nw"></div>
        <div class="resize-handle n"></div>
        <div class="resize-handle ne"></div>
        <div class="resize-handle w"></div>
        <div class="resize-handle e"></div>
        <div class="resize-handle sw"></div>
        <div class="resize-handle s"></div>
        <div class="resize-handle se"></div>
    </div>

    <!-- 影片容器區域 - 動態生成 -->
    <div id="videoContainersArea"></div>

    <!-- 調試面板 -->
    <div class="debug-panel" id="debugPanel">
        <h3>控制面板 <span class="debug-hint-text">Tab 關閉</span></h3>

        <!-- 快速操作 -->
        <div class="debug-quick-actions">
            <button class="debug-btn-mini" onclick="hideAllElements()" title="隱藏全部">👁️‍🗨️ 全部隱藏</button>
            <button class="debug-btn-mini" onclick="showAllElements()" title="顯示全部">👁️ 全部顯示</button>
        </div>

        <div class="debug-section">
            <h4>🎮 遊戲元素</h4>
            <div class="debug-grid">
                <div class="debug-chip" id="toggleWheel" onclick="toggleWheelVisibility()">🎡 轉盤</div>
                <div class="debug-chip" id="toggleGiftbox" onclick="toggleGiftboxVisibility()">🎁 盲盒</div>
                <div class="debug-chip" id="toggleGiftboxAutoHide" onclick="toggleGiftboxAutoHide()">⏱️ 盲盒自動隱藏</div>
            </div>
        </div>

        <div class="debug-section">
            <h4>🎬 影片控制</h4>
            <div class="debug-grid">
                <div class="debug-chip" id="toggleVideo" onclick="toggleVideoVisibility()">📹 禮物影片</div>
                <div class="debug-chip" id="toggleEntryVideo" onclick="toggleEntryVideoVisibility()">👋 進場影片</div>
                <div class="debug-chip" id="toggleRandomVideo" onclick="toggleRandomVideoVisible(); document.getElementById('toggleRandomVideo').classList.toggle('active', randomVideoVisible);">🎲 隨機影片</div>
                <div class="debug-chip" id="toggleDuckVideo" onclick="toggleDuckVideoVisible(); document.getElementById('toggleDuckVideo').classList.toggle('active', duckVideoVisible);">🦆 抓鴨影片</div>
            </div>
        </div>

        <div class="debug-section">
            <h4>📊 統計顯示</h4>
            <div class="debug-grid">
                <div class="debug-chip" id="toggleDuckCounter" onclick="toggleDuckCounterVisible(); document.getElementById('toggleDuckCounter').classList.toggle('active', duckCounterVisible);">🦆 鴨子計數</div>
                <div class="debug-chip" id="togglePityCounter" onclick="togglePityCounterVisible(); document.getElementById('togglePityCounter').classList.toggle('active', pityCounterVisible);">🎰 保底計數</div>
                <div class="debug-chip" id="toggleLeaderboard" onclick="toggleLeaderboardVisible(); document.getElementById('toggleLeaderboard').classList.toggle('active', leaderboardVisible);">🏆 排行榜</div>
            </div>
        </div>

        <div class="debug-section">
            <h4>🧪 測試功能</h4>
            <div class="debug-btn-grid">
                <button class="debug-btn compact" id="testWheelBtn" onclick="testWheelSpin()">🎡 轉盤</button>
                <button class="debug-btn compact" id="testGiftboxBtn" onclick="testGiftboxOpen()">🎁 盲盒</button>
                <button class="debug-btn compact" onclick="testEntryText()">📝 文字</button>
                <button class="debug-btn compact" onclick="testEntryVideo()">🎬 進場</button>
            </div>
            <div class="debug-btn-grid" style="margin-top: 6px;">
                <button class="debug-btn compact secondary" onclick="reloadAllThumbnails()">🔄 重載縮圖</button>
                <button class="debug-btn compact danger" onclick="resetAllCropStates()">✂️ 重置裁切</button>
            </div>
        </div>

        <div class="debug-section collapsible">
            <h4 onclick="toggleSection(this)">
                <span>📋 影片列表</span>
                <span class="collapse-icon">▼</span>
            </h4>
            <div class="section-content">
                <div class="video-list compact" id="videoList">
                    <div class="empty-list">載入中...</div>
                </div>
            </div>
        </div>

        <div class="debug-section collapsible">
            <h4 onclick="toggleSection(this)">
                <span>👋 進場列表</span>
                <span class="collapse-icon">▼</span>
            </h4>
            <div class="section-content">
                <div class="video-list compact" id="entryList">
                    <div class="empty-list">載入中...</div>
                </div>
            </div>
        </div>
    </div>

    <!-- 提示 -->
    <div class="debug-hint" id="debugHint">按 Tab 鍵開啟調試面板</div>

    <!-- 右鍵選單 -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" onclick="toggleWheelVisibility()">
            <span class="checkmark" id="wheelCheck">✓</span>
            <span>顯示轉盤</span>
        </div>
        <div class="context-menu-item" onclick="toggleGiftboxVisibility()">
            <span class="checkmark" id="giftboxCheck">✓</span>
            <span>顯示盲盒</span>
        </div>
        <div class="context-menu-item" onclick="toggleGiftboxAutoHide()">
            <span class="checkmark" id="giftboxAutoHideCheck"></span>
            <span>盲盒自動隱藏</span>
        </div>
        <div class="context-menu-item" onclick="toggleVideoVisibility()">
            <span class="checkmark" id="videoCheck">✓</span>
            <span>顯示影片</span>
        </div>
        <div class="context-menu-item" onclick="toggleDebugPanel()">
            <span class="checkmark" id="debugCheck"></span>
            <span>開啟調試面板</span>
        </div>
    </div>

    <!-- 元素右鍵選單 (圖層控制) -->
    <div class="context-menu" id="elementContextMenu">
        <div class="context-menu-header" id="elementMenuTitle">元素控制</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="moveLayerToTop()">
            <span class="menu-icon">⬆️</span>
            <span>移到最上層</span>
        </div>
        <div class="context-menu-item" onclick="moveLayerUp()">
            <span class="menu-icon">🔼</span>
            <span>上移一層</span>
        </div>
        <div class="context-menu-item" onclick="moveLayerDown()">
            <span class="menu-icon">🔽</span>
            <span>下移一層</span>
        </div>
        <div class="context-menu-item" onclick="moveLayerToBottom()">
            <span class="menu-icon">⬇️</span>
            <span>移到最下層</span>
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" onclick="hideCurrentElement()">
            <span class="menu-icon">👁️</span>
            <span>隱藏此元素</span>
        </div>
    </div>

    <script>
        // === 調試設定 (商用版本請設為 false) ===
        const DEBUG_MODE = false;
        const debugLog = (...args) => { if (DEBUG_MODE) console.log(...args); };

        // === 全域變數 ===
        let wheelOptions = [];
        let giftboxOptions = [];
        let videoGifts = [];
        let wheelAngle = 0;
        let wheelVisible = false;
        let giftboxVisible = false;
        let giftboxAutoHide = false;  // 盲盒自動隱藏模式
        let videoVisible = false;
        let wheelModuleEnabled = true;  // 轉盤模組是否啟用
        let giftboxModuleEnabled = false;  // 盲盒模組是否啟用
        let isSpinning = false;
        let isGiftboxOpening = false;
        let debugPanelVisible = false;

        // 影片容器資料 (每個影片一個容器)
        let videoContainers = {};  // { index: { visible, width, height, left, top } }

        // 各容器的播放狀態
        let containerPlayingState = {};  // { index: { isPlaying, queue, wasHidden } }

        // 每個影片容器的裁切狀態
        let videoCropState = {};  // { index: { cropLeft, cropTop, originalWidth, originalHeight } }

        // 儲存的位置資料（從配置載入）
        let savedPositions = null;

        // === 初始化 ===
        document.addEventListener('DOMContentLoaded', async () => {
            await waitForPywebview();

            // 1. 先載入儲存的位置資料
            savedPositions = await loadSavedPositions();

            // 2. 載入轉盤選項、盲盒選項、影片列表和進場列表
            await loadWheelOptions();
            await loadGiftboxOptions();
            await loadVideoGifts();  // 這裡會生成容器並套用位置
            await loadEntryList();   // 載入進場效果列表

            // 3. 套用轉盤、盲盒、進場文字、進場影片、隨機影片位置
            applyWheelPosition();
            applyGiftboxPosition();
            applyEntryTextPosition();
            applyEntryVideoPosition();
            applyRandomVideoPosition();
            applyDuckPositions();

            // 載入初始保底計數
            if (window.pywebview && window.pywebview.api) {
                try {
                    const pityData = await pywebview.api.get_pity_counter();
                    if (pityData) {
                        updatePityCounter(pityData);
                    }
                } catch (e) {
                    console.error('載入保底計數失敗:', e);
                }

                // 載入初始排行榜
                try {
                    const lbData = await pywebview.api.get_leaderboard();
                    if (lbData) {
                        updateLeaderboard(lbData);
                    }
                } catch (e) {
                    console.error('載入排行榜失敗:', e);
                }
            }

            // 4. 檢查模組狀態
            await loadModuleStatus();

            // 5. 初始化其他功能
            drawWheel();
            initDraggable();
            initResizable();
            initContextMenu();
            applyElementZIndexes();  // 套用儲存的圖層順序
            initMessageListener();
            initKeyboardShortcuts();
            showHint();

            // 3秒後自動隱藏視窗控制列（但滑鼠移上去還是會顯示）
            setTimeout(() => {
                const controls = document.getElementById('windowControls');
                if (controls) {
                    controls.classList.add('auto-hide');
                }
            }, 3000);

            // 移除初始化狀態，顯示所有已配置的元素
            requestAnimationFrame(() => {
                document.body.classList.remove('initializing');
            });

            // 延遲重新載入縮圖
            setTimeout(() => {
                debugLog('[初始化] 完成，重載縮圖');
                reloadAllThumbnails();
            }, 500);
        });

        // 載入儲存的位置資料
        async function loadSavedPositions() {
            try {
                if (window.pywebview && window.pywebview.api) {
                    const positions = await pywebview.api.get_greenscreen_positions();
                    console.log('[位置] 載入儲存資料:', positions ? '有資料' : '無資料');
                    return positions || null;
                }
            } catch (e) {
                console.error('[位置] 載入失敗:', e);
            }
            return null;
        }

        // 套用轉盤位置
        function applyWheelPosition() {
            if (!savedPositions || !savedPositions.wheel) {
                console.log('[轉盤] 使用預設位置');
                return;
            }

            const wheel = document.getElementById('wheelContainer');
            const canvas = document.getElementById('wheelCanvas');
            const data = savedPositions.wheel;

            // 套用尺寸和位置
            const w = Math.max(50, data.width || 350);
            const h = Math.max(50, data.height || 350);
            wheel.style.width = w + 'px';
            wheel.style.height = h + 'px';
            wheel.style.left = (data.left || 0) + 'px';
            wheel.style.top = (data.top || 150) + 'px';
            wheel.style.transform = 'none';
            canvas.width = w;
            canvas.height = h;

            // 套用顯示狀態
            if (data.visible === false) {
                wheelVisible = false;
                setElementVisible(wheel, false);
                document.getElementById('wheelCheck').textContent = '';
                document.getElementById('toggleWheel').classList.remove('active');
            } else {
                wheelVisible = true;
                setElementVisible(wheel, true);
                document.getElementById('wheelCheck').textContent = '✓';
                document.getElementById('toggleWheel').classList.add('active');
            }

            console.log('[轉盤] 已套用位置:', w, 'x', h, '顯示:', wheelVisible);
        }

        // 通用的顯示/隱藏函數
        function setElementVisible(el, visible) {
            if (visible) {
                el.classList.remove('hidden');
                el.style.display = 'block';
                el.style.visibility = 'visible';
                el.style.opacity = '1';
            } else {
                el.classList.add('hidden');
                el.style.display = 'none';
                el.style.visibility = 'hidden';
                el.style.opacity = '0';
            }
        }

        // 套用盲盒位置
        function applyGiftboxPosition() {
            const giftbox = document.getElementById('giftboxContainer');
            if (!giftbox) return;

            if (savedPositions && savedPositions.giftbox) {
                const data = savedPositions.giftbox;
                const w = Math.max(50, data.width || 200);
                const h = Math.max(50, data.height || 200);
                giftbox.style.width = w + 'px';
                giftbox.style.height = h + 'px';
                giftbox.style.left = (data.left || 0) + 'px';
                giftbox.style.top = (data.top || 150) + 'px';
                giftbox.style.right = 'auto';
                giftbox.style.transform = 'none';

                if (data.visible === false) {
                    giftboxVisible = false;
                    setElementVisible(giftbox, false);
                    document.getElementById('giftboxCheck').textContent = '';
                    document.getElementById('toggleGiftbox').classList.remove('active');
                } else {
                    giftboxVisible = true;
                    setElementVisible(giftbox, true);
                    document.getElementById('giftboxCheck').textContent = '✓';
                    document.getElementById('toggleGiftbox').classList.add('active');
                }

                // 自動隱藏模式
                if (data.autoHide === true) {
                    giftboxAutoHide = true;
                    giftbox.classList.add('auto-hidden');
                    document.getElementById('giftboxAutoHideCheck').textContent = '✓';
                    document.getElementById('toggleGiftboxAutoHide').classList.add('active');
                } else {
                    giftboxAutoHide = false;
                    giftbox.classList.remove('auto-hidden');
                    document.getElementById('giftboxAutoHideCheck').textContent = '';
                    document.getElementById('toggleGiftboxAutoHide').classList.remove('active');
                }

                console.log('[盲盒] 已套用位置:', w, 'x', h, '顯示:', giftboxVisible, '自動隱藏:', giftboxAutoHide);
            } else {
                console.log('[盲盒] 使用預設位置');
                giftbox.style.right = '50px';
                giftbox.style.left = 'auto';
            }
        }

        // 套用進場文字位置
        function applyEntryTextPosition() {
            const entryText = document.getElementById('entryTextContainer');
            if (!entryText) return;

            if (savedPositions && savedPositions.entryText) {
                const data = savedPositions.entryText;
                entryText.style.left = (data.left || 0) + 'px';
                entryText.style.top = (data.top || 50) + 'px';
                entryText.style.transform = 'none';
                console.log('[進場文字] 已套用位置:', data.left, ',', data.top);
            } else {
                console.log('[進場文字] 使用預設位置');
                // 預設置中
                entryText.style.left = '50%';
                entryText.style.top = '50px';
                entryText.style.transform = 'translateX(-50%)';
            }
        }

        function applyEntryVideoPosition() {
            const entryVideo = document.getElementById('entryVideoContainer');
            if (!entryVideo) return;

            if (savedPositions && savedPositions.entryVideo) {
                const data = savedPositions.entryVideo;
                entryVideo.style.width = (data.width || 400) + 'px';
                entryVideo.style.height = (data.height || 300) + 'px';
                entryVideo.style.left = (data.left || 100) + 'px';
                entryVideo.style.top = (data.top || 100) + 'px';

                // 設定顯示狀態
                entryVideoVisible = data.visible || false;
                setElementVisible(entryVideo, entryVideoVisible);
                document.getElementById('toggleEntryVideo')?.classList.toggle('active', entryVideoVisible);

                // 更新進場列表中的按鈕狀態
                updateEntryVisibilityButtons();

                console.log('[進場影片] 已套用位置:', data);
            } else {
                console.log('[進場影片] 使用預設位置');
                entryVideo.style.width = '400px';
                entryVideo.style.height = '300px';
                entryVideo.style.left = '100px';
                entryVideo.style.top = '100px';
                setElementVisible(entryVideo, false);
            }
        }

        // 套用隨機影片位置
        function applyRandomVideoPosition() {
            const randomVideo = document.getElementById('randomVideoContainer');
            if (!randomVideo) return;

            if (savedPositions && savedPositions.randomVideo) {
                const data = savedPositions.randomVideo;
                randomVideo.style.width = (data.width || 300) + 'px';
                randomVideo.style.height = (data.height || 200) + 'px';
                randomVideo.style.left = (data.left || 50) + 'px';
                randomVideo.style.top = (data.top || 400) + 'px';

                // 設定顯示狀態
                randomVideoVisible = data.visible !== false;
                if (!randomVideoVisible) {
                    randomVideo.classList.add('hidden');
                } else {
                    randomVideo.classList.remove('hidden');
                }

                // 更新調試面板的開關狀態
                document.getElementById('toggleRandomVideo')?.classList.toggle('active', randomVideoVisible);

                console.log('[隨機影片] 已套用位置:', data);
            } else {
                console.log('[隨機影片] 使用預設位置');
                randomVideo.style.width = '300px';
                randomVideo.style.height = '200px';
                randomVideo.style.left = '50px';
                randomVideo.style.top = '400px';
            }
        }

        // 套用縮放內容的比例（等比例縮放，置中顯示）
        function applyScalableBoxScale(elem, width, height) {
            if (!elem || !elem.classList.contains('scalable-box')) return;
            const content = elem.querySelector('.scalable-content');
            if (!content) return;

            // 取得基礎尺寸（用於計算縮放比例）
            const baseWidth = parseInt(elem.dataset.baseWidth) || 200;
            const baseHeight = parseInt(elem.dataset.baseHeight) || 100;

            // 先重置 transform 以取得真實內容尺寸
            content.style.transform = 'translate(-50%, -50%)';

            // 取得實際內容尺寸（會根據文字自動拉長）
            let contentWidth = content.offsetWidth;
            let contentHeight = content.offsetHeight;

            // 如果元素隱藏時 offset 為 0，使用基礎尺寸作為參考
            if (contentWidth <= 0) contentWidth = baseWidth;
            if (contentHeight <= 0) contentHeight = baseHeight;

            // 計算縮放比例（取較小值以確保完整顯示）
            const scaleX = width / contentWidth;
            const scaleY = height / contentHeight;
            const scale = Math.min(scaleX, scaleY);

            // 確保 scale 是有效值
            if (!isFinite(scale) || scale <= 0) {
                content.style.transform = 'translate(-50%, -50%) scale(1)';
                return;
            }

            // 置中 + 縮放
            content.style.transform = `translate(-50%, -50%) scale(${scale})`;
        }

        // 套用抓鴨子位置
        function applyDuckPositions() {
            const duckVideo = document.getElementById('duckVideoContainer');
            const duckCounter = document.getElementById('duckCounterBox');

            // 抓鴨子影片容器
            if (duckVideo) {
                if (savedPositions && savedPositions.duckVideo) {
                    const data = savedPositions.duckVideo;
                    duckVideo.style.width = (data.width || 300) + 'px';
                    duckVideo.style.height = (data.height || 200) + 'px';
                    duckVideo.style.left = (data.left || 400) + 'px';
                    duckVideo.style.top = (data.top || 400) + 'px';

                    duckVideoVisible = data.visible !== false;
                    if (!duckVideoVisible) {
                        duckVideo.classList.add('hidden');
                    } else {
                        duckVideo.classList.remove('hidden');
                    }
                    document.getElementById('toggleDuckVideo')?.classList.toggle('active', duckVideoVisible);
                    console.log('[抓鴨子影片] 已套用位置:', data);
                } else {
                    console.log('[抓鴨子影片] 使用預設位置');
                }
            }

            // 鴨子計數顯示
            if (duckCounter) {
                if (savedPositions && savedPositions.duckCounter) {
                    const data = savedPositions.duckCounter;
                    const w = data.width || 200;
                    const h = data.height || 100;
                    const l = data.left || 50;
                    const t = data.top || 50;

                    duckCounter.style.width = w + 'px';
                    duckCounter.style.height = h + 'px';
                    duckCounter.style.left = l + 'px';
                    duckCounter.style.top = t + 'px';

                    // 更新緩存
                    scalableBoxCache.duckCounterBox = { width: w, height: h, left: l, top: t };

                    // 套用縮放
                    applyScalableBoxScale(duckCounter, w, h);

                    duckCounterVisible = data.visible !== false;
                    if (!duckCounterVisible) {
                        duckCounter.classList.add('hidden');
                    } else {
                        duckCounter.classList.remove('hidden');
                    }
                    document.getElementById('toggleDuckCounter')?.classList.toggle('active', duckCounterVisible);
                    console.log('[鴨子計數] 已套用位置:', data);
                } else {
                    // 設置預設值到 style（確保保存時能讀取）
                    duckCounter.style.width = '200px';
                    duckCounter.style.height = '100px';
                    duckCounter.style.left = '50px';
                    duckCounter.style.top = '50px';
                    // 緩存使用預設值（已在聲明時設定）
                    // 預設縮放（scale = 1）
                    applyScalableBoxScale(duckCounter, 200, 100);
                    console.log('[鴨子計數] 使用預設位置');
                }
            }

            // 保底計數顯示
            const pityCounter = document.getElementById('pityCounterBox');
            if (pityCounter) {
                if (savedPositions && savedPositions.pityCounter) {
                    const data = savedPositions.pityCounter;
                    const w = data.width || 180;
                    const h = data.height || 80;
                    const l = data.left || 50;
                    const t = data.top || 170;

                    pityCounter.style.width = w + 'px';
                    pityCounter.style.height = h + 'px';
                    pityCounter.style.left = l + 'px';
                    pityCounter.style.top = t + 'px';

                    // 更新緩存
                    scalableBoxCache.pityCounterBox = { width: w, height: h, left: l, top: t };

                    // 套用縮放
                    applyScalableBoxScale(pityCounter, w, h);

                    pityCounterVisible = data.visible !== false;
                    if (!pityCounterVisible) {
                        pityCounter.classList.add('hidden');
                    } else {
                        pityCounter.classList.remove('hidden');
                    }
                    document.getElementById('togglePityCounter')?.classList.toggle('active', pityCounterVisible);
                    console.log('[保底計數] 已套用位置:', data);
                } else {
                    // 設置預設值到 style（確保保存時能讀取）
                    pityCounter.style.width = '180px';
                    pityCounter.style.height = '80px';
                    pityCounter.style.left = '50px';
                    pityCounter.style.top = '170px';
                    // 緩存使用預設值（已在聲明時設定）
                    // 預設縮放（scale = 1）
                    applyScalableBoxScale(pityCounter, 180, 80);
                    console.log('[保底計數] 使用預設位置');
                }
            }

            // 排行榜顯示
            const leaderboard = document.getElementById('leaderboardBox');
            if (leaderboard) {
                if (savedPositions && savedPositions.leaderboard) {
                    const data = savedPositions.leaderboard;
                    const w = data.width || 320;
                    const h = data.height || 100;
                    const l = data.left || 50;
                    const t = data.top || 300;

                    leaderboard.style.width = w + 'px';
                    leaderboard.style.height = h + 'px';
                    leaderboard.style.left = l + 'px';
                    leaderboard.style.top = t + 'px';

                    // 更新緩存
                    scalableBoxCache.leaderboardBox = { width: w, height: h, left: l, top: t };

                    // 套用縮放
                    applyScalableBoxScale(leaderboard, w, h);

                    leaderboardVisible = data.visible !== false;
                    if (!leaderboardVisible) {
                        leaderboard.classList.add('hidden');
                    } else {
                        leaderboard.classList.remove('hidden');
                    }
                    document.getElementById('toggleLeaderboard')?.classList.toggle('active', leaderboardVisible);
                    console.log('[排行榜] 已套用位置:', data);
                } else {
                    // 設置預設值到 style（確保保存時能讀取）
                    leaderboard.style.width = '320px';
                    leaderboard.style.height = '100px';
                    leaderboard.style.left = '50px';
                    leaderboard.style.top = '300px';
                    // 緩存使用預設值（已在聲明時設定）
                    // 預設縮放
                    applyScalableBoxScale(leaderboard, 320, 100);
                    console.log('[排行榜] 使用預設位置');
                }
            }

            // 禮物圖顯示
            const giftImageDisplay = document.getElementById('giftImageDisplay');
            if (giftImageDisplay) {
                if (savedPositions && savedPositions.giftImage) {
                    const data = savedPositions.giftImage;
                    // 套用尺寸
                    if (data.width !== undefined && data.width > 0) {
                        giftImageDisplay.style.width = data.width + 'px';
                    }
                    if (data.height !== undefined && data.height > 0) {
                        giftImageDisplay.style.height = data.height + 'px';
                    }
                    // 套用位置
                    if (data.left !== undefined) giftImageDisplay.style.left = data.left + 'px';
                    if (data.top !== undefined) giftImageDisplay.style.top = data.top + 'px';
                    // 禮物圖使用 transform 置中，需要移除置中效果才能使用自定義位置
                    if (data.left !== undefined || data.top !== undefined) {
                        giftImageDisplay.style.transform = 'none';
                    }
                    // 保存原始尺寸到 dataset（用於後續縮放計算）
                    if (data.originalWidth > 0) {
                        giftImageDisplay.dataset.originalWidth = data.originalWidth;
                    }
                    if (data.originalHeight > 0) {
                        giftImageDisplay.dataset.originalHeight = data.originalHeight;
                    }
                    // 如果有保存的禮物圖資料，恢復內容
                    if (data.data && data.visible) {
                        // 延遲執行以確保函數已定義
                        setTimeout(() => {
                            showGiftImageOnGreenScreen(data.data);
                            // 恢復縮放
                            const wrapper = giftImageDisplay.querySelector('.gift-image-wrapper');
                            if (wrapper && data.originalWidth > 0 && data.originalHeight > 0 && data.width > 0 && data.height > 0) {
                                const scaleX = data.width / data.originalWidth;
                                const scaleY = data.height / data.originalHeight;
                                const scale = Math.min(scaleX, scaleY);
                                wrapper.style.transform = `scale(${scale})`;
                            }
                        }, 100);
                    }
                    console.log('[禮物圖] 已套用位置:', data);
                }
            }
        }

        // 載入盲盒選項
        async function loadGiftboxOptions() {
            try {
                if (window.pywebview && window.pywebview.api) {
                    giftboxOptions = await pywebview.api.get_giftbox_options();
                } else {
                    giftboxOptions = [
                        { name: '大獎', color: '#ffd93d', weight: 1 },
                        { name: '中獎', color: '#4ecca3', weight: 2 },
                        { name: '小獎', color: '#00d9ff', weight: 3 },
                        { name: '謝謝參與', color: '#e94560', weight: 4 }
                    ];
                }
            } catch (e) {
                giftboxOptions = [
                    { name: '大獎', color: '#ffd93d', weight: 1 },
                    { name: '中獎', color: '#4ecca3', weight: 2 },
                    { name: '小獎', color: '#00d9ff', weight: 3 },
                    { name: '謝謝參與', color: '#e94560', weight: 4 }
                ];
            }
        }

        // 載入模組狀態（主控台的模組開關）
        async function loadModuleStatus() {
            try {
                if (window.pywebview && window.pywebview.api) {
                    const status = await pywebview.api.get_module_status();

                    wheelModuleEnabled = status.wheel_enabled;
                    giftboxModuleEnabled = status.giftbox_enabled;
                    updateWheelTestButton();
                    updateGiftboxTestButton();

                    // 如果主控台關閉了轉盤模組，強制隱藏
                    if (!status.wheel_enabled) {
                        wheelVisible = false;
                        setElementVisible(document.getElementById('wheelContainer'), false);
                        document.getElementById('wheelCheck').textContent = '';
                        document.getElementById('toggleWheel').classList.remove('active');
                    }

                    // 根據盲盒模組狀態設定可見性
                    if (status.giftbox_enabled) {
                        giftboxVisible = true;
                        setElementVisible(document.getElementById('giftboxContainer'), true);
                        document.getElementById('giftboxCheck').textContent = '✓';
                        document.getElementById('toggleGiftbox').classList.add('active');
                    } else {
                        giftboxVisible = false;
                        setElementVisible(document.getElementById('giftboxContainer'), false);
                        document.getElementById('giftboxCheck').textContent = '';
                        document.getElementById('toggleGiftbox').classList.remove('active');
                    }

                    // 如果主控台關閉了影片模組，強制隱藏所有影片容器
                    if (!status.video_enabled) {
                        videoVisible = false;
                        document.querySelectorAll('.video-container').forEach(vc => {
                            setElementVisible(vc, false);
                        });
                        document.getElementById('videoCheck').textContent = '';
                        document.getElementById('toggleVideo').classList.remove('active');
                    }
                }
            } catch (e) {
                console.error('[模組狀態] 載入失敗:', e);
            }
        }

        // 載入影片列表並生成容器
        async function loadVideoGifts() {
            try {
                if (window.pywebview && window.pywebview.api) {
                    // 使用當前場景的影片設定
                    const activeScene = await pywebview.api.get_active_scene();
                    videoGifts = (activeScene && activeScene.video_gifts) || [];
                    renderVideoList();
                    generateVideoContainers();
                }
            } catch (e) {
                console.error('載入影片列表失敗:', e);
                document.getElementById('videoList').innerHTML = '<div class="empty-list">載入失敗</div>';
            }
        }

        // 生成影片容器
        function generateVideoContainers() {
            const area = document.getElementById('videoContainersArea');
            area.innerHTML = '';

            // 從 savedPositions 取得影片容器資料
            const savedVideoData = (savedPositions && savedPositions.videoContainers) || {};

            videoGifts.forEach((gift, index) => {
                if (!gift.video_path) return;

                // 取得儲存的資料
                const saved = savedVideoData[index] || {};

                // 計算容器屬性（優先使用儲存的值）
                const width = Math.max(50, saved.width || 300);
                const height = Math.max(50, saved.height || 200);
                const left = saved.left ?? (50 + (index % 3) * 320);
                const top = saved.top ?? (100 + Math.floor(index / 3) * 220);
                const visible = (saved.visible !== false) && (gift.visible !== false);

                // 裁切狀態
                const cropLeft = saved.cropLeft || 0;
                const cropTop = saved.cropTop || 0;
                const originalWidth = saved.originalWidth || width;
                const originalHeight = saved.originalHeight || height;

                // 儲存到 videoContainers 供後續使用
                videoContainers[index] = {
                    visible, width, height, left, top,
                    cropLeft, cropTop, originalWidth, originalHeight
                };

                // 儲存裁切狀態
                videoCropState[index] = { cropLeft, cropTop, originalWidth, originalHeight };

                console.log(`[容器 ${index}] 尺寸:${width}x${height} 位置:(${left},${top}) 顯示:${visible} 裁切:(${cropLeft},${cropTop}) 原始:${originalWidth}x${originalHeight}`);

                // 建立容器元素
                const container = document.createElement('div');
                container.className = 'draggable video-container';
                container.id = `videoContainer_${index}`;
                container.dataset.index = index;
                container.style.width = width + 'px';
                container.style.height = height + 'px';
                container.style.left = left + 'px';
                container.style.top = top + 'px';

                // 明確設定顯示狀態
                setElementVisible(container, visible);

                container.innerHTML = `
                    <video class="thumbnail-video" muted preload="metadata" src="${formatVideoPath(gift.video_path)}"></video>
                    <video class="video-player"></video>
                    <div class="resize-handle nw"></div>
                    <div class="resize-handle n"></div>
                    <div class="resize-handle ne"></div>
                    <div class="resize-handle w"></div>
                    <div class="resize-handle e"></div>
                    <div class="resize-handle sw"></div>
                    <div class="resize-handle s"></div>
                    <div class="resize-handle se"></div>
                `;

                area.appendChild(container);

                // 設定縮圖和影片的裁切樣式
                const thumbnail = container.querySelector('.thumbnail-video');
                const player = container.querySelector('.video-player');

                thumbnail.style.width = originalWidth + 'px';
                thumbnail.style.height = originalHeight + 'px';
                thumbnail.style.left = -cropLeft + 'px';
                thumbnail.style.top = -cropTop + 'px';
                thumbnail.style.position = 'absolute';

                player.style.width = originalWidth + 'px';
                player.style.height = originalHeight + 'px';
                player.style.left = -cropLeft + 'px';
                player.style.top = -cropTop + 'px';
                player.style.position = 'absolute';

                // 設定縮圖載入事件
                thumbnail.onloadedmetadata = () => {
                    console.log(`[縮圖] 容器 ${index} 載入成功`);
                    try { thumbnail.currentTime = 1; } catch (e) {}
                };
                thumbnail.onerror = (e) => {
                    console.error(`[縮圖] 容器 ${index} 載入失敗:`, thumbnail.src, e);
                    thumbnail.style.display = 'none';
                    container.style.background = 'rgba(255, 0, 0, 0.3)';
                };
            });

            // 重新初始化拖曳和縮放
            initDraggable();
            initResizable();

            // 套用儲存的圖層順序到影片容器
            if (savedPositions && savedPositions.elementZIndexes) {
                document.querySelectorAll('.video-container').forEach(vc => {
                    const key = vc.dataset.index;
                    if (savedPositions.elementZIndexes[key]) {
                        vc.style.zIndex = savedPositions.elementZIndexes[key];
                        elementZIndexes[key] = savedPositions.elementZIndexes[key];
                    }
                });
            }
        }

        // 渲染影片列表
        function renderVideoList() {
            const container = document.getElementById('videoList');

            if (videoGifts.length === 0) {
                container.innerHTML = '<div class="empty-list">尚無影片設定<br><small>請在主控台新增影片觸發</small></div>';
                return;
            }

            const typeLabels = { gift: '禮物', chat: '彈幕', like: '點讚' };

            container.innerHTML = videoGifts.map((gift, index) => {
                const isVisible = gift.visible !== false;
                const videoPath = gift.video_path || '';

                return `
                    <div class="video-item ${!isVisible ? 'hidden-item' : ''}" data-index="${index}">
                        <div class="video-thumbnail">
                            ${videoPath ? `<video src="${formatVideoPath(videoPath)}" muted preload="metadata" onloadedmetadata="this.currentTime=1" onerror="console.error('[列表縮圖] 載入失敗:', this.src); this.parentElement.innerHTML='<div class=\\'no-video\\'>❌</div>'"></video>` : '<div class="no-video">🎬</div>'}
                        </div>
                        <div class="video-info">
                            <div class="video-name">${gift.name || '未命名'}</div>
                            <div class="video-type">${typeLabels[gift.trigger_type] || '禮物'}</div>
                        </div>
                        <div class="video-actions">
                            <button class="debug-btn small" onclick="testVideoByIndex(${index})">▶️ 測試</button>
                            <button class="debug-btn small ${isVisible ? 'secondary' : 'danger'}" onclick="toggleVideoGiftVisible(${index})">
                                ${isVisible ? '👁️ 顯示' : '🚫 隱藏'}
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // 格式化影片路徑 - 使用本地檔案伺服器
        const FILE_SERVER_PORT = 18888;

        function formatVideoPath(path) {
            if (!path) return '';
            // 使用本地伺服器提供影片 (注意: /media 路徑)
            return `http://127.0.0.1:${FILE_SERVER_PORT}/media?path=${encodeURIComponent(path)}`;
        }

        // 測試單個影片
        async function testVideoByIndex(index) {
            const gift = videoGifts[index];
            if (!gift || !gift.video_path) return;

            triggerVideoInContainer(index, {
                path: gift.video_path,
                speed: gift.video_speed || 1.0,
                volume: gift.video_volume || 100,
                seconds: gift.video_seconds || 0,
                repeat: 1
            });
        }

        // 在指定容器播放影片
        function triggerVideoInContainer(index, videoData) {
            console.log(`[DEBUG] triggerVideoInContainer 被呼叫: index=${index}, path=${videoData.path}, count=${videoData.count || 1}`);

            const container = document.getElementById(`videoContainer_${index}`);
            if (!container) {
                console.error(`[ERROR] 找不到影片容器: videoContainer_${index}`);
                // 列出所有現有容器
                const allContainers = document.querySelectorAll('.video-container');
                console.log(`[DEBUG] 現有容器數量: ${allContainers.length}`);
                allContainers.forEach(c => console.log(`  - ${c.id}`));
                return;
            }

            console.log(`[DEBUG] 找到容器: ${container.id}, 尺寸: ${container.offsetWidth}x${container.offsetHeight}`);

            // 初始化容器狀態
            if (!containerPlayingState[index]) {
                containerPlayingState[index] = { isPlaying: false, queue: [], wasHidden: false };
            }

            const state = containerPlayingState[index];

            // 檢查容器是否被隱藏，如果是的話記錄並暫時顯示
            if (container.classList.contains('hidden') && !state.isPlaying) {
                state.wasHidden = true;
                // 暫時顯示容器
                container.classList.remove('hidden');
                container.style.display = 'block';
                container.style.visibility = 'visible';
                container.style.opacity = '1';
                console.log(`容器 [${index}] 原本隱藏，暫時顯示以播放影片`);
            }

            // 根據 count 加入佇列（送幾個禮物就播放幾次）
            const playCount = Math.min(videoData.count || 1, 100);  // 最多 100 次，避免過多
            const priority = videoData.priority || 1;  // 預設優先級 1

            for (let i = 0; i < playCount; i++) {
                const newItem = {...videoData, count: 1, priority: priority};

                // 根據優先級插入佇列（數字越大優先級越高，排越前面）
                let inserted = false;
                for (let j = 0; j < state.queue.length; j++) {
                    if (priority > (state.queue[j].priority || 1)) {
                        state.queue.splice(j, 0, newItem);
                        inserted = true;
                        break;
                    }
                }
                if (!inserted) {
                    state.queue.push(newItem);
                }
            }
            console.log(`[DEBUG] 加入佇列 ${playCount} 次 (優先級: ${priority})，目前佇列長度: ${state.queue.length}`);

            // 如果有強制插隊且正在播放，停止當前播放
            if (videoData.force_interrupt && state.isPlaying) {
                stopVideoInContainer(index);
            }

            playNextVideoInContainer(index);
        }

        // 播放容器中的下一個影片
        function playNextVideoInContainer(index) {
            const state = containerPlayingState[index];
            if (!state || state.isPlaying || state.queue.length === 0) return;

            const container = document.getElementById(`videoContainer_${index}`);
            if (!container) {
                console.error(`找不到容器: videoContainer_${index}`);
                return;
            }

            const data = state.queue.shift();
            if (!data.path) {
                playNextVideoInContainer(index);
                return;
            }

            state.isPlaying = true;

            const videoPlayer = container.querySelector('.video-player');
            const thumbnail = container.querySelector('.thumbnail-video');
            const videoSrc = formatVideoPath(data.path);

            console.log(`準備播放影片 [${index}]:`, videoSrc);

            // 清除舊的事件
            videoPlayer.onloadedmetadata = null;
            videoPlayer.oncanplay = null;
            videoPlayer.onended = null;
            videoPlayer.onerror = null;
            videoPlayer.onloadeddata = null;

            let currentRepeat = 0;
            const maxRepeat = data.repeat || 1;
            let hasStarted = false;

            const startPlayback = () => {
                if (hasStarted) return;
                hasStarted = true;

                console.log(`[DEBUG] 開始播放影片 [${index}]`);
                console.log(`[DEBUG] 容器狀態: display=${container.style.display}, visibility=${container.style.visibility}, hidden=${container.classList.contains('hidden')}`);

                // 確保容器可見
                if (container.classList.contains('hidden')) {
                    container.classList.remove('hidden');
                    container.style.display = 'block';
                    container.style.visibility = 'visible';
                    container.style.opacity = '1';
                }

                // 確保容器有 playing class
                container.classList.add('playing');
                console.log(`[DEBUG] 容器 playing class 已添加: ${container.classList.contains('playing')}`);

                // 隱藏縮圖
                if (thumbnail) {
                    thumbnail.style.display = 'none';
                    thumbnail.style.visibility = 'hidden';
                }

                // 確保影片播放器顯示
                videoPlayer.style.display = 'block';
                videoPlayer.style.visibility = 'visible';
                videoPlayer.style.opacity = '1';
                videoPlayer.style.zIndex = '999';
                console.log(`[DEBUG] 播放器樣式已設置: display=${videoPlayer.style.display}, visibility=${videoPlayer.style.visibility}`);

                // 確保播放器有正確的尺寸和位置（繼承裁切狀態）
                const cropState = videoCropState[index];
                let playerWidth = container.offsetWidth || 300;
                let playerHeight = container.offsetHeight || 200;
                let playerLeft = 0;
                let playerTop = 0;

                if (cropState && cropState.originalWidth > 50 && cropState.originalHeight > 50) {
                    playerWidth = cropState.originalWidth;
                    playerHeight = cropState.originalHeight;
                    playerLeft = -(cropState.cropLeft || 0);
                    playerTop = -(cropState.cropTop || 0);
                }

                console.log(`[DEBUG] 播放影片 [${index}] 尺寸: ${playerWidth}x${playerHeight}, 偏移: ${playerLeft},${playerTop}`);

                videoPlayer.style.position = 'absolute';
                videoPlayer.style.width = playerWidth + 'px';
                videoPlayer.style.height = playerHeight + 'px';
                videoPlayer.style.left = playerLeft + 'px';
                videoPlayer.style.top = playerTop + 'px';

                if (data.seconds > 0) {
                    setTimeout(() => {
                        if (state.isPlaying) {
                            videoPlayer.pause();
                            handleVideoEndInContainer(index);
                        }
                    }, data.seconds * 1000);
                }

                videoPlayer.play().then(() => {
                    console.log(`影片播放中 [${index}]`);
                }).catch((err) => {
                    console.error(`影片播放失敗 [${index}]:`, err);
                    handleVideoEndInContainer(index);
                });
            };

            videoPlayer.onloadedmetadata = () => {
                console.log(`影片 metadata 已載入 [${index}]`);
                startPlayback();
            };

            videoPlayer.onloadeddata = () => {
                console.log(`影片資料已載入 [${index}]`);
                startPlayback();
            };

            videoPlayer.oncanplay = () => {
                console.log(`影片可播放 [${index}]`);
                startPlayback();
            };

            videoPlayer.onended = () => {
                console.log(`影片播放結束 [${index}]`);
                currentRepeat++;
                if (currentRepeat < maxRepeat) {
                    videoPlayer.currentTime = 0;
                    videoPlayer.play();
                } else {
                    handleVideoEndInContainer(index);
                }
            };

            videoPlayer.onerror = (e) => {
                console.error(`影片載入錯誤 [${index}]:`, e);
                handleVideoEndInContainer(index, true);  // 傳遞 isError = true
            };

            // 設定影片源
            videoPlayer.src = videoSrc;
            videoPlayer.playbackRate = data.speed || 1.0;
            videoPlayer.volume = (data.volume || 100) / 100;
            videoPlayer.muted = false;
            videoPlayer.load();

            // 備用：如果 1 秒後還沒開始播放，強制嘗試
            setTimeout(() => {
                if (!hasStarted && state.isPlaying) {
                    console.log(`強制嘗試播放 [${index}]`);
                    startPlayback();
                }
            }, 1000);
        }

        // 處理容器影片結束
        function handleVideoEndInContainer(index, isError = false) {
            const state = containerPlayingState[index];
            if (!state) return;

            // 防止重複觸發
            if (!state.isPlaying) return;
            state.isPlaying = false;

            const container = document.getElementById(`videoContainer_${index}`);
            if (container) {
                container.classList.remove('playing');

                // 隱藏播放器，顯示縮圖
                const videoPlayer = container.querySelector('.video-player');
                const thumbnail = container.querySelector('.thumbnail-video');

                if (videoPlayer) {
                    // 先清除所有事件，防止 src='' 觸發 onerror
                    videoPlayer.onloadedmetadata = null;
                    videoPlayer.onloadeddata = null;
                    videoPlayer.oncanplay = null;
                    videoPlayer.onended = null;
                    videoPlayer.onerror = null;

                    videoPlayer.pause();
                    videoPlayer.removeAttribute('src');
                    videoPlayer.load();  // 重置影片元素
                    videoPlayer.style.display = 'none';
                }

                if (thumbnail) {
                    // 完整重置縮圖顯示狀態
                    thumbnail.style.display = 'block';
                    thumbnail.style.visibility = 'visible';
                    thumbnail.style.opacity = '1';

                    // 重新設定 currentTime 以顯示縮圖畫面
                    // （播放器可能影響了縮圖的時間位置）
                    try {
                        if (thumbnail.readyState >= 1) {
                            thumbnail.currentTime = 1;
                        } else {
                            // 如果縮圖尚未載入，重新載入
                            const src = thumbnail.src;
                            if (src) {
                                thumbnail.onloadedmetadata = () => {
                                    thumbnail.currentTime = 1;
                                };
                                thumbnail.load();
                            }
                        }
                    } catch (e) {
                        console.warn(`[WARN] 重置縮圖時間失敗 [${index}]:`, e);
                    }
                }
            }

            console.log(`影片容器 [${index}] 播放完成${isError ? ' (發生錯誤)' : ''}`);

            // 如果是錯誤，清空佇列避免無限重試
            if (isError) {
                state.queue = [];
            }

            // 檢查佇列是否還有影片
            if (state.queue.length > 0) {
                // 還有影片要播放，延遲一下再播放
                setTimeout(() => playNextVideoInContainer(index), 100);
            } else {
                // 佇列已空，如果原本是隱藏的，恢復隱藏狀態
                if (state.wasHidden && container) {
                    container.classList.add('hidden');
                    container.style.display = 'none';
                    container.style.visibility = 'hidden';
                    container.style.opacity = '0';
                    console.log(`容器 [${index}] 播放完成，恢復隱藏狀態`);
                }
                // 重置 wasHidden 狀態
                state.wasHidden = false;
            }
        }

        // 停止容器中的影片
        function stopVideoInContainer(index) {
            const container = document.getElementById(`videoContainer_${index}`);
            if (!container) return;

            const videoPlayer = container.querySelector('.video-player');
            const thumbnail = container.querySelector('.thumbnail-video');

            if (videoPlayer) {
                // 先清除所有事件
                videoPlayer.onloadedmetadata = null;
                videoPlayer.onloadeddata = null;
                videoPlayer.oncanplay = null;
                videoPlayer.onended = null;
                videoPlayer.onerror = null;

                videoPlayer.pause();
                videoPlayer.removeAttribute('src');
                videoPlayer.load();
                videoPlayer.style.display = 'none';
            }

            if (thumbnail) {
                // 完整重置縮圖顯示狀態
                thumbnail.style.display = 'block';
                thumbnail.style.visibility = 'visible';
                thumbnail.style.opacity = '1';

                // 重新設定 currentTime 以顯示縮圖畫面
                try {
                    if (thumbnail.readyState >= 1) {
                        thumbnail.currentTime = 1;
                    }
                } catch (e) {
                    console.warn(`[WARN] 停止時重置縮圖時間失敗 [${index}]:`, e);
                }
            }

            container.classList.remove('playing');

            const state = containerPlayingState[index];
            if (state) {
                state.isPlaying = false;
                // 停止時不恢復隱藏狀態（因為是強制中斷，會立即播放下一個）
            }
        }

        // 切換影片顯示/隱藏
        async function toggleVideoGiftVisible(index) {
            if (!videoGifts[index]) return;

            const gift = videoGifts[index];
            gift.visible = gift.visible === false ? true : false;

            // 更新容器狀態
            if (videoContainers[index]) {
                videoContainers[index].visible = gift.visible;
            }

            // 更新綠幕上的容器
            const container = document.getElementById(`videoContainer_${index}`);
            if (container) {
                setElementVisible(container, gift.visible);
            }

            // 重要：先保存當前所有容器的位置和裁切狀態
            await savePositions();

            try {
                if (window.pywebview && window.pywebview.api) {
                    // 標記這是僅可見性更新，不需要重新生成容器
                    window._skipContainerRegeneration = true;
                    // 使用場景 API 更新影片設定
                    const scenes = await pywebview.api.get_scenes();
                    const activeSceneId = scenes.activeSceneId || 'default';
                    await pywebview.api.update_scene_video_gifts(activeSceneId, videoGifts);
                    // 延遲重置標記，確保 configUpdated 事件已處理
                    setTimeout(() => { window._skipContainerRegeneration = false; }, 100);
                }
            } catch (e) {
                console.error('更新失敗:', e);
                window._skipContainerRegeneration = false;
            }

            renderVideoList();
        }

        function waitForPywebview() {
            return new Promise((resolve) => {
                // 檢查 API 是否完全可用（包括具體方法）
                const checkApi = () => {
                    if (window.pywebview && window.pywebview.api &&
                        typeof window.pywebview.api.get_greenscreen_positions === 'function') {
                        console.log('[DEBUG] pywebview API 已就緒');
                        resolve();
                        return true;
                    }
                    return false;
                };

                if (checkApi()) return;

                // 監聽 pywebviewready 事件
                window.addEventListener('pywebviewready', () => {
                    // 事件觸發後仍需等待 API 方法綁定
                    let attempts = 0;
                    const waitInterval = setInterval(() => {
                        attempts++;
                        if (checkApi() || attempts > 50) {
                            clearInterval(waitInterval);
                            if (attempts > 50) {
                                console.warn('[WARN] 等待 pywebview API 超時');
                                resolve();
                            }
                        }
                    }, 100);
                });

                // 備用：輪詢檢查
                let pollAttempts = 0;
                const pollInterval = setInterval(() => {
                    pollAttempts++;
                    if (checkApi() || pollAttempts > 50) {
                        clearInterval(pollInterval);
                        if (pollAttempts > 50) {
                            console.warn('[WARN] 輪詢等待 pywebview API 超時');
                            resolve();
                        }
                    }
                }, 100);
            });
        }

        // === 視窗控制 ===
        function closeWindow() {
            if (window.electronAPI && window.electronAPI.closeGreenScreen) {
                window.electronAPI.closeGreenScreen();
            } else {
                window.close();
            }
        }

        function minimizeWindow() {
            if (window.electronAPI && window.electronAPI.minimizeGreenScreen) {
                window.electronAPI.minimizeGreenScreen();
            }
        }

        function toggleMaximize() {
            if (window.electronAPI && window.electronAPI.toggleMaximizeGreenScreen) {
                window.electronAPI.toggleMaximizeGreenScreen();
            }
        }

        // 顯示提示
        function showHint() {
            const hint = document.getElementById('debugHint');
            hint.classList.add('visible');
            setTimeout(() => hint.classList.remove('visible'), 3000);
        }

        // 鍵盤快捷鍵
        function initKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Tab') {
                    e.preventDefault();
                    toggleDebugPanel();
                }
            });
        }

        // 切換調試面板
        function toggleDebugPanel() {
            debugPanelVisible = !debugPanelVisible;
            const panel = document.getElementById('debugPanel');
            const check = document.getElementById('debugCheck');
            panel.classList.toggle('visible', debugPanelVisible);
            check.textContent = debugPanelVisible ? '✓' : '';

            if (debugPanelVisible) {
                document.body.classList.add('debug-mode');
                // 只更新列表，不重新生成容器
                refreshVideoListOnly();
            } else {
                document.body.classList.remove('debug-mode');
            }
        }

        // 切換可折疊區塊
        function toggleSection(header) {
            const section = header.parentElement;
            section.classList.toggle('collapsed');
        }

        // 只更新影片列表 UI，不重新生成容器
        async function refreshVideoListOnly() {
            try {
                if (window.pywebview && window.pywebview.api) {
                    // 使用當前場景的影片設定
                    const activeScene = await pywebview.api.get_active_scene();
                    videoGifts = (activeScene && activeScene.video_gifts) || [];
                    renderVideoList();
                }
            } catch (e) {
                console.error('更新影片列表失敗:', e);
            }
        }

        // 監聽訊息
        function initMessageListener() {
            console.log('=== 初始化事件監聽器 ===');

            // 監聽來自 Electron 主進程的事件
            if (window.electronAPI && window.electronAPI.onGreenScreenEvent) {
                console.log('設定 electronAPI 事件監聽');
                window.electronAPI.onGreenScreenEvent((event, data) => {
                    console.log('收到主進程事件:', event, data);
                    // 派發對應的自定義事件
                    window.dispatchEvent(new CustomEvent(event, { detail: data }));
                });
            } else {
                console.warn('electronAPI.onGreenScreenEvent 不可用');
            }

            // 監聽配置更新 - 即時同步不需重開
            // 配置更新節流（避免頻繁更新造成卡頓）
            let configUpdateTimer = null;
            if (window.electronAPI && window.electronAPI.onConfigUpdate) {
                console.log('設定配置更新監聽');
                window.electronAPI.onConfigUpdate(async (config) => {
                    // 使用節流，300ms 內只處理最後一次
                    if (configUpdateTimer) clearTimeout(configUpdateTimer);
                    configUpdateTimer = setTimeout(async () => {
                        console.log('[配置更新] 收到配置變更，即時同步...');
                        // 重新載入進場列表
                        await loadEntryList();
                        // 重新載入影片列表
                        await loadVideoGifts();
                        // 重新載入轉盤選項
                        await loadWheelOptions();
                        // 重新載入盲盒選項
                        await loadGiftboxOptions();
                        console.log('[配置更新] 同步完成');
                    }, 300);
                });
            }

            window.addEventListener('triggerWheel', (event) => {
                const data = event.detail;
                console.log('收到轉盤事件:', data);
                triggerWheel(data.spins);
            });

            window.addEventListener('triggerVideo', (event) => {
                const data = event.detail;
                console.log('收到影片事件:', data);
                triggerVideo(data);
            });

            // 進場效果事件
            window.addEventListener('triggerEntry', (event) => {
                const data = event.detail;
                console.log('收到進場事件:', data);
                triggerEntry(data);
            });

            // 盲盒事件
            window.addEventListener('triggerGiftbox', (event) => {
                const data = event.detail;
                console.log('收到盲盒事件:', data);
                triggerGiftbox(data.opens);
            });

            // 抓鴨子影片事件
            window.addEventListener('triggerDuckVideo', (event) => {
                playDuckVideo(event.detail);
            });

            // 鴨子計數更新事件
            window.addEventListener('updateDuckCount', (event) => {
                updateDuckCounter(event.detail.count);
            });

            // 保底計數更新事件
            window.addEventListener('updatePityCounter', (event) => {
                updatePityCounter(event.detail);
            });

            // 排行榜更新事件（非抓鴨子來源的更新，如手動調整）
            window.addEventListener('updateLeaderboard', (event) => {
                // 如果不是抓鴨子影片播放中，直接更新
                if (!duckVideoPlaying) {
                    updateLeaderboard(event.detail);
                }
                // 抓鴨子期間的排行榜更新由 triggerDuckVideo 事件內的 leaderboardData 處理
            });

            // 里程碑慶祝事件
            window.addEventListener('triggerMilestone', (event) => {
                triggerMilestoneCelebration(event.detail);
            });

            // 禮物圖顯示事件
            window.addEventListener('showGiftImage', (event) => {
                showGiftImageOnGreenScreen(event.detail);
            });

            // 禮物圖隱藏事件
            window.addEventListener('hideGiftImage', () => {
                hideGiftImage();
            });

            // 鎖鏈對抗事件
            window.addEventListener('startChainBattle', (event) => {
                startChainBattle(event.detail);
            });

            window.addEventListener('addChainCount', (event) => {
                addChainCount(event.detail.amount);
            });

            window.addEventListener('syncChainCount', (event) => {
                syncChainCount(event.detail);
            });

            window.addEventListener('chainVictory', () => {
                chainVictory();
            });

            window.addEventListener('stopChainBattle', () => {
                stopChainBattle();
            });

            window.addEventListener('playChainVideo', (event) => {
                playChainVideo(event.detail);
            });

            // 禮物圖匯出事件
            window.addEventListener('exportGiftImage', (event) => {
                exportGiftImageToFile(event.detail);
            });

            // 全域測試函數 - 可從控制台呼叫
            window.testTriggerVideo = function(index) {
                console.log('測試觸發影片:', index);
                if (videoGifts[index]) {
                    triggerVideoInContainer(index, {
                        path: videoGifts[index].video_path,
                        speed: 1.0,
                        volume: 100,
                        seconds: 0,
                        repeat: 1
                    });
                }
            };

            console.log('事件監聽器已註冊，videoGifts:', videoGifts);

            // 監聽模組狀態變化
            window.addEventListener('moduleStatusChanged', (event) => {
                const data = event.detail;
                console.log('模組狀態變化:', data);

                if (data.module === 'wheel') {
                    wheelModuleEnabled = data.enabled;
                    updateWheelTestButton();

                    const wc = document.getElementById('wheelContainer');
                    if (data.enabled) {
                        wheelVisible = true;
                        wc.classList.remove('hidden');
                        wc.style.display = 'block';
                        document.getElementById('wheelCheck').textContent = '✓';
                        document.getElementById('toggleWheel').classList.add('active');
                    } else {
                        wheelVisible = false;
                        wc.classList.add('hidden');
                        wc.style.display = 'none';
                        document.getElementById('wheelCheck').textContent = '';
                        document.getElementById('toggleWheel').classList.remove('active');
                    }
                }

                if (data.module === 'giftbox') {
                    giftboxModuleEnabled = data.enabled;
                    updateGiftboxTestButton();

                    const gc = document.getElementById('giftboxContainer');
                    if (data.enabled) {
                        giftboxVisible = true;
                        gc.classList.remove('hidden');
                        gc.style.display = 'block';
                        document.getElementById('giftboxCheck').textContent = '✓';
                        document.getElementById('toggleGiftbox').classList.add('active');
                    } else {
                        giftboxVisible = false;
                        gc.classList.add('hidden');
                        gc.style.display = 'none';
                        document.getElementById('giftboxCheck').textContent = '';
                        document.getElementById('toggleGiftbox').classList.remove('active');
                    }
                }

                if (data.module === 'video') {
                    if (data.enabled) {
                        videoVisible = true;
                        document.querySelectorAll('.video-container').forEach(vc => {
                            const idx = vc.dataset.index;
                            // 只顯示未被單獨隱藏的容器
                            if (videoGifts[idx]?.visible !== false) {
                                vc.classList.remove('hidden');
                                vc.style.display = 'block';
                                vc.style.visibility = 'visible';
                                vc.style.opacity = '1';
                            }
                        });
                        document.getElementById('videoCheck').textContent = '✓';
                        document.getElementById('toggleVideo').classList.add('active');
                    } else {
                        videoVisible = false;
                        document.querySelectorAll('.video-container').forEach(vc => {
                            vc.classList.add('hidden');
                            vc.style.display = 'none';
                            vc.style.visibility = 'hidden';
                            vc.style.opacity = '0';
                        });
                        document.getElementById('videoCheck').textContent = '';
                        document.getElementById('toggleVideo').classList.remove('active');
                    }
                }
            });

            // 監聯配置更新
            window.addEventListener('configUpdated', async () => {
                console.log('[DEBUG] 收到 configUpdated 事件');

                // 如果是僅可見性更新，跳過容器重新生成
                if (window._skipContainerRegeneration) {
                    console.log('[DEBUG] 跳過容器重新生成（僅可見性更新）');
                    // 只更新影片列表 UI，不重新生成容器
                    await refreshVideoListOnly();
                    return;
                }

                // 保存當前容器位置到 savedPositions，避免重新生成時位置被重置
                if (savedPositions) {
                    // 從 DOM 和 videoCropState 收集最新狀態
                    const currentVideoData = {};
                    document.querySelectorAll('.video-container').forEach(vc => {
                        const idx = parseInt(vc.dataset.index);
                        const crop = videoCropState[idx] || {};
                        const cached = videoContainers[idx] || {};

                        currentVideoData[idx] = {
                            width: vc.offsetWidth || parseInt(vc.style.width) || cached.width || 300,
                            height: vc.offsetHeight || parseInt(vc.style.height) || cached.height || 200,
                            left: vc.offsetLeft || parseInt(vc.style.left) || cached.left || 0,
                            top: vc.offsetTop || parseInt(vc.style.top) || cached.top || 0,
                            visible: !vc.classList.contains('hidden'),
                            cropLeft: crop.cropLeft || 0,
                            cropTop: crop.cropTop || 0,
                            originalWidth: crop.originalWidth || cached.originalWidth || vc.offsetWidth || 300,
                            originalHeight: crop.originalHeight || cached.originalHeight || vc.offsetHeight || 200
                        };
                        console.log(`[DEBUG] 容器 ${idx} 狀態:`, currentVideoData[idx]);
                    });

                    // 更新 videoContainers 和 savedPositions
                    Object.assign(videoContainers, currentVideoData);
                    savedPositions.videoContainers = currentVideoData;
                    console.log('[DEBUG] 已保存當前容器位置和裁切狀態到 savedPositions');
                }

                console.log('[DEBUG] 重新載入影片設定');
                await loadVideoGifts();
                // 延遲後重新載入縮圖，確保 DOM 已更新
                setTimeout(() => {
                    console.log('[DEBUG] 延遲重載縮圖');
                    reloadAllThumbnails();
                }, 300);
            });

            window.addEventListener('message', (event) => {
                const data = event.data;
                if (!data || !data.type) return;

                if (data.type === 'wheel') {
                    triggerWheel(data.spins);
                } else if (data.type === 'video') {
                    triggerVideo(data);
                }
            });
        }

        async function loadWheelOptions() {
            try {
                if (window.pywebview && window.pywebview.api) {
                    wheelOptions = await pywebview.api.get_wheel_options();
                } else {
                    wheelOptions = [
                        { name: '選項A', color: '#e94560', weight: 1 },
                        { name: '選項B', color: '#4ecca3', weight: 1 },
                        { name: '選項C', color: '#00d9ff', weight: 1 },
                        { name: '選項D', color: '#ffd93d', weight: 1 }
                    ];
                }
            } catch (e) {
                wheelOptions = [
                    { name: '選項A', color: '#e94560', weight: 1 },
                    { name: '選項B', color: '#4ecca3', weight: 1 },
                    { name: '選項C', color: '#00d9ff', weight: 1 },
                    { name: '選項D', color: '#ffd93d', weight: 1 }
                ];
            }
        }

        // === 顯示控制 ===
        function toggleWheelVisibility() {
            wheelVisible = !wheelVisible;
            setElementVisible(document.getElementById('wheelContainer'), wheelVisible);
            document.getElementById('wheelCheck').textContent = wheelVisible ? '✓' : '';
            document.getElementById('toggleWheel').classList.toggle('active', wheelVisible);
            savePositions();
        }

        function toggleGiftboxVisibility() {
            giftboxVisible = !giftboxVisible;
            setElementVisible(document.getElementById('giftboxContainer'), giftboxVisible);
            document.getElementById('giftboxCheck').textContent = giftboxVisible ? '✓' : '';
            document.getElementById('toggleGiftbox').classList.toggle('active', giftboxVisible);
            savePositions();
        }

        function toggleGiftboxAutoHide() {
            giftboxAutoHide = !giftboxAutoHide;
            const container = document.getElementById('giftboxContainer');
            container.classList.toggle('auto-hidden', giftboxAutoHide);
            document.getElementById('giftboxAutoHideCheck').textContent = giftboxAutoHide ? '✓' : '';
            document.getElementById('toggleGiftboxAutoHide').classList.toggle('active', giftboxAutoHide);
            savePositions();
        }

        function toggleVideoVisibility() {
            videoVisible = !videoVisible;
            document.querySelectorAll('.video-container').forEach(vc => {
                const idx = parseInt(vc.dataset.index);
                // 只顯示未被單獨隱藏的容器
                const shouldShow = videoVisible && (videoGifts[idx]?.visible !== false);
                setElementVisible(vc, shouldShow);
            });
            document.getElementById('videoCheck').textContent = videoVisible ? '✓' : '';
            document.getElementById('toggleVideo').classList.toggle('active', videoVisible);
            savePositions();
        }

        // 進場影片容器相關
        let entryVideoVisible = false;
        let entryList = [];

        function toggleEntryVideoVisibility() {
            entryVideoVisible = !entryVideoVisible;
            const container = document.getElementById('entryVideoContainer');
            if (container) {
                setElementVisible(container, entryVideoVisible);
            }
            document.getElementById('toggleEntryVideo').classList.toggle('active', entryVideoVisible);

            // 更新所有進場列表中的顯示/隱藏按鈕狀態
            updateEntryVisibilityButtons();

            savePositions();
        }

        // 更新所有進場效果的顯示/隱藏按鈕狀態（根據各自的 enabled 狀態）
        async function updateEntryVisibilityButtons() {
            // 更新專屬進場的按鈕
            entryList.forEach((entry, index) => {
                const enabled = entry.enabled !== false;
                const item = document.getElementById(`entryItem_${index}`);
                const btn = document.getElementById(`entryVisBtn_${index}`);
                if (item) {
                    item.classList.toggle('hidden-item', !enabled);
                }
                if (btn) {
                    btn.className = `debug-btn small ${enabled ? 'secondary' : 'danger'}`;
                    btn.innerHTML = enabled ? '👁️' : '🚫';
                }
            });

            // 更新全局進場的按鈕
            try {
                const config = await pywebview.api.get_config();
                const entryConfig = config.entry_config || {};
                const globalEnabled = entryConfig.enabled !== false;
                const item = document.getElementById('entryItem_global');
                const btn = document.getElementById('entryVisBtn_global');
                if (item) {
                    item.classList.toggle('hidden-item', !globalEnabled);
                }
                if (btn) {
                    btn.className = `debug-btn small ${globalEnabled ? 'secondary' : 'danger'}`;
                    btn.innerHTML = globalEnabled ? '👁️' : '🚫';
                }
            } catch (e) {
                // 忽略錯誤
            }
        }

        // === 快速隱藏/顯示全部 ===
        function hideAllElements() {
            // 隱藏轉盤
            wheelVisible = false;
            setElementVisible(document.getElementById('wheelContainer'), false);
            document.getElementById('wheelCheck').textContent = '';
            document.getElementById('toggleWheel').classList.remove('active');

            // 隱藏盲盒
            giftboxVisible = false;
            setElementVisible(document.getElementById('giftboxContainer'), false);
            document.getElementById('giftboxCheck').textContent = '';
            document.getElementById('toggleGiftbox').classList.remove('active');

            // 隱藏影片容器
            videoVisible = false;
            document.querySelectorAll('.video-container').forEach(vc => {
                setElementVisible(vc, false);
            });
            document.getElementById('videoCheck').textContent = '';
            document.getElementById('toggleVideo').classList.remove('active');

            // 隱藏進場影片容器
            entryVideoVisible = false;
            const entryContainer = document.getElementById('entryVideoContainer');
            if (entryContainer) {
                setElementVisible(entryContainer, false);
            }
            document.getElementById('toggleEntryVideo').classList.remove('active');
            updateEntryVisibilityButtons();

            savePositions();
            debugLog('所有元素已隱藏');
        }

        function showAllElements() {
            // 顯示轉盤
            wheelVisible = true;
            setElementVisible(document.getElementById('wheelContainer'), true);
            document.getElementById('wheelCheck').textContent = '✓';
            document.getElementById('toggleWheel').classList.add('active');

            // 顯示盲盒
            giftboxVisible = true;
            setElementVisible(document.getElementById('giftboxContainer'), true);
            document.getElementById('giftboxCheck').textContent = '✓';
            document.getElementById('toggleGiftbox').classList.add('active');

            // 顯示影片容器
            videoVisible = true;
            document.querySelectorAll('.video-container').forEach(vc => {
                const idx = parseInt(vc.dataset.index);
                const shouldShow = videoGifts[idx]?.visible !== false;
                setElementVisible(vc, shouldShow);
            });
            document.getElementById('videoCheck').textContent = '✓';
            document.getElementById('toggleVideo').classList.add('active');

            // 顯示進場影片容器
            entryVideoVisible = true;
            const entryContainer = document.getElementById('entryVideoContainer');
            if (entryContainer) {
                setElementVisible(entryContainer, true);
            }
            document.getElementById('toggleEntryVideo').classList.add('active');
            updateEntryVisibilityButtons();

            savePositions();
            debugLog('所有元素已顯示');
        }

        async function loadEntryList() {
            try {
                const config = await pywebview.api.get_config();
                entryList = config.entry_list || [];
                const entryConfig = config.entry_config || {};

                const container = document.getElementById('entryList');
                if (!container) return;

                if (entryList.length === 0 && !entryConfig.media_path) {
                    container.innerHTML = '<div class="empty-list">尚未設定進場效果</div>';
                    return;
                }

                let html = '';

                // 顯示專屬進場列表
                entryList.forEach((entry, index) => {
                    if (!entry.media_path) return;
                    const isVideo = /\.(mp4|avi|mov|mkv|webm)$/i.test(entry.media_path);
                    const enabled = entry.enabled !== false;
                    html += `
                        <div class="video-item ${enabled ? '' : 'hidden-item'}" id="entryItem_${index}">
                            <div class="video-thumbnail">
                                ${isVideo
                                    ? `<video src="${formatVideoPath(entry.media_path)}" muted preload="metadata"></video>`
                                    : `<div style="display:flex;align-items:center;justify-content:center;height:100%;background:#333;color:#fff;">🎵</div>`
                                }
                            </div>
                            <div class="video-info">
                                <div class="video-name">👤 ${entry.username || '未命名'}</div>
                                <div class="video-type">${entry.media_path.split('\\').pop()}</div>
                            </div>
                            <div class="video-actions">
                                <button class="debug-btn small" onclick="testEntryByIndex(${index})">▶️</button>
                                <button class="debug-btn small ${enabled ? 'secondary' : 'danger'}" onclick="toggleEntryEnabled(${index})" id="entryVisBtn_${index}">
                                    ${enabled ? '👁️' : '🚫'}
                                </button>
                            </div>
                        </div>
                    `;
                });

                // 顯示全局進場（如果有設定）
                if (entryConfig.media_path) {
                    const isVideo = /\.(mp4|avi|mov|mkv|webm)$/i.test(entryConfig.media_path);
                    const enabled = entryConfig.enabled !== false;
                    html += `
                        <div class="video-item ${enabled ? '' : 'hidden-item'}" id="entryItem_global">
                            <div class="video-thumbnail">
                                ${isVideo
                                    ? `<video src="${formatVideoPath(entryConfig.media_path)}" muted preload="metadata"></video>`
                                    : `<div style="display:flex;align-items:center;justify-content:center;height:100%;background:#333;color:#fff;">🎵</div>`
                                }
                            </div>
                            <div class="video-info">
                                <div class="video-name">🌐 全局進場</div>
                                <div class="video-type">${entryConfig.media_path.split('\\').pop()}</div>
                            </div>
                            <div class="video-actions">
                                <button class="debug-btn small" onclick="testGlobalEntry()">▶️</button>
                                <button class="debug-btn small ${enabled ? 'secondary' : 'danger'}" onclick="toggleGlobalEntryEnabled()" id="entryVisBtn_global">
                                    ${enabled ? '👁️' : '🚫'}
                                </button>
                            </div>
                        </div>
                    `;
                }

                container.innerHTML = html || '<div class="empty-list">尚未設定進場效果</div>';

                // 更新進場縮圖
                updateEntryThumbnail();
            } catch (e) {
                console.error('[進場列表] 載入失敗:', e);
            }
        }

        // 切換單個進場項目的啟用狀態
        async function toggleEntryEnabled(index) {
            if (!entryList[index]) return;

            const currentEnabled = entryList[index].enabled !== false;
            const newEnabled = !currentEnabled;

            // 更新本地狀態
            entryList[index].enabled = newEnabled;

            // 更新 UI
            const item = document.getElementById(`entryItem_${index}`);
            const btn = document.getElementById(`entryVisBtn_${index}`);
            if (item) {
                item.classList.toggle('hidden-item', !newEnabled);
            }
            if (btn) {
                btn.className = `debug-btn small ${newEnabled ? 'secondary' : 'danger'}`;
                btn.innerHTML = newEnabled ? '👁️' : '🚫';
            }

            // 保存到配置
            try {
                await pywebview.api.update_config({ entry_list: entryList });
                console.log(`[進場] ${entryList[index].username} ${newEnabled ? '已啟用' : '已停用'}`);
            } catch (e) {
                console.error('[進場] 更新配置失敗:', e);
            }
        }

        // 切換全局進場的啟用狀態
        async function toggleGlobalEntryEnabled() {
            try {
                const config = await pywebview.api.get_config();
                const entryConfig = config.entry_config || {};
                const currentEnabled = entryConfig.enabled !== false;
                const newEnabled = !currentEnabled;

                // 更新配置
                entryConfig.enabled = newEnabled;
                await pywebview.api.update_config({ entry_config: entryConfig });

                // 更新 UI
                const item = document.getElementById('entryItem_global');
                const btn = document.getElementById('entryVisBtn_global');
                if (item) {
                    item.classList.toggle('hidden-item', !newEnabled);
                }
                if (btn) {
                    btn.className = `debug-btn small ${newEnabled ? 'secondary' : 'danger'}`;
                    btn.innerHTML = newEnabled ? '👁️' : '🚫';
                }

                console.log(`[進場] 全局進場 ${newEnabled ? '已啟用' : '已停用'}`);
            } catch (e) {
                console.error('[進場] 更新全局配置失敗:', e);
            }
        }

        function updateEntryThumbnail() {
            const thumbnail = document.getElementById('entryThumbnail');
            if (!thumbnail) return;

            // 使用第一個專屬進場或全局進場的影片作為縮圖
            let videoPath = '';
            for (const entry of entryList) {
                if (entry.media_path && /\.(mp4|avi|mov|mkv|webm)$/i.test(entry.media_path)) {
                    videoPath = entry.media_path;
                    break;
                }
            }

            if (videoPath) {
                thumbnail.src = formatVideoPath(videoPath);
            }
        }

        async function testEntryByIndex(index) {
            if (!entryList[index]) return;
            const entry = entryList[index];
            const isAudio = /\.(mp3|wav|ogg|m4a|aac)$/i.test(entry.media_path);

            triggerEntry({
                username: entry.username || '測試用戶',
                level: 30,
                path: entry.media_path,
                volume: entry.volume || 100,
                force_interrupt: entry.force_interrupt !== false,
                is_audio: isAudio,
                show_text: entry.show_text || false,
                text: entry.text || '',
                text_size: entry.text_size || 48,
                text_color: entry.text_color || '#ffffff',
                text_duration: entry.text_duration || 5,
                is_specific: true
            });
        }

        async function testGlobalEntry() {
            const config = await pywebview.api.get_config();
            const entry = config.entry_config || {};
            if (!entry.media_path) return;

            const isAudio = /\.(mp3|wav|ogg|m4a|aac)$/i.test(entry.media_path);
            triggerEntry({
                username: '測試用戶',
                level: 0,
                path: entry.media_path,
                volume: entry.volume || 100,
                force_interrupt: entry.force_interrupt !== false,
                is_audio: isAudio,
                show_text: false,
                is_specific: false
            });
        }

        // 保存位置和狀態（使用 API 保存到配置文件，確保持久化）
        // 保存所有位置和狀態
        // 節流版本的 savePositions（避免頻繁調用造成卡頓）
        let savePositionsTimer = null;
        function savePositionsDebounced() {
            if (savePositionsTimer) clearTimeout(savePositionsTimer);
            savePositionsTimer = setTimeout(() => {
                savePositions();
            }, 300);
        }

        async function savePositions() {
            const wheel = document.getElementById('wheelContainer');
            const giftbox = document.getElementById('giftboxContainer');
            const entryText = document.getElementById('entryTextContainer');
            const entryVideo = document.getElementById('entryVideoContainer');
            const randomVideo = document.getElementById('randomVideoContainer');
            const duckVideo = document.getElementById('duckVideoContainer');
            const duckCounter = document.getElementById('duckCounterBox');
            const pityCounter = document.getElementById('pityCounterBox');
            const leaderboard = document.getElementById('leaderboardBox');
            const giftImageDisplay = document.getElementById('giftImageDisplay');

            // 收集影片容器資料
            const videoData = {};
            document.querySelectorAll('.video-container').forEach(vc => {
                const idx = parseInt(vc.dataset.index);
                const cached = videoContainers[idx] || {};
                const crop = videoCropState[idx] || {};

                // 取得尺寸（隱藏時可能是0，用 style 或快取值）
                let w = vc.offsetWidth || parseInt(vc.style.width) || cached.width || 300;
                let h = vc.offsetHeight || parseInt(vc.style.height) || cached.height || 200;

                videoData[idx] = {
                    width: Math.max(50, w),
                    height: Math.max(50, h),
                    left: vc.offsetLeft || parseInt(vc.style.left) || cached.left || 0,
                    top: vc.offsetTop || parseInt(vc.style.top) || cached.top || 0,
                    visible: !vc.classList.contains('hidden'),
                    cropLeft: crop.cropLeft || 0,
                    cropTop: crop.cropTop || 0,
                    originalWidth: crop.originalWidth || w,
                    originalHeight: crop.originalHeight || h
                };
            });

            // 輔助函數：可靠地取得元素尺寸（即使隱藏）
            function getElementDimensions(el, defaultW, defaultH) {
                if (!el) return { width: defaultW, height: defaultH, left: 0, top: 0 };

                // 對於 scalable-box 元素，優先使用緩存
                if (el.classList.contains('scalable-box') && scalableBoxCache[el.id]) {
                    const cached = scalableBoxCache[el.id];
                    console.log(`[getElementDimensions] 使用緩存: ${el.id}`, cached);
                    return {
                        width: cached.width,
                        height: cached.height,
                        left: cached.left,
                        top: cached.top
                    };
                }

                // 優先使用 style 值（隱藏時 offset 會是 0）
                // 注意：parseInt 可能返回 NaN，需要明確檢查
                const styleW = parseInt(el.style.width);
                const styleH = parseInt(el.style.height);
                const styleL = parseInt(el.style.left);
                const styleT = parseInt(el.style.top);

                // 使用 isNaN 檢查，避免 NaN || 0 的問題
                const w = !isNaN(styleW) && styleW > 0 ? styleW : (el.offsetWidth > 0 ? el.offsetWidth : defaultW);
                const h = !isNaN(styleH) && styleH > 0 ? styleH : (el.offsetHeight > 0 ? el.offsetHeight : defaultH);
                const l = !isNaN(styleL) ? styleL : (el.offsetLeft || 0);
                const t = !isNaN(styleT) ? styleT : (el.offsetTop || 0);

                return {
                    width: Math.max(50, w),
                    height: Math.max(50, h),
                    left: l,
                    top: t
                };
            }

            // 組合完整資料
            const wheelDim = getElementDimensions(wheel, 350, 350);
            const giftboxDim = getElementDimensions(giftbox, 200, 200);
            const entryVideoDim = getElementDimensions(entryVideo, 400, 300);
            const randomVideoDim = getElementDimensions(randomVideo, 300, 200);
            const duckVideoDim = getElementDimensions(duckVideo, 300, 200);
            const duckCounterDim = getElementDimensions(duckCounter, 200, 100);
            const pityCounterDim = getElementDimensions(pityCounter, 180, 80);
            const leaderboardDim = getElementDimensions(leaderboard, 320, 100);
            const giftImageDim = getElementDimensions(giftImageDisplay, 300, 200);

            const positions = {
                wheel: {
                    width: wheelDim.width,
                    height: wheelDim.height,
                    left: wheelDim.left,
                    top: wheelDim.top || 150,
                    visible: wheelVisible
                },
                giftbox: {
                    width: giftboxDim.width,
                    height: giftboxDim.height,
                    left: giftboxDim.left,
                    top: giftboxDim.top || 150,
                    visible: giftboxVisible,
                    autoHide: giftboxAutoHide
                },
                entryText: {
                    left: entryText ? (parseInt(entryText.style.left) || entryText.offsetLeft || 0) : 0,
                    top: entryText ? (parseInt(entryText.style.top) || entryText.offsetTop || 50) : 50
                },
                entryVideo: {
                    width: entryVideoDim.width,
                    height: entryVideoDim.height,
                    left: entryVideoDim.left || 100,
                    top: entryVideoDim.top || 100,
                    visible: entryVideoVisible
                },
                randomVideo: {
                    width: randomVideoDim.width,
                    height: randomVideoDim.height,
                    left: randomVideoDim.left || 50,
                    top: randomVideoDim.top || 400,
                    visible: randomVideoVisible
                },
                duckVideo: {
                    width: duckVideoDim.width,
                    height: duckVideoDim.height,
                    left: duckVideoDim.left || 400,
                    top: duckVideoDim.top || 400,
                    visible: duckVideoVisible
                },
                duckCounter: {
                    width: duckCounterDim.width,
                    height: duckCounterDim.height,
                    left: duckCounterDim.left || 50,
                    top: duckCounterDim.top || 50,
                    visible: duckCounterVisible
                },
                pityCounter: {
                    width: pityCounterDim.width,
                    height: pityCounterDim.height,
                    left: pityCounterDim.left || 50,
                    top: pityCounterDim.top || 170,
                    visible: pityCounterVisible
                },
                leaderboard: {
                    width: leaderboardDim.width,
                    height: leaderboardDim.height,
                    left: leaderboardDim.left || 50,
                    top: leaderboardDim.top || 300,
                    visible: leaderboardVisible
                },
                giftImage: {
                    width: giftImageDim.width,
                    height: giftImageDim.height,
                    left: giftImageDim.left,
                    top: giftImageDim.top,
                    visible: giftImageVisible,
                    // 保存原始內容尺寸（用於計算縮放比例）
                    originalWidth: giftImageDisplay ? (parseInt(giftImageDisplay.dataset.originalWidth) || 0) : 0,
                    originalHeight: giftImageDisplay ? (parseInt(giftImageDisplay.dataset.originalHeight) || 0) : 0,
                    // 保存禮物圖資料（用於恢復）
                    data: giftImageData
                },
                videoContainers: videoData,
                videoModuleVisible: videoVisible,
                elementZIndexes: elementZIndexes  // 保存圖層順序
            };

            // 保存到配置文件
            try {
                if (window.pywebview && window.pywebview.api) {
                    await pywebview.api.save_greenscreen_positions(positions);
                    // 同步更新 savedPositions，確保下次重新生成容器時位置正確
                    savedPositions = positions;
                    console.log('[保存] 綠幕位置已保存');
                }
            } catch (e) {
                console.error('[保存] 失敗:', e);
            }
        }

        // (已移除 - 位置現在在 applyWheelPosition 和 generateVideoContainers 中直接套用)

        // === 測試功能 ===
        function updateWheelTestButton() {
            const btn = document.getElementById('testWheelBtn');
            if (btn) {
                btn.disabled = !wheelModuleEnabled;
                btn.textContent = wheelModuleEnabled ? '🎡 測試轉盤' : '🎡 模組已關閉';
            }
        }

        function updateGiftboxTestButton() {
            const btn = document.getElementById('testGiftboxBtn');
            if (btn) {
                btn.disabled = false;
                btn.textContent = '🎁 測試盲盒';
            }
        }

        function testGiftboxOpen() {
            console.log('[盲盒測試] 觸發');
            triggerGiftbox(1);
        }

        function testEntryText() {
            console.log('[進場文字測試] 觸發');
            showEntryText({
                username: '測試用戶',
                text: '歡迎 {name} 進入直播間！',
                text_size: 48,
                text_color: '#ffffff',
                text_duration: 5
            });
        }

        async function testEntryVideo() {
            console.log('[進場影片測試] 觸發');
            try {
                // 從配置獲取進場列表
                const config = await pywebview.api.get_config();
                const entryList = config.entry_list || [];
                const entryConfig = config.entry_config || {};

                // 優先使用專屬進場列表中的第一個
                let testEntry = null;
                if (entryList.length > 0 && entryList[0].media_path) {
                    testEntry = entryList[0];
                } else if (entryConfig.media_path) {
                    testEntry = entryConfig;
                }

                if (!testEntry || !testEntry.media_path) {
                    alert('沒有設定進場效果！請先在主介面設定進場媒體。');
                    return;
                }

                const isAudio = /\.(mp3|wav|ogg|m4a|aac)$/i.test(testEntry.media_path);

                triggerEntry({
                    username: '測試用戶',
                    level: 30,
                    path: testEntry.media_path,
                    volume: testEntry.volume || 100,
                    force_interrupt: testEntry.force_interrupt !== false,
                    is_audio: isAudio,
                    show_text: testEntry.show_text || false,
                    text: testEntry.text || '',
                    text_size: testEntry.text_size || 48,
                    text_color: testEntry.text_color || '#ffffff',
                    text_duration: testEntry.text_duration || 5,
                    is_specific: true
                });
            } catch (e) {
                console.error('[進場影片測試] 錯誤:', e);
                alert('測試失敗: ' + e.message);
            }
        }

        // === 禮物圖顯示功能 ===
        let giftImageVisible = false;
        let giftImageData = null;  // 保存禮物圖資料用於恢復

        function showGiftImageOnGreenScreen(data) {
            // 保存資料以便恢復
            giftImageData = data;
            console.log('[禮物圖] 顯示', data);
            const container = document.getElementById('giftImageDisplay');
            const content = document.getElementById('giftImageContent');
            if (!container || !content) return;

            const { items, settings } = data;
            if (!items || items.length === 0) {
                container.style.display = 'none';
                giftImageVisible = false;
                return;
            }

            // 背景樣式
            let bgStyle = '';
            if (settings.bgType === 'transparent') {
                bgStyle = 'background: transparent;';
            } else if (settings.bgType === 'gradient') {
                bgStyle = `background: linear-gradient(135deg, ${settings.bgColor}, ${settings.bgColor2});`;
            } else {
                bgStyle = `background: ${settings.bgColor};`;
            }

            // 文字樣式
            const textStyle = `
                font-size: ${settings.fontSize}px;
                color: ${settings.fontColor};
                font-weight: ${settings.fontBold ? 'bold' : 'normal'};
                ${settings.textShadow ? 'text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);' : ''}
            `;

            // 圖示位置樣式
            const itemFlexDirection = settings.iconPosition === 'right' ? 'row-reverse' : 'row';

            content.style.cssText = `
                ${bgStyle}
                padding: ${settings.padding}px;
                gap: ${settings.gap}px;
                grid-template-columns: repeat(${settings.columns}, 1fr);
                ${settings.rounded ? 'border-radius: 16px;' : ''}
            `;

            content.innerHTML = items.map(item => `
                <div class="gift-image-grid-item" style="flex-direction: ${itemFlexDirection};">
                    ${item.iconUrl
                        ? `<img src="${item.iconUrl}" style="width: ${settings.iconSize}px; height: ${settings.iconSize}px;" onerror="this.style.display='none'">`
                        : `<div style="width: ${settings.iconSize}px; height: ${settings.iconSize}px; display: flex; align-items: center; justify-content: center; font-size: ${settings.iconSize * 0.6}px;">🎁</div>`
                    }
                    <span class="gift-label" style="${textStyle} font-family: '${item.font || 'Microsoft JhengHei'}', sans-serif;">${escapeHtmlGs(item.name)}</span>
                </div>
            `).join('');

            container.style.display = 'block';
            giftImageVisible = true;

            // 使用 requestAnimationFrame 等待內容渲染完成後保存原始尺寸
            const wrapper = container.querySelector('.gift-image-wrapper');
            if (wrapper) {
                // 重置縮放以取得真實尺寸
                wrapper.style.transform = 'none';
            }
            requestAnimationFrame(() => {
                // 保存原始尺寸到 dataset
                const origW = content.offsetWidth || content.scrollWidth || 300;
                const origH = content.offsetHeight || content.scrollHeight || 200;
                container.dataset.originalWidth = origW;
                container.dataset.originalHeight = origH;

                // 如果容器有自訂尺寸，套用縮放
                const containerW = parseInt(container.style.width);
                const containerH = parseInt(container.style.height);
                if (wrapper && containerW > 0 && containerH > 0) {
                    const scaleX = containerW / origW;
                    const scaleY = containerH / origH;
                    const scale = Math.min(scaleX, scaleY);
                    wrapper.style.transform = `scale(${scale})`;
                }

                savePositionsDebounced();
            });
        }

        function hideGiftImage() {
            const container = document.getElementById('giftImageDisplay');
            if (container) {
                container.style.display = 'none';
                giftImageVisible = false;
                giftImageData = null;  // 清除資料
                savePositionsDebounced();  // 保存狀態
            }
        }

        function toggleGiftImageVisible() {
            if (giftImageVisible) {
                hideGiftImage();
            } else {
                // 如果要顯示但沒有內容，提示用戶
                const content = document.getElementById('giftImageContent');
                if (!content || !content.innerHTML) {
                    console.log('[禮物圖] 尚無內容，請從主介面發送');
                    return;
                }
                document.getElementById('giftImageDisplay').style.display = 'block';
                giftImageVisible = true;
            }
            savePositionsDebounced();
        }

        async function exportGiftImageToFile(data) {
            console.log('[禮物圖] 匯出', data);
            const { items, settings, savePath } = data;
            if (!items || items.length === 0) return;

            // 創建一個臨時的 canvas 來繪製禮物圖
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const columns = settings.columns || 3;
            const gap = settings.gap || 20;
            const iconSize = settings.iconSize || 64;
            const padding = settings.padding || 30;
            const fontSize = settings.fontSize || 24;

            // 計算文字最大寬度（考慮每個項目的字體）
            let maxTextWidth = 0;
            items.forEach(item => {
                const itemFont = item.font || 'Microsoft JhengHei';
                ctx.font = `${settings.fontBold ? 'bold' : 'normal'} ${fontSize}px '${itemFont}', sans-serif`;
                const w = ctx.measureText(item.name).width;
                if (w > maxTextWidth) maxTextWidth = w;
            });

            const itemWidth = iconSize + 12 + maxTextWidth + 20;
            const itemHeight = Math.max(iconSize, fontSize + 10);
            const rows = Math.ceil(items.length / columns);

            const canvasWidth = padding * 2 + columns * itemWidth + (columns - 1) * gap;
            const canvasHeight = padding * 2 + rows * itemHeight + (rows - 1) * gap;

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // 背景
            if (settings.bgType === 'gradient') {
                const gradient = ctx.createLinearGradient(0, 0, canvasWidth, canvasHeight);
                gradient.addColorStop(0, settings.bgColor);
                gradient.addColorStop(1, settings.bgColor2);
                ctx.fillStyle = gradient;
            } else if (settings.bgType !== 'transparent') {
                ctx.fillStyle = settings.bgColor;
            }

            if (settings.bgType !== 'transparent') {
                if (settings.rounded) {
                    roundRect(ctx, 0, 0, canvasWidth, canvasHeight, 16);
                    ctx.fill();
                } else {
                    ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                }
            }

            // 載入所有圖片
            const loadImage = (url) => {
                return new Promise((resolve) => {
                    if (!url) {
                        resolve(null);
                        return;
                    }
                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => resolve(img);
                    img.onerror = () => resolve(null);
                    img.src = url;
                });
            };

            const images = await Promise.all(items.map(item => loadImage(item.iconUrl)));

            // 繪製每個禮物
            ctx.fillStyle = settings.fontColor;
            ctx.textBaseline = 'middle';

            if (settings.textShadow) {
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 4;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
            }

            items.forEach((item, i) => {
                const col = i % columns;
                const row = Math.floor(i / columns);
                const x = padding + col * (itemWidth + gap);
                const y = padding + row * (itemHeight + gap);

                // 繪製圖示
                const img = images[i];
                if (img) {
                    ctx.drawImage(img, x, y + (itemHeight - iconSize) / 2, iconSize, iconSize);
                } else {
                    // 繪製預設圖示
                    ctx.save();
                    ctx.font = `${iconSize * 0.6}px sans-serif`;
                    ctx.fillText('🎁', x + iconSize / 4, y + itemHeight / 2);
                    ctx.restore();
                }

                // 繪製文字（使用每個項目自己的字體）
                const itemFont = item.font || 'Microsoft JhengHei';
                ctx.font = `${settings.fontBold ? 'bold' : 'normal'} ${fontSize}px '${itemFont}', sans-serif`;
                ctx.fillStyle = settings.fontColor;
                ctx.fillText(item.name, x + iconSize + 12, y + itemHeight / 2);
            });

            // 匯出為圖片並保存
            const dataUrl = canvas.toDataURL('image/png');
            // 通知主進程保存文件
            if (window.electronAPI && savePath) {
                // 發送 base64 數據到主進程保存
                const base64Data = dataUrl.replace(/^data:image\/png;base64,/, '');
                try {
                    await window.electronAPI.saveExportedImage(savePath, base64Data);
                    console.log('[禮物圖] 已匯出到:', savePath);
                } catch (e) {
                    console.error('[禮物圖] 匯出失敗:', e);
                }
            }
        }

        function roundRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        // === 盲盒功能 ===
        function triggerGiftbox(opens) {
            console.log('[盲盒] 觸發，選項數量:', giftboxOptions.length, '正在開盒:', isGiftboxOpening);

            if (isGiftboxOpening) {
                console.log('[盲盒] 正在開盒中，忽略');
                return;
            }

            // 如果沒有選項，使用預設選項進行測試
            if (giftboxOptions.length === 0) {
                console.log('[盲盒] 沒有選項，使用預設');
                giftboxOptions = [
                    { name: '大獎', color: '#ffd93d', weight: 1 },
                    { name: '中獎', color: '#4ecca3', weight: 2 },
                    { name: '小獎', color: '#00d9ff', weight: 3 }
                ];
            }

            isGiftboxOpening = true;
            const container = document.getElementById('giftboxContainer');
            const box = document.getElementById('giftboxBox');
            const resultEl = document.getElementById('giftboxResult');
            const confettiEl = document.getElementById('giftboxConfetti');
            const countdownEl = document.getElementById('giftboxCountdown');
            const videoContainer = document.getElementById('giftboxVideoContainer');
            const videoEl = document.getElementById('giftboxVideo');

            // 強制顯示盲盒容器
            container.classList.remove('hidden');
            container.style.display = 'block';
            container.style.visibility = 'visible';
            container.style.opacity = '1';
            console.log('[盲盒] 強制顯示容器');

            // 如果是自動隱藏模式，先顯示盲盒
            if (giftboxAutoHide) {
                // 清除強制隱藏的 inline style
                container.style.opacity = '';
                container.style.visibility = '';
                container.style.pointerEvents = '';
                container.classList.add('triggered');
            }

            // 隨機選擇結果（根據權重）
            const totalWeight = giftboxOptions.reduce((sum, opt) => sum + (opt.weight || 1), 0);
            let random = Math.random() * totalWeight;
            let selectedOption = giftboxOptions[0];
            for (const opt of giftboxOptions) {
                random -= (opt.weight || 1);
                if (random <= 0) {
                    selectedOption = opt;
                    break;
                }
            }

            // 開盒動畫
            box.classList.add('opening');

            // 創建彩帶效果（先準備好，但不啟動）
            confettiEl.innerHTML = '';
            const colors = ['#e94560', '#4ecca3', '#ffd93d', '#00d9ff', '#ff6b9d'];
            for (let i = 0; i < 20; i++) {
                const piece = document.createElement('div');
                piece.className = 'confetti-piece';
                piece.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                piece.style.left = Math.random() * 100 + '%';
                piece.style.animationDelay = Math.random() * 0.5 + 's';
                piece.style.animationDuration = (1 + Math.random()) + 's';
                confettiEl.appendChild(piece);
            }

            // 0.3秒後開始滾動動畫
            setTimeout(() => {
                box.classList.add('rolling');

                // 滾動參數
                let currentIndex = 0;
                let interval = 50;  // 初始速度（毫秒）
                const maxInterval = 400;  // 最慢速度
                const acceleration = 1.15;  // 減速係數
                const minSpins = 15;  // 最少滾動次數
                let spinCount = 0;

                // 找到選中選項的索引
                const selectedIndex = giftboxOptions.indexOf(selectedOption);

                const spin = () => {
                    // 顯示當前選項（重置動畫）
                    const currentOption = giftboxOptions[currentIndex];
                    resultEl.style.animation = 'none';
                    void resultEl.offsetWidth;  // 強制重繪
                    resultEl.style.animation = '';
                    resultEl.textContent = currentOption.name;
                    resultEl.style.backgroundColor = currentOption.color || '#4ecca3';

                    // 移動到下一個選項
                    currentIndex = (currentIndex + 1) % giftboxOptions.length;
                    spinCount++;

                    // 減速
                    interval = Math.min(interval * acceleration, maxInterval);

                    // 判斷是否停止：已經轉夠了，速度夠慢，且停在選中的選項上
                    if (spinCount >= minSpins && interval >= maxInterval &&
                        currentIndex === (selectedIndex + 1) % giftboxOptions.length) {
                        // 停止滾動，顯示最終結果
                        resultEl.textContent = selectedOption.name;
                        resultEl.style.backgroundColor = selectedOption.color || '#4ecca3';

                        // 切換到顯示結果狀態
                        box.classList.remove('rolling');
                        box.classList.add('showing-result');

                        // 啟動彩帶動畫
                        confettiEl.querySelectorAll('.confetti-piece').forEach(piece => {
                            piece.style.animation = `confetti-fall ${1 + Math.random()}s ease-out forwards`;
                        });

                        console.log('盲盒結果:', selectedOption.name);

                        // 滾動完成後，如果有影片設定，啟動倒數計時
                        if (selectedOption.video_path) {
                            // 延遲0.5秒讓結果彈跳動畫完成，再開始倒數
                            setTimeout(() => {
                                startGiftboxCountdown(selectedOption);
                            }, 500);
                        } else {
                            // 沒有影片，3秒後重置
                            setTimeout(() => {
                                resetGiftbox();
                            }, 3000);
                        }
                    } else {
                        // 繼續滾動
                        setTimeout(spin, interval);
                    }
                };

                // 開始滾動
                spin();
            }, 300);
        }

        // 盲盒倒數計時
        function startGiftboxCountdown(option) {
            const countdownEl = document.getElementById('giftboxCountdown');
            let count = 3;

            const doCountdown = () => {
                countdownEl.textContent = count;
                countdownEl.classList.remove('active');
                // 強制重繪以重新觸發動畫
                void countdownEl.offsetWidth;
                countdownEl.classList.add('active');

                if (count > 1) {
                    count--;
                    setTimeout(doCountdown, 1000);
                } else {
                    // 倒數完成，播放影片
                    setTimeout(() => {
                        countdownEl.classList.remove('active');
                        playGiftboxVideo(option);
                    }, 1000);
                }
            };

            doCountdown();
        }

        // 播放盲盒影片
        function playGiftboxVideo(option) {
            const box = document.getElementById('giftboxBox');
            const videoContainer = document.getElementById('giftboxVideoContainer');
            const videoEl = document.getElementById('giftboxVideo');

            // 隱藏盒子，顯示影片
            box.style.display = 'none';
            videoContainer.classList.add('active');

            // 設定影片
            const videoSrc = formatVideoPath(option.video_path);
            videoEl.src = videoSrc;
            videoEl.volume = (option.video_volume || 100) / 100;
            videoEl.muted = false;

            // 設定播放時長限制
            const videoSeconds = option.video_seconds || 0;
            let playTimeout = null;

            videoEl.onloadeddata = () => {
                videoEl.play().then(() => {
                    console.log('盲盒影片開始播放');

                    if (videoSeconds > 0) {
                        playTimeout = setTimeout(() => {
                            videoEl.pause();
                            endGiftboxVideo();
                        }, videoSeconds * 1000);
                    }
                }).catch(e => {
                    console.error('盲盒影片播放失敗:', e);
                    endGiftboxVideo();
                });
            };

            videoEl.onended = () => {
                if (playTimeout) clearTimeout(playTimeout);
                endGiftboxVideo();
            };

            videoEl.onerror = () => {
                console.error('盲盒影片載入錯誤');
                endGiftboxVideo();
            };

            videoEl.load();
        }

        // 結束盲盒影片播放
        function endGiftboxVideo() {
            console.log('[盲盒] 影片結束，開始重置');
            const videoContainer = document.getElementById('giftboxVideoContainer');
            const videoEl = document.getElementById('giftboxVideo');
            const box = document.getElementById('giftboxBox');

            videoEl.pause();
            videoEl.removeAttribute('src');
            videoEl.load();
            videoContainer.classList.remove('active');
            box.style.display = '';

            resetGiftbox();
        }

        // 重置盲盒狀態
        function resetGiftbox() {
            const container = document.getElementById('giftboxContainer');
            const box = document.getElementById('giftboxBox');
            const confettiEl = document.getElementById('giftboxConfetti');
            const resultEl = document.getElementById('giftboxResult');
            const countdownEl = document.getElementById('giftboxCountdown');
            const videoContainer = document.getElementById('giftboxVideoContainer');
            const videoEl = document.getElementById('giftboxVideo');

            box.classList.remove('opening', 'rolling', 'showing-result');
            box.style.display = '';
            confettiEl.innerHTML = '';

            // 重置影片容器
            videoContainer.classList.remove('active');
            videoEl.pause();
            videoEl.removeAttribute('src');

            // 重置結果和倒數顯示
            resultEl.textContent = '';
            resultEl.style.animation = '';
            resultEl.style.backgroundColor = '';
            countdownEl.classList.remove('active');
            countdownEl.textContent = '3';

            // 如果是自動隱藏模式，隱藏盲盒
            if (giftboxAutoHide) {
                console.log('[盲盒] 自動隱藏 - 強制隱藏');
                container.classList.remove('triggered');
                // 強制隱藏
                container.style.opacity = '0';
                container.style.visibility = 'hidden';
                container.style.pointerEvents = 'none';
            }

            isGiftboxOpening = false;
            console.log('[盲盒] 已重置');
        }

        // 重新載入所有縮圖
        function reloadAllThumbnails() {
            console.log('[DEBUG] 重新載入所有縮圖');

            document.querySelectorAll('.video-container').forEach((container, i) => {
                const thumbnail = container.querySelector('.thumbnail-video');
                if (!thumbnail) return;

                const idx = container.dataset.index;
                const src = thumbnail.src || thumbnail.getAttribute('src');

                console.log(`[DEBUG] 重新載入縮圖 [${idx}], src=${src ? src.substring(0, 80) : 'empty'}`);

                if (!src || src === 'undefined' || src === '') {
                    console.warn(`[WARN] 縮圖 [${idx}] 沒有有效的 src`);
                    container.style.background = 'rgba(255, 165, 0, 0.3)';  // 橙色表示無 src
                    return;
                }

                // 重置容器背景（如果之前顯示錯誤）
                container.style.background = 'rgba(0, 0, 0, 0.3)';
                thumbnail.style.display = 'block';
                thumbnail.style.visibility = 'visible';
                thumbnail.style.opacity = '1';

                // 清除舊事件
                thumbnail.onloadedmetadata = null;
                thumbnail.onloadeddata = null;
                thumbnail.onerror = null;
                thumbnail.oncanplay = null;

                // 強制重新載入
                thumbnail.removeAttribute('src');

                // 設定事件處理
                thumbnail.onloadedmetadata = () => {
                    console.log(`[DEBUG] 縮圖重載 metadata 成功 [${idx}], readyState=${thumbnail.readyState}`);
                    try {
                        thumbnail.currentTime = 1;
                    } catch (e) {
                        console.warn(`[WARN] 設定縮圖時間失敗 [${idx}]:`, e);
                    }
                };

                thumbnail.onloadeddata = () => {
                    console.log(`[DEBUG] 縮圖重載 data 成功 [${idx}], readyState=${thumbnail.readyState}, currentTime=${thumbnail.currentTime}`);
                    if (thumbnail.currentTime === 0) {
                        try {
                            thumbnail.currentTime = 1;
                        } catch (e) {
                            console.warn(`[WARN] 設定縮圖時間失敗 (loadeddata) [${idx}]:`, e);
                        }
                    }
                };

                thumbnail.oncanplay = () => {
                    console.log(`[DEBUG] 縮圖可播放 [${idx}], currentTime=${thumbnail.currentTime}`);
                };

                thumbnail.onerror = (e) => {
                    console.error(`[ERROR] 縮圖重載失敗 [${idx}]:`, e, thumbnail.error);
                    thumbnail.style.display = 'none';
                    container.style.background = 'rgba(255, 0, 0, 0.3)';
                };

                // 重新設定 src 並載入
                setTimeout(() => {
                    console.log(`[DEBUG] 設定縮圖 src [${idx}]`);
                    thumbnail.src = src;
                    thumbnail.load();
                }, 50 * i);  // 錯開載入時間
            });

            console.log('[DEBUG] 縮圖重載已觸發');
        }

        // 重置所有裁切狀態
        async function resetAllCropStates() {
            console.log('[DEBUG] 重置所有裁切狀態');

            // 重置每個容器
            document.querySelectorAll('.video-container').forEach(vc => {
                const idx = vc.dataset.index;
                const width = 300;
                const height = 200;

                // 重置裁切狀態
                videoCropState[idx] = {
                    cropLeft: 0,
                    cropTop: 0,
                    originalWidth: width,
                    originalHeight: height
                };

                // 更新容器尺寸
                vc.style.width = width + 'px';
                vc.style.height = height + 'px';

                // 重置縮圖和播放器
                const thumbnail = vc.querySelector('.thumbnail-video');
                const player = vc.querySelector('.video-player');

                if (thumbnail) {
                    thumbnail.style.width = width + 'px';
                    thumbnail.style.height = height + 'px';
                    thumbnail.style.left = '0px';
                    thumbnail.style.top = '0px';
                }
                if (player) {
                    player.style.width = width + 'px';
                    player.style.height = height + 'px';
                    player.style.left = '0px';
                    player.style.top = '0px';
                }

                // 更新容器資料
                if (videoContainers[idx]) {
                    videoContainers[idx].width = width;
                    videoContainers[idx].height = height;
                    videoContainers[idx].cropLeft = 0;
                    videoContainers[idx].cropTop = 0;
                    videoContainers[idx].originalWidth = width;
                    videoContainers[idx].originalHeight = height;
                }
            });

            // 保存到配置文件
            await savePositions();
            console.log('[DEBUG] 裁切狀態已重置並保存');
            alert('裁切狀態已重置！');
        }

        function testWheelSpin() {
            if (!wheelModuleEnabled) return;
            triggerWheel(1);
        }

        // === 轉盤繪製 ===
        function drawWheel() {
            const canvas = document.getElementById('wheelCanvas');
            const ctx = canvas.getContext('2d');
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            const radius = Math.max(10, Math.min(cx, cy) - 15);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (wheelOptions.length === 0 || radius < 10) return;

            const totalWeight = wheelOptions.reduce((sum, opt) => sum + opt.weight, 0);
            let startAngle = (wheelAngle * Math.PI / 180);

            wheelOptions.forEach(opt => {
                const sweep = (2 * Math.PI * opt.weight / totalWeight);

                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.arc(cx, cy, radius, startAngle, startAngle + sweep);
                ctx.closePath();
                ctx.fillStyle = opt.color;
                ctx.fill();

                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 2;
                ctx.stroke();

                const textAngle = startAngle + sweep / 2;
                const textRadius = radius * 0.65;
                const textX = cx + textRadius * Math.cos(textAngle);
                const textY = cy + textRadius * Math.sin(textAngle);

                ctx.save();
                ctx.translate(textX, textY);
                ctx.rotate(textAngle + Math.PI / 2);
                ctx.fillStyle = '#000';
                ctx.font = `bold ${Math.max(12, radius / 12)}px Microsoft JhengHei`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(opt.name, 0, 0);
                ctx.restore();

                startAngle += sweep;
            });

            // 中心圓
            ctx.beginPath();
            ctx.arc(cx, cy, radius * 0.1, 0, Math.PI * 2);
            ctx.fillStyle = 'white';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 3;
            ctx.stroke();

            // 指針
            const pointerSize = radius * 0.12;
            ctx.beginPath();
            ctx.moveTo(cx - pointerSize, 10);
            ctx.lineTo(cx + pointerSize, 10);
            ctx.lineTo(cx, 10 + pointerSize * 2);
            ctx.closePath();
            ctx.fillStyle = '#e94560';
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // === 轉盤動畫 ===
        function triggerWheel(spins) {
            if (isSpinning) return;
            spinWheel(spins);
        }

        function spinWheel(spins) {
            if (isSpinning || wheelOptions.length === 0) return;

            isSpinning = true;

            const startAngle = wheelAngle;
            const extraSpins = 5 + Math.floor(Math.random() * 3);
            const targetAngle = startAngle + 360 * extraSpins + Math.random() * 360;
            const duration = 4000;
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                wheelAngle = startAngle + (targetAngle - startAngle) * eased;

                drawWheel();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    isSpinning = false;
                    wheelAngle = wheelAngle % 360;
                    const result = getWheelResult();
                    console.log('轉盤結果:', result);
                }
            }

            requestAnimationFrame(animate);
        }

        function getWheelResult() {
            const pointerAngle = (270 - wheelAngle % 360 + 360) % 360;
            const totalWeight = wheelOptions.reduce((sum, opt) => sum + opt.weight, 0);

            let cumAngle = 0;
            for (const opt of wheelOptions) {
                const optAngle = 360 * opt.weight / totalWeight;
                if (pointerAngle >= cumAngle && pointerAngle < cumAngle + optAngle) {
                    return opt;
                }
                cumAngle += optAngle;
            }
            return wheelOptions[0];
        }

        // === 影片播放 ===
        // 根據影片路徑找到對應的容器並播放
        function triggerVideo(videoData) {
            if (!videoData.path) return;

            // 找到對應的容器 (根據路徑匹配)
            let foundIndex = -1;
            for (let i = 0; i < videoGifts.length; i++) {
                if (videoGifts[i].video_path === videoData.path) {
                    foundIndex = i;
                    break;
                }
            }

            // 如果找不到對應容器（例如隨機影片），使用專用隨機影片容器
            if (foundIndex === -1) {
                console.log('[隨機影片] 使用專用容器播放:', videoData.path);
                playRandomVideo(videoData);
                return;
            }

            // 使用對應容器播放
            triggerVideoInContainer(foundIndex, videoData);
        }

        // 隨機影片播放狀態
        let randomVideoQueue = [];
        let randomVideoPlaying = false;
        let randomVideoVisible = false;

        // 初始化隨機影片容器位置
        function initRandomVideoContainer() {
            const container = document.getElementById('randomVideoContainer');
            if (!container) return;

            // 從保存的位置載入
            const saved = savedPositions.randomVideo || {};
            container.style.width = (saved.width || 300) + 'px';
            container.style.height = (saved.height || 200) + 'px';
            container.style.left = (saved.left || 50) + 'px';
            container.style.top = (saved.top || 400) + 'px';
            randomVideoVisible = saved.visible !== false;

            if (!randomVideoVisible) {
                container.classList.add('hidden');
            }

            console.log('[隨機影片] 容器初始化完成');
        }

        // 播放隨機影片（使用專用容器）
        function playRandomVideo(videoData) {
            // 加入佇列
            const playCount = Math.min(videoData.count || 1, 100);
            for (let i = 0; i < playCount; i++) {
                randomVideoQueue.push({...videoData, count: 1});
            }
            console.log(`[隨機影片] 加入佇列，目前長度: ${randomVideoQueue.length}`);

            // 如果強制插隊且正在播放，停止當前播放
            if (videoData.force_interrupt && randomVideoPlaying) {
                stopRandomVideo();
            }

            playNextRandomVideo();
        }

        // 播放下一個隨機影片
        async function playNextRandomVideo() {
            if (randomVideoPlaying || randomVideoQueue.length === 0) return;

            const container = document.getElementById('randomVideoContainer');
            const video = document.getElementById('randomVideoPlayer');
            if (!container || !video) {
                console.error('[隨機影片] 找不到專用容器');
                return;
            }

            const data = randomVideoQueue.shift();
            if (!data.path) {
                playNextRandomVideo();
                return;
            }

            randomVideoPlaying = true;
            console.log('[隨機影片] 開始播放:', data.path);

            // 取得媒體 URL
            let videoUrl = data.path;
            if (window.pywebview && window.pywebview.api) {
                try {
                    videoUrl = await pywebview.api.get_media_url(data.path);
                } catch (e) {
                    console.error('[隨機影片] 取得 URL 失敗:', e);
                }
            }

            // 設定影片
            video.src = videoUrl;
            video.playbackRate = data.speed || 1;
            video.volume = (data.volume || 100) / 100;
            video.currentTime = 0;

            // 顯示容器並標記播放中
            container.classList.remove('hidden');
            container.classList.add('playing');

            // 處理重複播放
            let currentRepeat = 0;
            const maxRepeat = data.repeat || 1;
            const maxSeconds = data.seconds || 0;

            const onEnded = () => {
                currentRepeat++;
                if (currentRepeat < maxRepeat) {
                    video.currentTime = 0;
                    video.play();
                } else {
                    finishRandomVideo();
                }
            };

            const finishRandomVideo = () => {
                video.onended = null;
                video.ontimeupdate = null;
                video.onerror = null;
                // 釋放影片記憶體
                video.src = '';
                video.load();
                container.classList.remove('playing');
                // 如果原本是隱藏的，恢復隱藏
                if (!randomVideoVisible) {
                    container.classList.add('hidden');
                }
                randomVideoPlaying = false;
                console.log('[隨機影片] 播放完成');
                playNextRandomVideo();
            };

            video.onended = onEnded;

            // 如果設定了秒數限制
            if (maxSeconds > 0) {
                video.ontimeupdate = () => {
                    if (video.currentTime >= maxSeconds) {
                        currentRepeat++;
                        if (currentRepeat < maxRepeat) {
                            video.currentTime = 0;
                        } else {
                            finishRandomVideo();
                        }
                    }
                };
            }

            video.onerror = (e) => {
                console.error('[隨機影片] 播放錯誤:', e);
                finishRandomVideo();
            };

            try {
                await video.play();
            } catch (e) {
                console.error('[隨機影片] 播放失敗:', e);
                finishRandomVideo();
            }
        }

        // 停止隨機影片
        function stopRandomVideo() {
            const container = document.getElementById('randomVideoContainer');
            const video = document.getElementById('randomVideoPlayer');
            if (video) {
                video.pause();
                video.onended = null;
                video.ontimeupdate = null;
                video.onerror = null;
                // 釋放影片記憶體
                video.src = '';
                video.load();
            }
            if (container) {
                container.classList.remove('playing');
                if (!randomVideoVisible) {
                    container.classList.add('hidden');
                }
            }
            randomVideoPlaying = false;
        }

        // 切換隨機影片容器顯示
        function toggleRandomVideoVisible() {
            const container = document.getElementById('randomVideoContainer');
            if (!container) return;

            randomVideoVisible = !randomVideoVisible;
            if (randomVideoVisible) {
                container.classList.remove('hidden');
            } else {
                container.classList.add('hidden');
            }
            savePositions();
            return randomVideoVisible;
        }

        // === 抓鴨子模組 ===
        let duckVideoPlaying = false;
        let duckVideoVisible = false;
        let duckCounterVisible = false;
        let pendingDuckAmount = 0;  // 等待影片播完後要加的鴨子數量
        let pendingDuckUsername = '';  // 抓到鴨子的用戶名
        let pendingPityData = null;  // 等待影片播完後要更新的保底資料
        let duckVideoQueue = [];  // 抓鴨子影片佇列
        let pendingLeaderboardData = null;  // 當前影片播完後要更新的排行榜資料
        let pendingMilestoneData = null;  // 當前影片播完後要觸發的里程碑

        // 播放抓鴨子影片
        async function playDuckVideo(videoData) {
            // 如果正在播放，加入佇列
            if (duckVideoPlaying) {
                duckVideoQueue.push(videoData);
                return;
            }
            await playDuckVideoNow(videoData);
        }

        // 立即播放抓鴨子影片
        async function playDuckVideoNow(videoData) {
            // 立即設定播放中狀態，防止競態條件（必須在任何 await 之前）
            duckVideoPlaying = true;

            const container = document.getElementById('duckVideoContainer');
            const video = document.getElementById('duckVideoPlayer');

            if (!container || !video) {
                duckVideoPlaying = false;
                playNextDuckVideo();
                return;
            }

            // 儲存待加的鴨子數量（影片播完後才加）
            pendingDuckAmount = videoData.caught ? (videoData.duckAmount || 0) : 0;
            pendingDuckUsername = videoData.username || '';
            // 儲存保底資料（影片播完後才更新 UI）
            if (videoData.pityEnabled) {
                pendingPityData = {
                    current: videoData.pityCounter,
                    threshold: videoData.pityThreshold,
                    thresholdJackpot: videoData.pityThresholdJackpot
                };
            } else {
                pendingPityData = null;
            }
            // 儲存排行榜資料（影片播完後更新）
            pendingLeaderboardData = videoData.leaderboardData || null;
            // 儲存里程碑資料（影片播完後觸發）
            pendingMilestoneData = videoData.milestoneData || null;

            try {
                // 取得媒體 URL
                let videoUrl = videoData.path;
                if (window.pywebview && window.pywebview.api) {
                    videoUrl = await window.pywebview.api.get_media_url(videoData.path);
                }

                // 先清空舊影片源以釋放記憶體
                video.pause();
                video.removeAttribute('src');
                video.load();

                // 等待一幀確保清理完成
                await new Promise(r => requestAnimationFrame(r));

                // 設定影片
                video.src = videoUrl;
                video.volume = (videoData.volume || 100) / 100;
                video.muted = false;

                // 等待影片載入完成再播放（減少卡頓）
                await new Promise((resolve, reject) => {
                    const onCanPlay = () => {
                        video.removeEventListener('canplaythrough', onCanPlay);
                        video.removeEventListener('error', onError);
                        resolve();
                    };
                    const onError = () => {
                        video.removeEventListener('canplaythrough', onCanPlay);
                        video.removeEventListener('error', onError);
                        reject();
                    };
                    video.addEventListener('canplaythrough', onCanPlay);
                    video.addEventListener('error', onError);
                    video.load();
                    // 超時保護
                    setTimeout(resolve, 5000);
                });

                // 載入完成後設定播放速度（避免被 load() 重置）
                video.playbackRate = videoData.speed || 1;
                console.log('[鴨子影片] 設定播放速度:', videoData.speed || 1);

                // 使用 requestAnimationFrame 確保在下一幀顯示
                await new Promise(r => requestAnimationFrame(r));

                // 顯示容器並播放
                container.classList.remove('hidden');
                container.classList.add('playing');

                // 處理播放結束
                const onEnded = () => {
                    finishDuckVideo();
                };

                // 如果有時間限制
                if (videoData.seconds > 0) {
                    setTimeout(() => {
                        if (duckVideoPlaying) {
                            finishDuckVideo();
                        }
                    }, videoData.seconds * 1000);
                }

                video.onended = onEnded;
                video.onerror = () => {
                    finishDuckVideo();
                };

                await video.play();
            } catch (e) {
                console.error('Duck video playback error:', e);
                finishDuckVideo();
            }
        }

        // 結束抓鴨子影片
        async function finishDuckVideo() {
            const container = document.getElementById('duckVideoContainer');
            const video = document.getElementById('duckVideoPlayer');

            if (video) {
                video.pause();
                video.onended = null;
                video.onerror = null;
                video.oncanplay = null;
                video.oncanplaythrough = null;
                // 徹底釋放影片記憶體
                video.removeAttribute('src');
                video.load();
                // 使用 requestAnimationFrame 確保清理完成
                await new Promise(r => requestAnimationFrame(r));
            }
            if (container) {
                container.classList.remove('playing');
                if (!duckVideoVisible) {
                    container.classList.add('hidden');
                }
            }

            // 先捕獲當前的數據，然後重置（避免競態條件）
            const amountToAdd = pendingDuckAmount;
            const pityData = pendingPityData;
            const leaderboardData = pendingLeaderboardData;
            const milestoneData = pendingMilestoneData;
            pendingDuckAmount = 0;
            pendingDuckUsername = '';
            pendingPityData = null;
            pendingLeaderboardData = null;
            pendingMilestoneData = null;

            // 影片播完後才增加鴨子數量
            if (amountToAdd > 0) {
                try {
                    await window.pywebview.api.add_duck(amountToAdd);
                } catch (e) {
                    // 忽略錯誤
                }
            }

            // 影片播完後才更新保底進度（綠幕本地 UI + 通知主視窗）
            if (pityData) {
                updatePityCounter(pityData);
                // 通知主視窗更新保底進度
                try {
                    await window.pywebview.api.notify_pity_update();
                } catch (e) {
                    // 忽略錯誤
                }
            }

            // 影片播完後才更新排行榜
            if (leaderboardData) {
                console.log('[排行榜] 影片播完，更新排行榜');
                updateLeaderboard(leaderboardData);
            }

            // 影片播完後才觸發里程碑
            if (milestoneData) {
                console.log('[里程碑] 影片播完，觸發里程碑:', milestoneData.type);
                triggerMilestoneCelebration(milestoneData);
            }

            // 全部處理完成後才設為 false，確保新事件會被正確排隊
            duckVideoPlaying = false;

            // 播放佇列中的下一個影片
            playNextDuckVideo();
        }

        // 播放佇列中的下一個抓鴨子影片
        function playNextDuckVideo() {
            if (duckVideoQueue.length > 0) {
                const nextVideo = duckVideoQueue.shift();
                playDuckVideoNow(nextVideo);
            } else {
                // 通知主進程處理下一個
                try {
                    window.pywebview.api.notify_duck_video_finished();
                } catch (e) {
                    // 忽略錯誤
                }
            }
        }

        // 更新鴨子計數
        let lastDuckCount = 0;
        function updateDuckCounter(count) {
            const counterValue = document.getElementById('duckCounterValue');
            const counterAdd = document.getElementById('duckCounterAdd');
            const counterBox = document.getElementById('duckCounterBox');

            if (counterValue) {
                // 計算增加的數量
                const diff = count - lastDuckCount;

                // 如果增加了鴨子，顯示 +X 動畫
                if (diff > 0 && counterAdd) {
                    counterAdd.textContent = `+${diff}`;
                    counterAdd.classList.remove('show');
                    // 強制重繪以重新觸發動畫
                    void counterAdd.offsetWidth;
                    counterAdd.classList.add('show');
                }

                counterValue.textContent = count;
                // 添加動畫效果
                counterValue.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    counterValue.style.transform = 'scale(1)';
                }, 200);

                lastDuckCount = count;
            }
        }

        // 切換鴨子影片容器顯示
        function toggleDuckVideoVisible() {
            const container = document.getElementById('duckVideoContainer');
            if (!container) return;

            duckVideoVisible = !duckVideoVisible;
            if (duckVideoVisible) {
                container.classList.remove('hidden');
            } else {
                container.classList.add('hidden');
            }
            savePositions();
            return duckVideoVisible;
        }

        // 切換鴨子計數顯示
        function toggleDuckCounterVisible() {
            const container = document.getElementById('duckCounterBox');
            if (!container) return;

            duckCounterVisible = !duckCounterVisible;
            if (duckCounterVisible) {
                // 先套用尺寸（在顯示之前）
                if (scalableBoxCache.duckCounterBox) {
                    const cached = scalableBoxCache.duckCounterBox;
                    container.style.width = cached.width + 'px';
                    container.style.height = cached.height + 'px';
                    container.style.left = cached.left + 'px';
                    container.style.top = cached.top + 'px';
                }
                // 先用 visibility:hidden 顯示（佔位但不可見）以便計算尺寸
                container.style.visibility = 'hidden';
                container.classList.remove('hidden');
                // 下一幀再套用縮放並顯示
                requestAnimationFrame(() => {
                    if (scalableBoxCache.duckCounterBox) {
                        const cached = scalableBoxCache.duckCounterBox;
                        applyScalableBoxScale(container, cached.width, cached.height);
                    }
                    container.style.visibility = 'visible';
                });
            } else {
                container.classList.add('hidden');
            }
            savePositions();
            return duckCounterVisible;
        }

        // 保底計數顯示
        let pityCounterVisible = false;

        // scalable-box 元素尺寸緩存（解決隱藏時無法讀取尺寸的問題）
        const scalableBoxCache = {
            pityCounterBox: { width: 180, height: 80, left: 50, top: 170 },
            duckCounterBox: { width: 200, height: 100, left: 50, top: 50 },
            leaderboardBox: { width: 320, height: 100, left: 50, top: 300 }
        };

        function updatePityCounter(data) {
            const counterValue = document.getElementById('pityCounterValue');
            const counterStage = document.getElementById('pityCounterStage');
            const counterBox = document.getElementById('pityCounterBox');

            if (!counterValue) return;

            const current = data.current || 0;
            const t1 = data.threshold || 1000;
            const t2 = data.thresholdJackpot || 2000;

            // 決定顯示哪一層
            if (current >= t1) {
                // 已過第一層，顯示終極保底進度
                counterValue.textContent = `${current} / ${t2}`;
                counterValue.classList.add('stage2');
                if (counterStage) counterStage.textContent = '🔥 衝刺終極保底！';
            } else {
                counterValue.textContent = `${current} / ${t1}`;
                counterValue.classList.remove('stage2');
                if (current >= t1 * 0.9) {
                    if (counterStage) counterStage.textContent = '即將觸發保底！';
                } else if (current >= t1 * 0.7) {
                    if (counterStage) counterStage.textContent = '接近保底中...';
                } else {
                    if (counterStage) counterStage.textContent = '';
                }
            }

            // 添加動畫效果
            counterValue.style.transform = 'scale(1.1)';
            setTimeout(() => {
                counterValue.style.transform = 'scale(1)';
            }, 200);
        }

        // 切換保底計數顯示
        function togglePityCounterVisible() {
            const container = document.getElementById('pityCounterBox');
            if (!container) return;

            pityCounterVisible = !pityCounterVisible;
            if (pityCounterVisible) {
                // 先套用尺寸（在顯示之前）
                if (scalableBoxCache.pityCounterBox) {
                    const cached = scalableBoxCache.pityCounterBox;
                    container.style.width = cached.width + 'px';
                    container.style.height = cached.height + 'px';
                    container.style.left = cached.left + 'px';
                    container.style.top = cached.top + 'px';
                }
                // 先用 visibility:hidden 顯示（佔位但不可見）以便計算尺寸
                container.style.visibility = 'hidden';
                container.classList.remove('hidden');
                // 下一幀再套用縮放並顯示
                requestAnimationFrame(() => {
                    if (scalableBoxCache.pityCounterBox) {
                        const cached = scalableBoxCache.pityCounterBox;
                        applyScalableBoxScale(container, cached.width, cached.height);
                    }
                    container.style.visibility = 'visible';
                });
            } else {
                container.classList.add('hidden');
            }
            savePositions();
            return pityCounterVisible;
        }

        // === 排行榜 ===
        let leaderboardVisible = false;
        let leaderboardData = { totalRanking: [], singleHighest: [] };

        // 切換排行榜顯示
        function toggleLeaderboardVisible() {
            const container = document.getElementById('leaderboardBox');
            if (!container) return;

            leaderboardVisible = !leaderboardVisible;
            if (leaderboardVisible) {
                // 先套用尺寸（在顯示之前）
                if (scalableBoxCache.leaderboardBox) {
                    const cached = scalableBoxCache.leaderboardBox;
                    container.style.width = cached.width + 'px';
                    container.style.height = cached.height + 'px';
                    container.style.left = cached.left + 'px';
                    container.style.top = cached.top + 'px';
                }
                // 先用 visibility:hidden 顯示（佔位但不可見）以便計算尺寸
                container.style.visibility = 'hidden';
                container.classList.remove('hidden');
                // 下一幀再套用縮放並顯示
                requestAnimationFrame(() => {
                    if (scalableBoxCache.leaderboardBox) {
                        const cached = scalableBoxCache.leaderboardBox;
                        applyScalableBoxScale(container, cached.width, cached.height);
                    }
                    container.style.visibility = 'visible';
                });
            } else {
                container.classList.add('hidden');
            }
            savePositions();
            return leaderboardVisible;
        }

        // 更新排行榜
        let lastLeaderboardState = { totalDucks: 0, singleAmount: 0, totalUser: '', singleUser: '' };

        function updateLeaderboard(data) {
            if (!data) return;
            leaderboardData = data;

            // 渲染排行榜（累計第一名 + 單次最高）
            const simpleList = document.getElementById('gsLeaderboardSimple');
            if (simpleList) {
                const totalItem = data.totalRanking && data.totalRanking.length > 0 ? data.totalRanking[0] : null;
                const singleItem = data.singleHighest && data.singleHighest.length > 0 ? data.singleHighest[0] : null;

                // 檢查是否有變化
                const newTotalDucks = totalItem ? totalItem.totalDucks : 0;
                const newSingleAmount = singleItem ? singleItem.amount : 0;
                const newTotalUser = totalItem ? (totalItem.uniqueId || totalItem.nickname) : '';
                const newSingleUser = singleItem ? (singleItem.uniqueId || singleItem.nickname) : '';

                const totalChanged = newTotalDucks !== lastLeaderboardState.totalDucks || newTotalUser !== lastLeaderboardState.totalUser;
                const singleChanged = newSingleAmount !== lastLeaderboardState.singleAmount || newSingleUser !== lastLeaderboardState.singleUser;

                // 更新狀態
                lastLeaderboardState = { totalDucks: newTotalDucks, singleAmount: newSingleAmount, totalUser: newTotalUser, singleUser: newSingleUser };

                simpleList.innerHTML = `
                    <div class="lb-row${totalChanged ? ' updating' : ''}">
                        <span class="lb-icon gold">👑</span>
                        ${totalItem && totalItem.avatar
                            ? `<img class="lb-avatar-mini gold-border" src="${totalItem.avatar}" onerror="this.outerHTML='<div class=\\'lb-avatar-mini gold-border placeholder\\'>🦆</div>'">`
                            : '<div class="lb-avatar-mini gold-border placeholder">🦆</div>'
                        }
                        <span class="lb-name">${totalItem ? escapeHtmlGs(totalItem.nickname || totalItem.name) : '---'}</span>
                        <span class="lb-value gold">${totalItem ? totalItem.totalDucks.toLocaleString() : 0}🦆</span>
                    </div>
                    <div class="lb-row${singleChanged ? ' updating' : ''}">
                        <span class="lb-icon purple">⭐</span>
                        ${singleItem && singleItem.avatar
                            ? `<img class="lb-avatar-mini purple-border" src="${singleItem.avatar}" onerror="this.outerHTML='<div class=\\'lb-avatar-mini purple-border placeholder\\'>🦆</div>'">`
                            : '<div class="lb-avatar-mini purple-border placeholder">🦆</div>'
                        }
                        <span class="lb-name">${singleItem ? escapeHtmlGs(singleItem.nickname || singleItem.name) : '---'}</span>
                        <span class="lb-value purple">${singleItem ? singleItem.amount.toLocaleString() : 0}🦆</span>
                    </div>
                `;
            }
        }

        // HTML 轉義
        function escapeHtmlGs(text) {
            const div = document.createElement('div');
            div.textContent = text || '';
            return div.innerHTML;
        }

        // === 里程碑慶祝 ===
        let milestoneTimeout = null;

        async function triggerMilestoneCelebration(data) {
            console.log('[里程碑] 觸發慶祝:', data);

            const overlay = document.getElementById('milestoneOverlay');
            const video = document.getElementById('milestoneVideo');
            const badge = document.getElementById('milestoneBadge');
            const avatar = document.getElementById('milestoneAvatar');
            const name = document.getElementById('milestoneName');
            const amount = document.getElementById('milestoneAmount');

            if (!overlay || !video) return;

            // 清除之前的計時器
            if (milestoneTimeout) {
                clearTimeout(milestoneTimeout);
                milestoneTimeout = null;
            }

            // 設定內容
            if (data.type === 'total') {
                badge.textContent = '🏆 累計第一';
            } else {
                badge.textContent = '🎯 單次最高';
            }

            name.textContent = data.nickname || '未知用戶';
            amount.textContent = (data.amount || 0).toLocaleString();

            // 設定頭像
            if (data.avatar) {
                avatar.src = data.avatar;
                avatar.classList.remove('placeholder');
                avatar.style.display = 'block';
                avatar.onerror = () => {
                    avatar.style.display = 'none';
                    // 創建一個佔位符
                    const placeholder = document.createElement('div');
                    placeholder.className = 'milestone-avatar placeholder';
                    placeholder.textContent = '🦆';
                    avatar.parentNode.insertBefore(placeholder, avatar);
                };
            } else {
                avatar.style.display = 'none';
                // 檢查是否已有佔位符
                const existingPlaceholder = overlay.querySelector('.milestone-avatar.placeholder');
                if (!existingPlaceholder) {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'milestone-avatar placeholder';
                    placeholder.textContent = '🦆';
                    avatar.parentNode.insertBefore(placeholder, avatar);
                }
            }

            // 設定影片
            if (data.videoPath) {
                try {
                    const mediaUrl = await pywebview.api.get_media_url(data.videoPath);
                    video.src = mediaUrl;
                    video.currentTime = 0;
                    video.play().catch(e => console.error('[里程碑] 影片播放失敗:', e));
                } catch (e) {
                    console.error('[里程碑] 獲取影片URL失敗:', e);
                }
            }

            // 顯示覆蓋層
            overlay.classList.add('active');

            // 影片結束或超時後隱藏（最多顯示 15 秒）
            const hideOverlay = () => {
                overlay.classList.remove('active');
                video.pause();
                video.src = '';
                // 移除可能的佔位符
                const placeholder = overlay.querySelector('.milestone-avatar.placeholder');
                if (placeholder) {
                    placeholder.remove();
                }
            };

            video.onended = hideOverlay;
            milestoneTimeout = setTimeout(hideOverlay, 15000);
        }

        // === 進場效果 ===
        let entryPlaying = false;

        function triggerEntry(data) {
            console.log('[ENTRY] 觸發進場效果:', data);

            // 決定使用哪個容器（縮圖容器或全屏容器）
            const useSmallContainer = entryVideoVisible && !data.is_audio;

            const fullContainer = document.getElementById('entryContainer');
            const fullVideo = document.getElementById('entryVideo');
            const audio = document.getElementById('entryAudio');

            const smallContainer = document.getElementById('entryVideoContainer');
            const smallPlayer = document.getElementById('entryPlayer');
            const smallAudio = document.getElementById('entryPlayerAudio');

            // 如果設定強制中斷，先停止所有其他影片
            if (data.force_interrupt) {
                console.log('[ENTRY] 強制中斷其他播放');
                // 停止所有影片容器
                document.querySelectorAll('.video-container').forEach(vc => {
                    const idx = vc.dataset.index;
                    if (idx !== undefined) {
                        stopVideoInContainer(parseInt(idx));
                    }
                });
            }

            // 準備影片路徑
            const videoSrc = formatVideoPath(data.path);

            if (data.is_audio) {
                // 音效模式 - 使用縮圖容器的 audio 或全屏容器的 audio
                const targetAudio = entryVideoVisible ? smallAudio : audio;
                if (!targetAudio) {
                    console.error('[ENTRY] 找不到音訊元素');
                    return;
                }
                targetAudio.src = videoSrc;
                targetAudio.volume = (data.volume || 100) / 100;
                targetAudio.onended = () => {
                    console.log('[ENTRY] 音效播放結束');
                    entryPlaying = false;
                };
                targetAudio.onerror = (e) => {
                    console.error('[ENTRY] 音效播放錯誤:', e);
                    entryPlaying = false;
                };
                targetAudio.play().catch(e => {
                    console.error('[ENTRY] 音效播放失敗:', e);
                });
                entryPlaying = true;
            } else if (useSmallContainer && smallContainer && smallPlayer) {
                // 影片模式 - 在縮圖容器中播放
                console.log('[ENTRY] 使用縮圖容器播放');
                smallPlayer.src = videoSrc;
                smallPlayer.volume = (data.volume || 100) / 100;
                smallPlayer.muted = false;

                smallPlayer.onloadedmetadata = () => {
                    console.log('[ENTRY] 影片已載入（縮圖容器）');
                };

                smallPlayer.onended = () => {
                    console.log('[ENTRY] 影片播放結束（縮圖容器）');
                    smallContainer.classList.remove('playing');
                    smallPlayer.src = '';
                    entryPlaying = false;
                };

                smallPlayer.onerror = (e) => {
                    console.error('[ENTRY] 影片播放錯誤（縮圖容器）:', e);
                    smallContainer.classList.remove('playing');
                    smallPlayer.src = '';
                    entryPlaying = false;
                };

                // 顯示容器並播放
                smallContainer.classList.add('playing');
                entryPlaying = true;

                smallPlayer.play().then(() => {
                    console.log('[ENTRY] 影片開始播放（縮圖容器）');
                }).catch(e => {
                    console.error('[ENTRY] 影片播放失敗（縮圖容器）:', e);
                    smallContainer.classList.remove('playing');
                    entryPlaying = false;
                });
            } else {
                // 影片模式 - 全屏顯示
                if (!fullContainer || !fullVideo) {
                    console.error('[ENTRY] 找不到全屏進場容器');
                    return;
                }
                fullVideo.src = videoSrc;
                fullVideo.volume = (data.volume || 100) / 100;
                fullVideo.muted = false;

                fullVideo.onloadedmetadata = () => {
                    console.log('[ENTRY] 影片已載入');
                };

                fullVideo.onended = () => {
                    console.log('[ENTRY] 影片播放結束');
                    fullContainer.classList.remove('active');
                    fullVideo.src = '';
                    entryPlaying = false;
                };

                fullVideo.onerror = (e) => {
                    console.error('[ENTRY] 影片播放錯誤:', e);
                    fullContainer.classList.remove('active');
                    fullVideo.src = '';
                    entryPlaying = false;
                };

                // 顯示容器並播放
                fullContainer.classList.add('active');
                entryPlaying = true;

                fullVideo.play().then(() => {
                    console.log('[ENTRY] 影片開始播放');
                }).catch(e => {
                    console.error('[ENTRY] 影片播放失敗:', e);
                    fullContainer.classList.remove('active');
                    entryPlaying = false;
                });
            }

            // 顯示進場文字
            if (data.show_text && data.text) {
                showEntryText(data);
            }
        }

        // 進場文字計時器
        let entryTextTimer = null;

        function showEntryText(data) {
            const textContainer = document.getElementById('entryTextContainer');
            const textElement = document.getElementById('entryText');

            if (!textContainer || !textElement) return;

            // 清除之前的計時器
            if (entryTextTimer) {
                clearTimeout(entryTextTimer);
                entryTextTimer = null;
            }

            // 替換 {name} 為用戶名
            const displayText = (data.text || '').replace(/\{name\}/g, data.username || '');

            // 設定文字樣式
            textElement.textContent = displayText;
            textElement.style.fontSize = (data.text_size || 48) + 'px';
            textElement.style.color = data.text_color || '#ffffff';
            textElement.classList.remove('fade-out');

            // 顯示容器
            textContainer.classList.remove('hidden');

            // 設定自動隱藏
            const duration = (data.text_duration || 5) * 1000;
            entryTextTimer = setTimeout(() => {
                hideEntryText();
            }, duration);

            console.log('[ENTRY] 顯示進場文字:', displayText);
        }

        function hideEntryText() {
            const textContainer = document.getElementById('entryTextContainer');
            const textElement = document.getElementById('entryText');

            if (!textElement) return;

            // 添加淡出動畫
            textElement.classList.add('fade-out');

            // 動畫結束後隱藏
            setTimeout(() => {
                if (textContainer) {
                    textContainer.classList.add('hidden');
                }
                textElement.classList.remove('fade-out');
            }, 500);
        }

        // 停止進場效果
        function stopEntry() {
            const container = document.getElementById('entryContainer');
            const video = document.getElementById('entryVideo');
            const audio = document.getElementById('entryAudio');

            if (video) {
                video.pause();
                video.src = '';
            }
            if (audio) {
                audio.pause();
                audio.src = '';
            }
            if (container) {
                container.classList.remove('active');
            }
            entryPlaying = false;
        }

        // === 拖曳功能 ===
        let dragState = { active: false, elem: null, offsetX: 0, offsetY: 0 };

        function initDraggable() {
            const draggables = document.querySelectorAll('.draggable');

            draggables.forEach(elem => {
                // 移除舊的監聽器（如果有的話）
                elem.removeEventListener('mousedown', handleDragStart);
                elem.addEventListener('mousedown', handleDragStart);
            });
        }

        function handleDragStart(e) {
            if (e.button !== 0) return;
            if (e.target.classList.contains('resize-handle')) return;

            const elem = e.currentTarget;

            // 取得元素位置（優先使用 style 值，避免隱藏時 offset 為 0）
            let elemLeft = elem.offsetLeft;
            let elemTop = elem.offsetTop;

            // 如果是 scalable-box 且有緩存，使用緩存值
            if (elem.classList.contains('scalable-box') && scalableBoxCache[elem.id]) {
                const cached = scalableBoxCache[elem.id];
                if (elemLeft <= 0 && cached.left > 0) elemLeft = cached.left;
                if (elemTop <= 0 && cached.top > 0) elemTop = cached.top;
            }

            // 如果還是 0，嘗試從 style 取得
            if (elemLeft <= 0) elemLeft = parseInt(elem.style.left) || 0;
            if (elemTop <= 0) elemTop = parseInt(elem.style.top) || 0;

            dragState.active = true;
            dragState.elem = elem;
            dragState.offsetX = e.clientX - elemLeft;
            dragState.offsetY = e.clientY - elemTop;
            elem.style.transform = 'none';
            e.preventDefault();
        }

        // 全域拖曳事件（只註冊一次）
        document.addEventListener('mousemove', (e) => {
            if (!dragState.active || !dragState.elem) return;
            dragState.elem.style.left = (e.clientX - dragState.offsetX) + 'px';
            dragState.elem.style.top = (e.clientY - dragState.offsetY) + 'px';
        });

        document.addEventListener('mouseup', () => {
            if (dragState.active) {
                const elem = dragState.elem;

                // 更新 scalable-box 緩存的位置
                if (elem && elem.classList.contains('scalable-box') && scalableBoxCache[elem.id]) {
                    scalableBoxCache[elem.id].left = parseInt(elem.style.left) || 0;
                    scalableBoxCache[elem.id].top = parseInt(elem.style.top) || 0;
                    console.log(`[ScalableBox] 拖動後緩存更新: ${elem.id}`, scalableBoxCache[elem.id]);
                }

                dragState.active = false;
                dragState.elem = null;
                savePositionsDebounced();
            }
        });

        // === 縮放功能（8個方向） ===
        let resizeState = {
            active: false,
            elem: null,
            direction: '',
            startX: 0, startY: 0,
            startWidth: 0, startHeight: 0,
            startLeft: 0, startTop: 0,
            // 裁切用
            videoIndex: -1,
            startCropLeft: 0,
            startCropTop: 0,
            originalWidth: 0,
            originalHeight: 0
        };

        function initResizable() {
            const draggables = document.querySelectorAll('.draggable');

            draggables.forEach(elem => {
                const handles = elem.querySelectorAll('.resize-handle');

                handles.forEach(handle => {
                    // 移除舊的監聽器
                    handle.removeEventListener('mousedown', handleResizeStart);
                    handle.addEventListener('mousedown', handleResizeStart);
                });
            });
        }

        function handleResizeStart(e) {
            e.stopPropagation();
            e.preventDefault();

            const handle = e.currentTarget;
            const elem = handle.parentElement;

            // 取得方向
            let direction = '';
            const classes = handle.className.split(' ');
            for (const c of classes) {
                if (['nw', 'n', 'ne', 'w', 'e', 'sw', 's', 'se'].includes(c)) {
                    direction = c;
                    break;
                }
            }

            resizeState.active = true;
            resizeState.elem = elem;
            resizeState.direction = direction;
            resizeState.startX = e.clientX;
            resizeState.startY = e.clientY;

            // 取得元素尺寸（優先使用 style 值，避免隱藏時 offset 為 0）
            let startWidth = elem.offsetWidth;
            let startHeight = elem.offsetHeight;
            let startLeft = elem.offsetLeft;
            let startTop = elem.offsetTop;

            // 如果是 scalable-box 且有緩存，使用緩存值
            if (elem.classList.contains('scalable-box') && scalableBoxCache[elem.id]) {
                const cached = scalableBoxCache[elem.id];
                if (startWidth <= 0) startWidth = cached.width;
                if (startHeight <= 0) startHeight = cached.height;
                if (startLeft <= 0 && cached.left > 0) startLeft = cached.left;
                if (startTop <= 0 && cached.top > 0) startTop = cached.top;
            }

            // 如果還是 0，嘗試從 style 取得
            if (startWidth <= 0) startWidth = parseInt(elem.style.width) || 100;
            if (startHeight <= 0) startHeight = parseInt(elem.style.height) || 100;
            if (startLeft <= 0) startLeft = parseInt(elem.style.left) || 0;
            if (startTop <= 0) startTop = parseInt(elem.style.top) || 0;

            resizeState.startWidth = startWidth;
            resizeState.startHeight = startHeight;
            resizeState.startLeft = startLeft;
            resizeState.startTop = startTop;
            elem.style.transform = 'none';

            // 縮放框：儲存內容的實際尺寸
            if (elem.classList.contains('scalable-box')) {
                const content = elem.querySelector('.scalable-content');
                if (content) {
                    // 暫時重置 transform 以取得真實尺寸
                    content.style.transform = 'translate(-50%, -50%)';
                    let contentW = content.offsetWidth;
                    let contentH = content.offsetHeight;

                    // 如果內容尺寸為 0，使用基礎尺寸
                    if (contentW <= 0) contentW = parseInt(elem.dataset.baseWidth) || 200;
                    if (contentH <= 0) contentH = parseInt(elem.dataset.baseHeight) || 100;

                    resizeState.contentWidth = contentW;
                    resizeState.contentHeight = contentH;
                }
            }

            // 禮物圖：儲存內容的實際尺寸
            if (elem.id === 'giftImageDisplay') {
                const wrapper = elem.querySelector('.gift-image-wrapper');
                const content = elem.querySelector('.gift-image-content');
                if (wrapper && content) {
                    // 暫時重置 transform 以取得真實尺寸
                    const prevTransform = wrapper.style.transform;
                    wrapper.style.transform = 'none';
                    // 使用 content 的尺寸（因為 wrapper 是 inline-block 會自動調整）
                    resizeState.giftImageOrigWidth = content.offsetWidth || content.scrollWidth || 300;
                    resizeState.giftImageOrigHeight = content.offsetHeight || content.scrollHeight || 200;
                    wrapper.style.transform = prevTransform;
                }
            }

            // 影片容器的裁切狀態
            if (elem.classList.contains('video-container')) {
                const idx = parseInt(elem.dataset.index);
                resizeState.videoIndex = idx;

                // 初始化裁切狀態
                if (!videoCropState[idx]) {
                    videoCropState[idx] = {
                        cropLeft: 0,
                        cropTop: 0,
                        originalWidth: elem.offsetWidth,
                        originalHeight: elem.offsetHeight
                    };
                }

                resizeState.startCropLeft = videoCropState[idx].cropLeft;
                resizeState.startCropTop = videoCropState[idx].cropTop;
                resizeState.originalWidth = videoCropState[idx].originalWidth;
                resizeState.originalHeight = videoCropState[idx].originalHeight;
            } else {
                resizeState.videoIndex = -1;
            }
        }

        // 全域縮放事件（只註冊一次）
        document.addEventListener('mousemove', (e) => {
            if (!resizeState.active || !resizeState.elem) return;

            const deltaX = e.clientX - resizeState.startX;
            const deltaY = e.clientY - resizeState.startY;
            const direction = resizeState.direction;
            const elem = resizeState.elem;

            let newWidth = resizeState.startWidth;
            let newHeight = resizeState.startHeight;
            let newLeft = resizeState.startLeft;
            let newTop = resizeState.startTop;

            const isVideoContainer = elem.classList.contains('video-container');
            const isSingleSide = ['w', 'e', 'n', 's'].includes(direction);

            if (isVideoContainer && isSingleSide) {
                // 影片容器的單邊調整 = 裁切模式
                const idx = resizeState.videoIndex;
                const cropState = videoCropState[idx];
                const thumbnail = elem.querySelector('.thumbnail-video');
                const player = elem.querySelector('.video-player');

                if (direction === 'e') {
                    // 右邊裁切
                    newWidth = Math.max(50, resizeState.startWidth + deltaX);
                    newWidth = Math.min(newWidth, resizeState.originalWidth - cropState.cropLeft);
                }
                if (direction === 'w') {
                    // 左邊裁切
                    const newCropLeft = Math.max(0, Math.min(resizeState.startCropLeft + deltaX, resizeState.originalWidth - 50));
                    cropState.cropLeft = newCropLeft;
                    newWidth = Math.max(50, resizeState.startWidth - deltaX);
                    newWidth = Math.min(newWidth, resizeState.originalWidth - newCropLeft);
                    newLeft = resizeState.startLeft + deltaX;

                    if (thumbnail) thumbnail.style.left = -newCropLeft + 'px';
                    if (player) player.style.left = -newCropLeft + 'px';
                }
                if (direction === 's') {
                    // 下邊裁切
                    newHeight = Math.max(50, resizeState.startHeight + deltaY);
                    newHeight = Math.min(newHeight, resizeState.originalHeight - cropState.cropTop);
                }
                if (direction === 'n') {
                    // 上邊裁切
                    const newCropTop = Math.max(0, Math.min(resizeState.startCropTop + deltaY, resizeState.originalHeight - 50));
                    cropState.cropTop = newCropTop;
                    newHeight = Math.max(50, resizeState.startHeight - deltaY);
                    newHeight = Math.min(newHeight, resizeState.originalHeight - newCropTop);
                    newTop = resizeState.startTop + deltaY;

                    if (thumbnail) thumbnail.style.top = -newCropTop + 'px';
                    if (player) player.style.top = -newCropTop + 'px';
                }
            } else {
                // 一般縮放模式
                const isCorner = ['nw', 'ne', 'sw', 'se'].includes(direction);

                if (isCorner) {
                    // 四個角落：等比例縮放
                    const aspectRatio = resizeState.startWidth / resizeState.startHeight;

                    // 根據滑鼠移動方向決定縮放基準
                    let scale;
                    if (direction === 'se') {
                        // 右下角：取較大的縮放值
                        const scaleX = (resizeState.startWidth + deltaX) / resizeState.startWidth;
                        const scaleY = (resizeState.startHeight + deltaY) / resizeState.startHeight;
                        scale = Math.max(scaleX, scaleY);
                        newWidth = Math.max(50, resizeState.startWidth * scale);
                        newHeight = Math.max(50, newWidth / aspectRatio);
                    } else if (direction === 'sw') {
                        // 左下角
                        const scaleX = (resizeState.startWidth - deltaX) / resizeState.startWidth;
                        const scaleY = (resizeState.startHeight + deltaY) / resizeState.startHeight;
                        scale = Math.max(scaleX, scaleY);
                        newWidth = Math.max(50, resizeState.startWidth * scale);
                        newHeight = Math.max(50, newWidth / aspectRatio);
                        newLeft = resizeState.startLeft + resizeState.startWidth - newWidth;
                    } else if (direction === 'ne') {
                        // 右上角
                        const scaleX = (resizeState.startWidth + deltaX) / resizeState.startWidth;
                        const scaleY = (resizeState.startHeight - deltaY) / resizeState.startHeight;
                        scale = Math.max(scaleX, scaleY);
                        newWidth = Math.max(50, resizeState.startWidth * scale);
                        newHeight = Math.max(50, newWidth / aspectRatio);
                        newTop = resizeState.startTop + resizeState.startHeight - newHeight;
                    } else if (direction === 'nw') {
                        // 左上角
                        const scaleX = (resizeState.startWidth - deltaX) / resizeState.startWidth;
                        const scaleY = (resizeState.startHeight - deltaY) / resizeState.startHeight;
                        scale = Math.max(scaleX, scaleY);
                        newWidth = Math.max(50, resizeState.startWidth * scale);
                        newHeight = Math.max(50, newWidth / aspectRatio);
                        newLeft = resizeState.startLeft + resizeState.startWidth - newWidth;
                        newTop = resizeState.startTop + resizeState.startHeight - newHeight;
                    }
                } else {
                    // 四個邊：單向縮放
                    if (direction === 'e') {
                        newWidth = Math.max(50, resizeState.startWidth + deltaX);
                    }
                    if (direction === 'w') {
                        newWidth = Math.max(50, resizeState.startWidth - deltaX);
                        newLeft = resizeState.startLeft + deltaX;
                        if (newWidth <= 50) newLeft = resizeState.startLeft + resizeState.startWidth - 50;
                    }
                    if (direction === 's') {
                        newHeight = Math.max(50, resizeState.startHeight + deltaY);
                    }
                    if (direction === 'n') {
                        newHeight = Math.max(50, resizeState.startHeight - deltaY);
                        newTop = resizeState.startTop + deltaY;
                        if (newHeight <= 50) newTop = resizeState.startTop + resizeState.startHeight - 50;
                    }
                }

                // 影片容器角落調整時，更新原始尺寸並重置裁切
                if (isVideoContainer) {
                    const idx = resizeState.videoIndex;
                    videoCropState[idx] = {
                        cropLeft: 0,
                        cropTop: 0,
                        originalWidth: newWidth,
                        originalHeight: newHeight
                    };

                    const thumbnail = elem.querySelector('.thumbnail-video');
                    const player = elem.querySelector('.video-player');
                    if (thumbnail) {
                        thumbnail.style.left = '0px';
                        thumbnail.style.top = '0px';
                        thumbnail.style.width = newWidth + 'px';
                        thumbnail.style.height = newHeight + 'px';
                    }
                    if (player) {
                        player.style.left = '0px';
                        player.style.top = '0px';
                        player.style.width = newWidth + 'px';
                        player.style.height = newHeight + 'px';
                    }
                }
            }

            // 轉盤保持正方形
            if (elem.id === 'wheelContainer') {
                const size = Math.max(newWidth, newHeight);
                newWidth = size;
                newHeight = size;
            }

            elem.style.width = newWidth + 'px';
            elem.style.height = newHeight + 'px';
            elem.style.left = newLeft + 'px';
            elem.style.top = newTop + 'px';

            // 更新轉盤 canvas
            if (elem.id === 'wheelContainer') {
                const canvas = document.getElementById('wheelCanvas');
                canvas.width = newWidth;
                canvas.height = newHeight;
                drawWheel();
            }

            // 縮放內容（鴨子計數、保底計數等）
            if (elem.classList.contains('scalable-box')) {
                const content = elem.querySelector('.scalable-content');
                const contentWidth = resizeState.contentWidth || 200;
                const contentHeight = resizeState.contentHeight || 100;

                if (content) {
                    // 計算縮放比例（取較小值確保完整顯示）
                    const scaleX = newWidth / contentWidth;
                    const scaleY = newHeight / contentHeight;
                    const scale = Math.min(scaleX, scaleY);
                    // 置中 + 縮放
                    content.style.transform = `translate(-50%, -50%) scale(${scale})`;
                }

                // 更新緩存
                if (scalableBoxCache[elem.id]) {
                    scalableBoxCache[elem.id] = {
                        width: newWidth,
                        height: newHeight,
                        left: newLeft,
                        top: newTop
                    };
                    console.log(`[ScalableBox] 緩存更新: ${elem.id}`, scalableBoxCache[elem.id]);
                }
            }

            // 禮物圖縮放內容
            if (elem.id === 'giftImageDisplay') {
                const wrapper = elem.querySelector('.gift-image-wrapper');
                if (wrapper) {
                    // 取得內容原始尺寸（儲存在 resizeState 或使用當前尺寸）
                    const origW = resizeState.giftImageOrigWidth || 300;
                    const origH = resizeState.giftImageOrigHeight || 200;
                    // 計算縮放比例
                    const scaleX = newWidth / origW;
                    const scaleY = newHeight / origH;
                    const scale = Math.min(scaleX, scaleY);
                    wrapper.style.transform = `scale(${scale})`;
                    // 儲存當前縮放比例到容器的 dataset
                    elem.dataset.currentScale = scale;
                }
            }
        });

        document.addEventListener('mouseup', () => {
            if (resizeState.active) {
                resizeState.active = false;
                resizeState.elem = null;
                savePositionsDebounced();
            }
        });

        // === 右鍵選單 ===
        let currentContextElement = null;  // 當前右鍵點擊的元素
        let baseZIndex = 10;  // 基礎 z-index
        let elementZIndexes = {};  // 儲存各元素的 z-index

        function initContextMenu() {
            const menu = document.getElementById('contextMenu');
            const elementMenu = document.getElementById('elementContextMenu');

            document.addEventListener('contextmenu', (e) => {
                e.preventDefault();

                // 隱藏所有選單
                menu.classList.remove('visible');
                elementMenu.classList.remove('visible');

                // 檢查是否點擊了可調整圖層的元素
                const draggable = e.target.closest('.draggable');

                if (draggable) {
                    // 元素右鍵選單
                    currentContextElement = draggable;
                    const title = getElementTitle(draggable);
                    document.getElementById('elementMenuTitle').textContent = title;
                    elementMenu.style.left = e.clientX + 'px';
                    elementMenu.style.top = e.clientY + 'px';
                    elementMenu.classList.add('visible');
                } else {
                    // 一般右鍵選單
                    menu.style.left = e.clientX + 'px';
                    menu.style.top = e.clientY + 'px';
                    menu.classList.add('visible');
                }
            });

            document.addEventListener('click', () => {
                menu.classList.remove('visible');
                elementMenu.classList.remove('visible');
            });
        }

        // 套用儲存的圖層順序
        function applyElementZIndexes() {
            if (!savedPositions || !savedPositions.elementZIndexes) {
                console.log('[圖層] 無儲存的圖層順序');
                return;
            }

            // 恢復 elementZIndexes 資料
            elementZIndexes = { ...savedPositions.elementZIndexes };

            // 套用到所有元素
            getAllDraggables().forEach(elem => {
                const key = elem.id || elem.dataset.index;
                if (elementZIndexes[key]) {
                    elem.style.zIndex = elementZIndexes[key];
                }
            });

            console.log('[圖層] 已套用儲存的圖層順序:', Object.keys(elementZIndexes).length, '個元素');
        }

        function getElementTitle(elem) {
            if (elem.id === 'wheelContainer') return '🎡 轉盤';
            if (elem.id === 'giftboxContainer') return '🎁 盲盒';
            if (elem.id === 'entryTextContainer') return '👋 進場文字';
            if (elem.id === 'entryVideoContainer') return '🎬 進場影片';
            if (elem.id === 'randomVideoContainer') return '🎲 隨機影片';
            if (elem.id === 'duckVideoContainer') return '🦆 抓鴨影片';
            if (elem.id === 'duckCounterContainer') return '🔢 鴨子計數';
            if (elem.id === 'pityCounterContainer') return '🎰 保底計數';
            if (elem.id === 'leaderboardContainer') return '🏆 排行榜';
            if (elem.classList.contains('video-container')) {
                const idx = elem.dataset.index;
                const gift = videoGifts[idx];
                return `🎬 ${gift?.display_name || gift?.name || '影片 ' + idx}`;
            }
            return '元素';
        }

        function getAllDraggables() {
            return Array.from(document.querySelectorAll('.draggable'));
        }

        function getElementZIndex(elem) {
            const key = elem.id || elem.dataset.index;
            return elementZIndexes[key] || parseInt(elem.style.zIndex) || baseZIndex;
        }

        function setElementZIndex(elem, zIndex) {
            const key = elem.id || elem.dataset.index;
            elementZIndexes[key] = zIndex;
            elem.style.zIndex = zIndex;
            savePositions();
        }

        function moveLayerToTop() {
            if (!currentContextElement) return;
            const maxZ = Math.max(...getAllDraggables().map(el => getElementZIndex(el)));
            setElementZIndex(currentContextElement, maxZ + 1);
        }

        function moveLayerUp() {
            if (!currentContextElement) return;
            const currentZ = getElementZIndex(currentContextElement);
            setElementZIndex(currentContextElement, currentZ + 1);
        }

        function moveLayerDown() {
            if (!currentContextElement) return;
            const currentZ = getElementZIndex(currentContextElement);
            setElementZIndex(currentContextElement, Math.max(1, currentZ - 1));
        }

        function moveLayerToBottom() {
            if (!currentContextElement) return;
            const minZ = Math.min(...getAllDraggables().map(el => getElementZIndex(el)));
            setElementZIndex(currentContextElement, Math.max(1, minZ - 1));
        }

        function hideCurrentElement() {
            if (!currentContextElement) return;

            // 根據元素類型調用對應的隱藏函數
            if (currentContextElement.id === 'wheelContainer') {
                if (wheelVisible) toggleWheelVisibility();
            } else if (currentContextElement.id === 'giftboxContainer') {
                if (giftboxVisible) toggleGiftboxVisibility();
            } else if (currentContextElement.id === 'entryVideoContainer') {
                if (entryVideoVisible) toggleEntryVideoVisibility();
            } else if (currentContextElement.classList.contains('video-container')) {
                const idx = parseInt(currentContextElement.dataset.index);
                if (videoGifts[idx]?.visible !== false) {
                    toggleVideoGiftVisible(idx);
                }
            } else {
                // 直接隱藏
                setElementVisible(currentContextElement, false);
            }
        }

        // ========== 鎖鏈對抗模組 ==========
        let chainBattleActive = false;
        let chainCount = 0;
        let chainBaseCount = 20;  // 基礎鎖鏈數

        // 啟動鎖鏈對抗
        // 標記是否為鎖定視窗模式
        let isLockWindowMode = false;

        // 阻擋所有滑鼠事件
        function blockEvent(e) {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }

        // 阻擋除了空白鍵以外的按鍵
        function blockNonSpaceKey(e) {
            if (e.code !== 'Space') {
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }

        // 播放鎖鏈音效
        function playChainSound(type) {
            const soundIds = {
                lock: 'chainSoundLock',
                rattle: 'chainSoundRattle',
                victory: 'chainSoundVictory'
            };
            const sound = document.getElementById(soundIds[type]);
            if (sound) {
                sound.currentTime = 0;
                sound.play().catch(() => {});
            }
        }

        function startChainBattle(data = {}) {
            const overlay = document.getElementById('chainBattleOverlay');
            const counter = document.getElementById('chainCounter');

            // 如果已經在進行中，增加鎖鏈數
            if (chainBattleActive) {
                addChainCount(data.amount || chainBaseCount);
                return;
            }

            // 檢查是否為鎖定視窗模式
            if (data.isLockWindow) {
                isLockWindowMode = true;
                // 鎖定視窗模式：隱藏所有其他元素，顯示深色背景
                document.body.style.background = 'rgba(0, 0, 0, 0.95)';
                document.body.style.cursor = 'none';  // 隱藏游標

                // 隱藏所有元素（除了鎖鏈對抗）
                document.querySelectorAll('.draggable, .gift-image-display, #debugPanel').forEach(el => {
                    el.style.display = 'none';
                });

                // 禁用所有滑鼠事件
                document.addEventListener('mousedown', blockEvent, true);
                document.addEventListener('mouseup', blockEvent, true);
                document.addEventListener('click', blockEvent, true);
                document.addEventListener('dblclick', blockEvent, true);
                document.addEventListener('contextmenu', blockEvent, true);
                document.addEventListener('wheel', blockEvent, true);

                // 禁用除了空白鍵以外的所有按鍵
                document.addEventListener('keydown', blockNonSpaceKey, true);
                document.addEventListener('keyup', blockNonSpaceKey, true);
            }

            // 設定基礎數值
            chainBaseCount = data.baseCount || 20;
            chainCount = data.amount || chainBaseCount;

            // 更新顯示
            counter.textContent = chainCount;
            counter.classList.remove('adding', 'removing');

            // 顯示鎖鏈並鎖定畫面
            overlay.classList.remove('breaking', 'victory');
            overlay.classList.add('active');
            document.body.classList.add('chain-locked');
            chainBattleActive = true;

            // 播放鎖起來音效
            playChainSound('lock');

            console.log(`[鎖鏈對抗] 啟動！鎖鏈數: ${chainCount}${isLockWindowMode ? ' (鎖定視窗)' : ''}`);
        }

        // 增加鎖鏈數（觀眾送禮）
        function addChainCount(amount = 1) {
            if (!chainBattleActive) return;

            chainCount += amount;
            const counter = document.getElementById('chainCounter');
            counter.textContent = chainCount;

            // 播放增加動畫
            counter.classList.remove('removing');
            counter.classList.add('adding');
            setTimeout(() => counter.classList.remove('adding'), 300);

            console.log(`[鎖鏈對抗] +${amount}，目前: ${chainCount}`);
        }

        // 創建鎖鏈飄動數字
        function createChainFloatingNumber(amount, isAdd) {
            const container = document.getElementById('chainFloatingNumbers');
            if (!container) return;

            const num = document.createElement('div');
            num.className = `chain-floating-number ${isAdd ? 'add' : 'remove'}`;
            num.textContent = isAdd ? `+${amount}` : `-${amount}`;

            // 隨機位置（在計數器周圍）
            const centerX = window.innerWidth / 2;
            const centerY = window.innerHeight / 2;
            const offsetX = (Math.random() - 0.5) * 200;  // -100 到 +100
            const offsetY = (Math.random() - 0.5) * 100;  // -50 到 +50

            num.style.left = `${centerX + offsetX}px`;
            num.style.top = `${centerY + offsetY + 50}px`;  // 稍微偏下

            container.appendChild(num);

            // 動畫結束後移除元素
            setTimeout(() => {
                num.remove();
            }, 1500);
        }

        // 同步鎖鏈數（從主進程廣播）
        function syncChainCount(data) {
            if (!chainBattleActive) return;

            chainCount = data.count;
            const counter = document.getElementById('chainCounter');
            counter.textContent = chainCount;

            // 根據動作播放動畫
            if (data.action === 'add') {
                counter.classList.remove('removing');
                counter.classList.add('adding');
                setTimeout(() => counter.classList.remove('adding'), 300);
                // 顯示飄動數字
                if (data.amount) {
                    createChainFloatingNumber(data.amount, true);
                }
                console.log(`[鎖鏈對抗] +${data.amount}，目前: ${chainCount}`);
            } else if (data.action === 'remove') {
                counter.classList.remove('adding');
                counter.classList.add('removing');
                setTimeout(() => counter.classList.remove('removing'), 100);
                // 顯示飄動數字
                if (data.amount) {
                    createChainFloatingNumber(data.amount, false);
                }
                console.log(`[鎖鏈對抗] -${data.amount}，目前: ${chainCount}`);
            }
        }

        // 主播掙脫成功（由主進程觸發）
        function chainVictory() {
            if (!chainBattleActive) return;

            const overlay = document.getElementById('chainBattleOverlay');

            // 播放掙脫動畫和音效
            overlay.classList.add('breaking');
            playChainSound('victory');

            setTimeout(() => {
                overlay.classList.remove('breaking');
                overlay.classList.add('victory');

                // 2秒後關閉
                setTimeout(() => {
                    overlay.classList.remove('active', 'victory');
                    document.body.classList.remove('chain-locked');
                    chainBattleActive = false;
                    console.log('[鎖鏈對抗] 主播掙脫成功！');
                    // 通知主進程（只有非鎖定視窗才通知，避免重複）
                    if (!isLockWindowMode && window.pywebview && window.pywebview.api) {
                        pywebview.api.chain_battle_ended(true);
                    }
                }, 2000);
            }, 500);
        }

        // 強制結束鎖鏈對抗
        function stopChainBattle() {
            const overlay = document.getElementById('chainBattleOverlay');
            overlay.classList.remove('active', 'breaking', 'victory');
            document.body.classList.remove('chain-locked');
            chainBattleActive = false;
            chainCount = 0;
            console.log('[鎖鏈對抗] 已強制結束');
        }

        // 播放鎖鏈影片（左/中/右）
        function playChainVideo(data) {
            // side 為 'left'、'right' 或 null/undefined（固定位置用中間）
            const side = data.side || 'center';
            const containerMap = {
                left: 'chainVideoLeft',
                center: 'chainVideoCenter',
                right: 'chainVideoRight'
            };
            const playerMap = {
                left: 'chainVideoPlayerLeft',
                center: 'chainVideoPlayerCenter',
                right: 'chainVideoPlayerRight'
            };
            const containerId = containerMap[side];
            const playerId = playerMap[side];

            const container = document.getElementById(containerId);
            const player = document.getElementById(playerId);

            if (!container || !player) {
                console.error('[鎖鏈影片] 找不到容器:', containerId);
                return;
            }

            const videoPath = formatVideoPath(data.videoPath);
            const speed = data.speed || 1.0;
            const volume = (data.volume ?? 100) / 100;
            const seconds = data.seconds || 0;

            console.log(`[鎖鏈影片] 播放 (${side}):`, videoPath);

            // 設定影片
            player.src = videoPath;
            player.playbackRate = speed;
            player.volume = volume;
            player.muted = volume === 0;

            // 顯示容器
            container.classList.add('active');

            // 播放影片
            player.onloadedmetadata = () => {
                const duration = seconds > 0 ? Math.min(seconds, player.duration) : player.duration;

                player.play().catch(e => {
                    console.error('[鎖鏈影片] 播放失敗:', e);
                });

                // 設定結束時間
                if (seconds > 0) {
                    setTimeout(() => {
                        player.pause();
                        container.classList.remove('active');
                    }, duration * 1000 / speed);
                }
            };

            player.onended = () => {
                container.classList.remove('active');
            };

            player.onerror = (e) => {
                console.error('[鎖鏈影片] 載入錯誤:', e);
                container.classList.remove('active');
            };
        }

        // 監聽空白鍵（長按無效，必須一下一下按）
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && chainBattleActive) {
                e.preventDefault();  // 防止頁面滾動
                // e.repeat 為 true 表示長按重複觸發，忽略它
                if (!e.repeat) {
                    // 播放鎖鏈音效
                    playChainSound('rattle');
                    // 通知主進程減少計數（主進程會同步到所有視窗）
                    if (window.pywebview && window.pywebview.api) {
                        pywebview.api.remove_chain_count(1);
                    }
                }
            }
        });

        // 暴露給外部的函數
        window.triggerWheel = triggerWheel;
        window.triggerVideo = triggerVideo;
        window.triggerVideoInContainer = triggerVideoInContainer;
        window.playRandomVideo = playRandomVideo;
        window.stopRandomVideo = stopRandomVideo;
        window.toggleRandomVideoVisible = toggleRandomVideoVisible;
        window.playDuckVideo = playDuckVideo;
        window.finishDuckVideo = finishDuckVideo;
        window.updateDuckCounter = updateDuckCounter;
        window.toggleDuckVideoVisible = toggleDuckVideoVisible;
        window.toggleDuckCounterVisible = toggleDuckCounterVisible;
        window.updatePityCounter = updatePityCounter;
        window.triggerMilestoneCelebration = triggerMilestoneCelebration;
        window.togglePityCounterVisible = togglePityCounterVisible;
        window.startChainBattle = startChainBattle;
        window.addChainCount = addChainCount;
        window.syncChainCount = syncChainCount;
        window.chainVictory = chainVictory;
        window.stopChainBattle = stopChainBattle;
        window.playChainVideo = playChainVideo;
    </script>
</body>
</html>
