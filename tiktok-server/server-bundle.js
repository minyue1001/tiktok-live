var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/tiktok-live-connector/dist/types/errors.js
var require_errors = __commonJS({
  "node_modules/tiktok-live-connector/dist/types/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AuthenticatedWebSocketConnectionError = exports2.PremiumFeatureError = exports2.SignatureMissingTokensError = exports2.SignatureRateLimitError = exports2.SignAPIError = exports2.FetchSignedWebSocketIdentityParameterError = exports2.ErrorReason = exports2.TikTokLiveError = exports2.SchemaDecodeError = exports2.InvalidSchemaNameError = exports2.UserOfflineError = exports2.AlreadyConnectedError = exports2.AlreadyConnectingError = exports2.MissingRoomIdError = exports2.InvalidResponseError = exports2.FetchIsLiveError = exports2.InvalidUniqueIdError = void 0;
    var ConnectError = class extends Error {
      constructor(message) {
        super(message);
      }
    };
    var InvalidUniqueIdError = class extends Error {
    };
    exports2.InvalidUniqueIdError = InvalidUniqueIdError;
    var FetchIsLiveError = class extends Error {
      errors;
      constructor(errors, ...args) {
        super();
        this.errors = errors;
      }
    };
    exports2.FetchIsLiveError = FetchIsLiveError;
    var InvalidResponseError = class extends Error {
      requestErr;
      constructor(message, requestErr = void 0) {
        super(message);
        this.requestErr = requestErr;
        this.name = "InvalidResponseError";
      }
    };
    exports2.InvalidResponseError = InvalidResponseError;
    var MissingRoomIdError = class extends Error {
    };
    exports2.MissingRoomIdError = MissingRoomIdError;
    var AlreadyConnectingError = class extends ConnectError {
    };
    exports2.AlreadyConnectingError = AlreadyConnectingError;
    var AlreadyConnectedError = class extends ConnectError {
    };
    exports2.AlreadyConnectedError = AlreadyConnectedError;
    var UserOfflineError = class extends ConnectError {
    };
    exports2.UserOfflineError = UserOfflineError;
    var InvalidSchemaNameError = class extends Error {
    };
    exports2.InvalidSchemaNameError = InvalidSchemaNameError;
    var SchemaDecodeError = class extends Error {
    };
    exports2.SchemaDecodeError = SchemaDecodeError;
    var TikTokLiveError = class extends Error {
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
      }
    };
    exports2.TikTokLiveError = TikTokLiveError;
    var ErrorReason;
    (function(ErrorReason2) {
      ErrorReason2["RATE_LIMIT"] = "Rate Limited";
      ErrorReason2["CONNECT_ERROR"] = "Connect Error";
      ErrorReason2["EMPTY_PAYLOAD"] = "Empty Payload";
      ErrorReason2["SIGN_NOT_200"] = "Sign Error";
      ErrorReason2["EMPTY_COOKIES"] = "Empty Cookies";
      ErrorReason2["PREMIUM_FEATURE"] = "Premium Feature";
      ErrorReason2["AUTHENTICATED_WS"] = "Authenticated WS";
    })(ErrorReason = exports2.ErrorReason || (exports2.ErrorReason = {}));
    var FetchSignedWebSocketIdentityParameterError = class extends Error {
    };
    exports2.FetchSignedWebSocketIdentityParameterError = FetchSignedWebSocketIdentityParameterError;
    var SignAPIError = class extends TikTokLiveError {
      reason;
      requestId;
      agentId;
      constructor(reason, requestId, agentId, ...args) {
        super([`[${reason}]`, ...args].join(" "));
        this.reason = reason;
        this.requestId = requestId;
        this.agentId = agentId;
      }
      static formatSignServerMessage(message) {
        message = message.trim();
        const msgLen = message.length;
        const headerText = "SIGN SERVER MESSAGE";
        const headerLen = Math.floor((msgLen - headerText.length) / 2);
        const paddingLen = (msgLen - headerText.length) % 2;
        const footer = "+" + "-".repeat(msgLen + 2) + "+";
        const header = "+" + "-".repeat(headerLen) + " " + headerText + " " + "-".repeat(headerLen + paddingLen) + "+";
        const prefix = "|" + " ".repeat(header.length - 2) + "|";
        const body = "| " + message + " |";
        return `
	${prefix}
	${header}
	${body}
	${footer}
`;
      }
    };
    exports2.SignAPIError = SignAPIError;
    var SignatureRateLimitError = class _SignatureRateLimitError extends SignAPIError {
      retryAfter;
      resetTime;
      constructor(apiMessage, formatStr, response) {
        const retryAfter = _SignatureRateLimitError.calculateRetryAfter(response);
        const resetTime = _SignatureRateLimitError.calculateResetTime(response);
        const logId = response.headers["X-Log-ID"];
        const agentId = response.headers["X-Agent-ID"];
        const formattedMsg = formatStr.replace("%s", retryAfter.toString());
        const args = [formattedMsg];
        if (apiMessage) {
          const serverMsg = SignAPIError.formatSignServerMessage(apiMessage);
          args.push(serverMsg);
        }
        super(ErrorReason.RATE_LIMIT, logId, agentId, ...args);
        this.retryAfter = retryAfter;
        this.resetTime = resetTime;
      }
      static parseHeaderNumber(value) {
        return value ? parseInt(value) : void 0;
      }
      static calculateRetryAfter(response) {
        const retryAfter = parseInt(response.headers["retry-after"] || "0");
        return retryAfter * 1e3;
      }
      static calculateResetTime(response) {
        const value = response.headers["x-ratelimit-reset"];
        return value ? parseInt(value) * 1e3 : void 0;
      }
    };
    exports2.SignatureRateLimitError = SignatureRateLimitError;
    var SignatureMissingTokensError = class extends SignAPIError {
      constructor(...args) {
        super(ErrorReason.EMPTY_PAYLOAD, void 0, void 0, ...args);
      }
    };
    exports2.SignatureMissingTokensError = SignatureMissingTokensError;
    var PremiumFeatureError = class extends SignAPIError {
      constructor(apiMessage, ...args) {
        args.push(SignAPIError.formatSignServerMessage(apiMessage));
        super(ErrorReason.PREMIUM_FEATURE, void 0, void 0, ...args);
      }
    };
    exports2.PremiumFeatureError = PremiumFeatureError;
    var AuthenticatedWebSocketConnectionError = class extends SignAPIError {
      constructor(...args) {
        super(ErrorReason.AUTHENTICATED_WS, void 0, void 0, ...args);
      }
    };
    exports2.AuthenticatedWebSocketConnectionError = AuthenticatedWebSocketConnectionError;
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/varint.js
var require_varint = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/varint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.varint64read = varint64read;
    exports2.varint64write = varint64write;
    exports2.int64FromString = int64FromString;
    exports2.int64ToString = int64ToString;
    exports2.uInt64ToString = uInt64ToString;
    exports2.varint32write = varint32write;
    exports2.varint32read = varint32read;
    function varint64read() {
      let lowBits = 0;
      let highBits = 0;
      for (let shift = 0; shift < 28; shift += 7) {
        let b = this.buf[this.pos++];
        lowBits |= (b & 127) << shift;
        if ((b & 128) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
        }
      }
      let middleByte = this.buf[this.pos++];
      lowBits |= (middleByte & 15) << 28;
      highBits = (middleByte & 112) >> 4;
      if ((middleByte & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
      for (let shift = 3; shift <= 31; shift += 7) {
        let b = this.buf[this.pos++];
        highBits |= (b & 127) << shift;
        if ((b & 128) == 0) {
          this.assertBounds();
          return [lowBits, highBits];
        }
      }
      throw new Error("invalid varint");
    }
    function varint64write(lo, hi, bytes) {
      for (let i = 0; i < 28; i = i + 7) {
        const shift = lo >>> i;
        const hasNext = !(shift >>> 7 == 0 && hi == 0);
        const byte = (hasNext ? shift | 128 : shift) & 255;
        bytes.push(byte);
        if (!hasNext) {
          return;
        }
      }
      const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
      const hasMoreBits = !(hi >> 3 == 0);
      bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
      if (!hasMoreBits) {
        return;
      }
      for (let i = 3; i < 31; i = i + 7) {
        const shift = hi >>> i;
        const hasNext = !(shift >>> 7 == 0);
        const byte = (hasNext ? shift | 128 : shift) & 255;
        bytes.push(byte);
        if (!hasNext) {
          return;
        }
      }
      bytes.push(hi >>> 31 & 1);
    }
    var TWO_PWR_32_DBL = 4294967296;
    function int64FromString(dec) {
      const minus = dec[0] === "-";
      if (minus) {
        dec = dec.slice(1);
      }
      const base = 1e6;
      let lowBits = 0;
      let highBits = 0;
      function add1e6digit(begin, end) {
        const digit1e6 = Number(dec.slice(begin, end));
        highBits *= base;
        lowBits = lowBits * base + digit1e6;
        if (lowBits >= TWO_PWR_32_DBL) {
          highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
          lowBits = lowBits % TWO_PWR_32_DBL;
        }
      }
      add1e6digit(-24, -18);
      add1e6digit(-18, -12);
      add1e6digit(-12, -6);
      add1e6digit(-6);
      return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
    }
    function int64ToString(lo, hi) {
      let bits = newBits(lo, hi);
      const negative = bits.hi & 2147483648;
      if (negative) {
        bits = negate(bits.lo, bits.hi);
      }
      const result = uInt64ToString(bits.lo, bits.hi);
      return negative ? "-" + result : result;
    }
    function uInt64ToString(lo, hi) {
      ({ lo, hi } = toUnsigned(lo, hi));
      if (hi <= 2097151) {
        return String(TWO_PWR_32_DBL * hi + lo);
      }
      const low = lo & 16777215;
      const mid = (lo >>> 24 | hi << 8) & 16777215;
      const high = hi >> 16 & 65535;
      let digitA = low + mid * 6777216 + high * 6710656;
      let digitB = mid + high * 8147497;
      let digitC = high * 2;
      const base = 1e7;
      if (digitA >= base) {
        digitB += Math.floor(digitA / base);
        digitA %= base;
      }
      if (digitB >= base) {
        digitC += Math.floor(digitB / base);
        digitB %= base;
      }
      return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
    }
    function toUnsigned(lo, hi) {
      return { lo: lo >>> 0, hi: hi >>> 0 };
    }
    function newBits(lo, hi) {
      return { lo: lo | 0, hi: hi | 0 };
    }
    function negate(lowBits, highBits) {
      highBits = ~highBits;
      if (lowBits) {
        lowBits = ~lowBits + 1;
      } else {
        highBits += 1;
      }
      return newBits(lowBits, highBits);
    }
    var decimalFrom1e7WithLeadingZeros = (digit1e7) => {
      const partial = String(digit1e7);
      return "0000000".slice(partial.length) + partial;
    };
    function varint32write(value, bytes) {
      if (value >= 0) {
        while (value > 127) {
          bytes.push(value & 127 | 128);
          value = value >>> 7;
        }
        bytes.push(value);
      } else {
        for (let i = 0; i < 9; i++) {
          bytes.push(value & 127 | 128);
          value = value >> 7;
        }
        bytes.push(1);
      }
    }
    function varint32read() {
      let b = this.buf[this.pos++];
      let result = b & 127;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 127) << 7;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 127) << 14;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 127) << 21;
      if ((b & 128) == 0) {
        this.assertBounds();
        return result;
      }
      b = this.buf[this.pos++];
      result |= (b & 15) << 28;
      for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
        b = this.buf[this.pos++];
      if ((b & 128) != 0)
        throw new Error("invalid varint");
      this.assertBounds();
      return result >>> 0;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/proto-int64.js
var require_proto_int64 = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/proto-int64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.protoInt64 = void 0;
    var varint_js_1 = require_varint();
    exports2.protoInt64 = makeInt64Support();
    function makeInt64Support() {
      const dv = new DataView(new ArrayBuffer(8));
      const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (!!globalThis.Deno || typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
      if (ok) {
        const MIN = BigInt("-9223372036854775808");
        const MAX = BigInt("9223372036854775807");
        const UMIN = BigInt("0");
        const UMAX = BigInt("18446744073709551615");
        return {
          zero: BigInt(0),
          supported: true,
          parse(value) {
            const bi = typeof value == "bigint" ? value : BigInt(value);
            if (bi > MAX || bi < MIN) {
              throw new Error(`invalid int64: ${value}`);
            }
            return bi;
          },
          uParse(value) {
            const bi = typeof value == "bigint" ? value : BigInt(value);
            if (bi > UMAX || bi < UMIN) {
              throw new Error(`invalid uint64: ${value}`);
            }
            return bi;
          },
          enc(value) {
            dv.setBigInt64(0, this.parse(value), true);
            return {
              lo: dv.getInt32(0, true),
              hi: dv.getInt32(4, true)
            };
          },
          uEnc(value) {
            dv.setBigInt64(0, this.uParse(value), true);
            return {
              lo: dv.getInt32(0, true),
              hi: dv.getInt32(4, true)
            };
          },
          dec(lo, hi) {
            dv.setInt32(0, lo, true);
            dv.setInt32(4, hi, true);
            return dv.getBigInt64(0, true);
          },
          uDec(lo, hi) {
            dv.setInt32(0, lo, true);
            dv.setInt32(4, hi, true);
            return dv.getBigUint64(0, true);
          }
        };
      }
      return {
        zero: "0",
        supported: false,
        parse(value) {
          if (typeof value != "string") {
            value = value.toString();
          }
          assertInt64String(value);
          return value;
        },
        uParse(value) {
          if (typeof value != "string") {
            value = value.toString();
          }
          assertUInt64String(value);
          return value;
        },
        enc(value) {
          if (typeof value != "string") {
            value = value.toString();
          }
          assertInt64String(value);
          return (0, varint_js_1.int64FromString)(value);
        },
        uEnc(value) {
          if (typeof value != "string") {
            value = value.toString();
          }
          assertUInt64String(value);
          return (0, varint_js_1.int64FromString)(value);
        },
        dec(lo, hi) {
          return (0, varint_js_1.int64ToString)(lo, hi);
        },
        uDec(lo, hi) {
          return (0, varint_js_1.uInt64ToString)(lo, hi);
        }
      };
    }
    function assertInt64String(value) {
      if (!/^-?[0-9]+$/.test(value)) {
        throw new Error("invalid int64: " + value);
      }
    }
    function assertUInt64String(value) {
      if (!/^[0-9]+$/.test(value)) {
        throw new Error("invalid uint64: " + value);
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/text-encoding.js
var require_text_encoding = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/text-encoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.configureTextEncoding = configureTextEncoding;
    exports2.getTextEncoding = getTextEncoding;
    var symbol = /* @__PURE__ */ Symbol.for("@bufbuild/protobuf/text-encoding");
    function configureTextEncoding(textEncoding) {
      globalThis[symbol] = textEncoding;
    }
    function getTextEncoding() {
      if (globalThis[symbol] == void 0) {
        const te = new globalThis.TextEncoder();
        const td = new globalThis.TextDecoder();
        globalThis[symbol] = {
          encodeUtf8(text) {
            return te.encode(text);
          },
          decodeUtf8(bytes) {
            return td.decode(bytes);
          },
          checkUtf8(text) {
            try {
              encodeURIComponent(text);
              return true;
            } catch (_) {
              return false;
            }
          }
        };
      }
      return globalThis[symbol];
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/binary-encoding.js
var require_binary_encoding = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/binary-encoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BinaryReader = exports2.BinaryWriter = exports2.INT32_MIN = exports2.INT32_MAX = exports2.UINT32_MAX = exports2.FLOAT32_MIN = exports2.FLOAT32_MAX = exports2.WireType = void 0;
    var varint_js_1 = require_varint();
    var proto_int64_js_1 = require_proto_int64();
    var text_encoding_js_1 = require_text_encoding();
    var WireType;
    (function(WireType2) {
      WireType2[WireType2["Varint"] = 0] = "Varint";
      WireType2[WireType2["Bit64"] = 1] = "Bit64";
      WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
      WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
      WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
      WireType2[WireType2["Bit32"] = 5] = "Bit32";
    })(WireType || (exports2.WireType = WireType = {}));
    exports2.FLOAT32_MAX = 34028234663852886e22;
    exports2.FLOAT32_MIN = -34028234663852886e22;
    exports2.UINT32_MAX = 4294967295;
    exports2.INT32_MAX = 2147483647;
    exports2.INT32_MIN = -2147483648;
    var BinaryWriter = class {
      constructor(encodeUtf8 = (0, text_encoding_js_1.getTextEncoding)().encodeUtf8) {
        this.encodeUtf8 = encodeUtf8;
        this.stack = [];
        this.chunks = [];
        this.buf = [];
      }
      /**
       * Return all bytes written and reset this writer.
       */
      finish() {
        if (this.buf.length) {
          this.chunks.push(new Uint8Array(this.buf));
          this.buf = [];
        }
        let len = 0;
        for (let i = 0; i < this.chunks.length; i++)
          len += this.chunks[i].length;
        let bytes = new Uint8Array(len);
        let offset = 0;
        for (let i = 0; i < this.chunks.length; i++) {
          bytes.set(this.chunks[i], offset);
          offset += this.chunks[i].length;
        }
        this.chunks = [];
        return bytes;
      }
      /**
       * Start a new fork for length-delimited data like a message
       * or a packed repeated field.
       *
       * Must be joined later with `join()`.
       */
      fork() {
        this.stack.push({ chunks: this.chunks, buf: this.buf });
        this.chunks = [];
        this.buf = [];
        return this;
      }
      /**
       * Join the last fork. Write its length and bytes, then
       * return to the previous state.
       */
      join() {
        let chunk = this.finish();
        let prev = this.stack.pop();
        if (!prev)
          throw new Error("invalid state, fork stack empty");
        this.chunks = prev.chunks;
        this.buf = prev.buf;
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
      }
      /**
       * Writes a tag (field number and wire type).
       *
       * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
       *
       * Generated code should compute the tag ahead of time and call `uint32()`.
       */
      tag(fieldNo, type) {
        return this.uint32((fieldNo << 3 | type) >>> 0);
      }
      /**
       * Write a chunk of raw bytes.
       */
      raw(chunk) {
        if (this.buf.length) {
          this.chunks.push(new Uint8Array(this.buf));
          this.buf = [];
        }
        this.chunks.push(chunk);
        return this;
      }
      /**
       * Write a `uint32` value, an unsigned 32 bit varint.
       */
      uint32(value) {
        assertUInt32(value);
        while (value > 127) {
          this.buf.push(value & 127 | 128);
          value = value >>> 7;
        }
        this.buf.push(value);
        return this;
      }
      /**
       * Write a `int32` value, a signed 32 bit varint.
       */
      int32(value) {
        assertInt32(value);
        (0, varint_js_1.varint32write)(value, this.buf);
        return this;
      }
      /**
       * Write a `bool` value, a variant.
       */
      bool(value) {
        this.buf.push(value ? 1 : 0);
        return this;
      }
      /**
       * Write a `bytes` value, length-delimited arbitrary data.
       */
      bytes(value) {
        this.uint32(value.byteLength);
        return this.raw(value);
      }
      /**
       * Write a `string` value, length-delimited data converted to UTF-8 text.
       */
      string(value) {
        let chunk = this.encodeUtf8(value);
        this.uint32(chunk.byteLength);
        return this.raw(chunk);
      }
      /**
       * Write a `float` value, 32-bit floating point number.
       */
      float(value) {
        assertFloat32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setFloat32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `double` value, a 64-bit floating point number.
       */
      double(value) {
        let chunk = new Uint8Array(8);
        new DataView(chunk.buffer).setFloat64(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
       */
      fixed32(value) {
        assertUInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setUint32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
       */
      sfixed32(value) {
        assertInt32(value);
        let chunk = new Uint8Array(4);
        new DataView(chunk.buffer).setInt32(0, value, true);
        return this.raw(chunk);
      }
      /**
       * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
       */
      sint32(value) {
        assertInt32(value);
        value = (value << 1 ^ value >> 31) >>> 0;
        (0, varint_js_1.varint32write)(value, this.buf);
        return this;
      }
      /**
       * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
       */
      sfixed64(value) {
        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = proto_int64_js_1.protoInt64.enc(value);
        view.setInt32(0, tc.lo, true);
        view.setInt32(4, tc.hi, true);
        return this.raw(chunk);
      }
      /**
       * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
       */
      fixed64(value) {
        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = proto_int64_js_1.protoInt64.uEnc(value);
        view.setInt32(0, tc.lo, true);
        view.setInt32(4, tc.hi, true);
        return this.raw(chunk);
      }
      /**
       * Write a `int64` value, a signed 64-bit varint.
       */
      int64(value) {
        let tc = proto_int64_js_1.protoInt64.enc(value);
        (0, varint_js_1.varint64write)(tc.lo, tc.hi, this.buf);
        return this;
      }
      /**
       * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64(value) {
        const tc = proto_int64_js_1.protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
        (0, varint_js_1.varint64write)(lo, hi, this.buf);
        return this;
      }
      /**
       * Write a `uint64` value, an unsigned 64-bit varint.
       */
      uint64(value) {
        const tc = proto_int64_js_1.protoInt64.uEnc(value);
        (0, varint_js_1.varint64write)(tc.lo, tc.hi, this.buf);
        return this;
      }
    };
    exports2.BinaryWriter = BinaryWriter;
    var BinaryReader = class {
      constructor(buf, decodeUtf8 = (0, text_encoding_js_1.getTextEncoding)().decodeUtf8) {
        this.decodeUtf8 = decodeUtf8;
        this.varint64 = varint_js_1.varint64read;
        this.uint32 = varint_js_1.varint32read;
        this.buf = buf;
        this.len = buf.length;
        this.pos = 0;
        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      /**
       * Reads a tag - field number and wire type.
       */
      tag() {
        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
        if (fieldNo <= 0 || wireType < 0 || wireType > 5)
          throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
        return [fieldNo, wireType];
      }
      /**
       * Skip one element and return the skipped data.
       *
       * When skipping StartGroup, provide the tags field number to check for
       * matching field number in the EndGroup tag.
       */
      skip(wireType, fieldNo) {
        let start = this.pos;
        switch (wireType) {
          case WireType.Varint:
            while (this.buf[this.pos++] & 128) {
            }
            break;
          // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
          case WireType.Bit64:
            this.pos += 4;
          case WireType.Bit32:
            this.pos += 4;
            break;
          case WireType.LengthDelimited:
            let len = this.uint32();
            this.pos += len;
            break;
          case WireType.StartGroup:
            for (; ; ) {
              const [fn, wt] = this.tag();
              if (wt === WireType.EndGroup) {
                if (fieldNo !== void 0 && fn !== fieldNo) {
                  throw new Error("invalid end group tag");
                }
                break;
              }
              this.skip(wt, fn);
            }
            break;
          default:
            throw new Error("cant skip wire type " + wireType);
        }
        this.assertBounds();
        return this.buf.subarray(start, this.pos);
      }
      /**
       * Throws error if position in byte array is out of range.
       */
      assertBounds() {
        if (this.pos > this.len)
          throw new RangeError("premature EOF");
      }
      /**
       * Read a `int32` field, a signed 32 bit varint.
       */
      int32() {
        return this.uint32() | 0;
      }
      /**
       * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
       */
      sint32() {
        let zze = this.uint32();
        return zze >>> 1 ^ -(zze & 1);
      }
      /**
       * Read a `int64` field, a signed 64-bit varint.
       */
      int64() {
        return proto_int64_js_1.protoInt64.dec(...this.varint64());
      }
      /**
       * Read a `uint64` field, an unsigned 64-bit varint.
       */
      uint64() {
        return proto_int64_js_1.protoInt64.uDec(...this.varint64());
      }
      /**
       * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
       */
      sint64() {
        let [lo, hi] = this.varint64();
        let s = -(lo & 1);
        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
        hi = hi >>> 1 ^ s;
        return proto_int64_js_1.protoInt64.dec(lo, hi);
      }
      /**
       * Read a `bool` field, a variant.
       */
      bool() {
        let [lo, hi] = this.varint64();
        return lo !== 0 || hi !== 0;
      }
      /**
       * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
       */
      fixed32() {
        return this.view.getUint32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
       */
      sfixed32() {
        return this.view.getInt32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
       */
      fixed64() {
        return proto_int64_js_1.protoInt64.uDec(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
       */
      sfixed64() {
        return proto_int64_js_1.protoInt64.dec(this.sfixed32(), this.sfixed32());
      }
      /**
       * Read a `float` field, 32-bit floating point number.
       */
      float() {
        return this.view.getFloat32((this.pos += 4) - 4, true);
      }
      /**
       * Read a `double` field, a 64-bit floating point number.
       */
      double() {
        return this.view.getFloat64((this.pos += 8) - 8, true);
      }
      /**
       * Read a `bytes` field, length-delimited arbitrary data.
       */
      bytes() {
        let len = this.uint32(), start = this.pos;
        this.pos += len;
        this.assertBounds();
        return this.buf.subarray(start, start + len);
      }
      /**
       * Read a `string` field, length-delimited data converted to UTF-8 text.
       */
      string() {
        return this.decodeUtf8(this.bytes());
      }
    };
    exports2.BinaryReader = BinaryReader;
    function assertInt32(arg) {
      if (typeof arg == "string") {
        arg = Number(arg);
      } else if (typeof arg != "number") {
        throw new Error("invalid int32: " + typeof arg);
      }
      if (!Number.isInteger(arg) || arg > exports2.INT32_MAX || arg < exports2.INT32_MIN)
        throw new Error("invalid int32: " + arg);
    }
    function assertUInt32(arg) {
      if (typeof arg == "string") {
        arg = Number(arg);
      } else if (typeof arg != "number") {
        throw new Error("invalid uint32: " + typeof arg);
      }
      if (!Number.isInteger(arg) || arg > exports2.UINT32_MAX || arg < 0)
        throw new Error("invalid uint32: " + arg);
    }
    function assertFloat32(arg) {
      if (typeof arg == "string") {
        const o = arg;
        arg = Number(arg);
        if (Number.isNaN(arg) && o !== "NaN") {
          throw new Error("invalid float32: " + o);
        }
      } else if (typeof arg != "number") {
        throw new Error("invalid float32: " + typeof arg);
      }
      if (Number.isFinite(arg) && (arg > exports2.FLOAT32_MAX || arg < exports2.FLOAT32_MIN))
        throw new Error("invalid float32: " + arg);
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/base64-encoding.js
var require_base64_encoding = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/base64-encoding.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.base64Decode = base64Decode;
    exports2.base64Encode = base64Encode;
    function base64Decode(base64Str) {
      const table = getDecodeTable();
      let es = base64Str.length * 3 / 4;
      if (base64Str[base64Str.length - 2] == "=")
        es -= 2;
      else if (base64Str[base64Str.length - 1] == "=")
        es -= 1;
      let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
      for (let i = 0; i < base64Str.length; i++) {
        b = table[base64Str.charCodeAt(i)];
        if (b === void 0) {
          switch (base64Str[i]) {
            // @ts-ignore TS7029: Fallthrough case in switch -- ignore instead of expect-error for compiler settings without noFallthroughCasesInSwitch: true
            case "=":
              groupPos = 0;
            // reset state when padding found
            case "\n":
            case "\r":
            case "	":
            case " ":
              continue;
            // skip white-space, and padding
            default:
              throw Error("invalid base64 string");
          }
        }
        switch (groupPos) {
          case 0:
            p = b;
            groupPos = 1;
            break;
          case 1:
            bytes[bytePos++] = p << 2 | (b & 48) >> 4;
            p = b;
            groupPos = 2;
            break;
          case 2:
            bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
            p = b;
            groupPos = 3;
            break;
          case 3:
            bytes[bytePos++] = (p & 3) << 6 | b;
            groupPos = 0;
            break;
        }
      }
      if (groupPos == 1)
        throw Error("invalid base64 string");
      return bytes.subarray(0, bytePos);
    }
    function base64Encode(bytes, encoding = "std") {
      const table = getEncodeTable(encoding);
      const pad = encoding == "std";
      let base64 = "", groupPos = 0, b, p = 0;
      for (let i = 0; i < bytes.length; i++) {
        b = bytes[i];
        switch (groupPos) {
          case 0:
            base64 += table[b >> 2];
            p = (b & 3) << 4;
            groupPos = 1;
            break;
          case 1:
            base64 += table[p | b >> 4];
            p = (b & 15) << 2;
            groupPos = 2;
            break;
          case 2:
            base64 += table[p | b >> 6];
            base64 += table[b & 63];
            groupPos = 0;
            break;
        }
      }
      if (groupPos) {
        base64 += table[p];
        if (pad) {
          base64 += "=";
          if (groupPos == 1)
            base64 += "=";
        }
      }
      return base64;
    }
    var encodeTableStd;
    var encodeTableUrl;
    var decodeTable;
    function getEncodeTable(encoding) {
      if (!encodeTableStd) {
        encodeTableStd = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
        encodeTableUrl = encodeTableStd.slice(0, -2).concat("-", "_");
      }
      return encoding == "url" ? (
        // biome-ignore lint/style/noNonNullAssertion: TS fails to narrow down
        encodeTableUrl
      ) : encodeTableStd;
    }
    function getDecodeTable() {
      if (!decodeTable) {
        decodeTable = [];
        const encodeTable = getEncodeTable("std");
        for (let i = 0; i < encodeTable.length; i++)
          decodeTable[encodeTable[i].charCodeAt(0)] = i;
        decodeTable["-".charCodeAt(0)] = encodeTable.indexOf("+");
        decodeTable["_".charCodeAt(0)] = encodeTable.indexOf("/");
      }
      return decodeTable;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/descriptors.js
var require_descriptors = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/descriptors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ScalarType = void 0;
    var ScalarType;
    (function(ScalarType2) {
      ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
      ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
      ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
      ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
      ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
      ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
      ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
      ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
      ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
      ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
      ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
      ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
      ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
      ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
      ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
    })(ScalarType || (exports2.ScalarType = ScalarType = {}));
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/text-format.js
var require_text_format = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/text-format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseTextFormatEnumValue = parseTextFormatEnumValue;
    exports2.parseTextFormatScalarValue = parseTextFormatScalarValue;
    var descriptors_js_1 = require_descriptors();
    var proto_int64_js_1 = require_proto_int64();
    function parseTextFormatEnumValue(descEnum, value) {
      const enumValue = descEnum.values.find((v) => v.name === value);
      if (!enumValue) {
        throw new Error(`cannot parse ${descEnum} default value: ${value}`);
      }
      return enumValue.number;
    }
    function parseTextFormatScalarValue(type, value) {
      switch (type) {
        case descriptors_js_1.ScalarType.STRING:
          return value;
        case descriptors_js_1.ScalarType.BYTES: {
          const u = unescapeBytesDefaultValue(value);
          if (u === false) {
            throw new Error(`cannot parse ${descriptors_js_1.ScalarType[type]} default value: ${value}`);
          }
          return u;
        }
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.SINT64:
          return proto_int64_js_1.protoInt64.parse(value);
        case descriptors_js_1.ScalarType.UINT64:
        case descriptors_js_1.ScalarType.FIXED64:
          return proto_int64_js_1.protoInt64.uParse(value);
        case descriptors_js_1.ScalarType.DOUBLE:
        case descriptors_js_1.ScalarType.FLOAT:
          switch (value) {
            case "inf":
              return Number.POSITIVE_INFINITY;
            case "-inf":
              return Number.NEGATIVE_INFINITY;
            case "nan":
              return Number.NaN;
            default:
              return parseFloat(value);
          }
        case descriptors_js_1.ScalarType.BOOL:
          return value === "true";
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.UINT32:
        case descriptors_js_1.ScalarType.SINT32:
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.SFIXED32:
          return parseInt(value, 10);
      }
    }
    function unescapeBytesDefaultValue(str) {
      const b = [];
      const input = {
        tail: str,
        c: "",
        next() {
          if (this.tail.length == 0) {
            return false;
          }
          this.c = this.tail[0];
          this.tail = this.tail.substring(1);
          return true;
        },
        take(n) {
          if (this.tail.length >= n) {
            const r = this.tail.substring(0, n);
            this.tail = this.tail.substring(n);
            return r;
          }
          return false;
        }
      };
      while (input.next()) {
        switch (input.c) {
          case "\\":
            if (input.next()) {
              switch (input.c) {
                case "\\":
                  b.push(input.c.charCodeAt(0));
                  break;
                case "b":
                  b.push(8);
                  break;
                case "f":
                  b.push(12);
                  break;
                case "n":
                  b.push(10);
                  break;
                case "r":
                  b.push(13);
                  break;
                case "t":
                  b.push(9);
                  break;
                case "v":
                  b.push(11);
                  break;
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7": {
                  const s = input.c;
                  const t = input.take(2);
                  if (t === false) {
                    return false;
                  }
                  const n = parseInt(s + t, 8);
                  if (Number.isNaN(n)) {
                    return false;
                  }
                  b.push(n);
                  break;
                }
                case "x": {
                  const s = input.c;
                  const t = input.take(2);
                  if (t === false) {
                    return false;
                  }
                  const n = parseInt(s + t, 16);
                  if (Number.isNaN(n)) {
                    return false;
                  }
                  b.push(n);
                  break;
                }
                case "u": {
                  const s = input.c;
                  const t = input.take(4);
                  if (t === false) {
                    return false;
                  }
                  const n = parseInt(s + t, 16);
                  if (Number.isNaN(n)) {
                    return false;
                  }
                  const chunk = new Uint8Array(4);
                  const view = new DataView(chunk.buffer);
                  view.setInt32(0, n, true);
                  b.push(chunk[0], chunk[1], chunk[2], chunk[3]);
                  break;
                }
                case "U": {
                  const s = input.c;
                  const t = input.take(8);
                  if (t === false) {
                    return false;
                  }
                  const tc = proto_int64_js_1.protoInt64.uEnc(s + t);
                  const chunk = new Uint8Array(8);
                  const view = new DataView(chunk.buffer);
                  view.setInt32(0, tc.lo, true);
                  view.setInt32(4, tc.hi, true);
                  b.push(chunk[0], chunk[1], chunk[2], chunk[3], chunk[4], chunk[5], chunk[6], chunk[7]);
                  break;
                }
              }
            }
            break;
          default:
            b.push(input.c.charCodeAt(0));
        }
      }
      return new Uint8Array(b);
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/is-message.js
var require_is_message = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/is-message.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isMessage = isMessage;
    function isMessage(arg, schema) {
      const isMessage2 = arg !== null && typeof arg == "object" && "$typeName" in arg && typeof arg.$typeName == "string";
      if (!isMessage2) {
        return false;
      }
      if (schema === void 0) {
        return true;
      }
      return schema.typeName === arg.$typeName;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/error.js
var require_error = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FieldError = void 0;
    exports2.isFieldError = isFieldError;
    var errorNames = [
      "FieldValueInvalidError",
      "FieldListRangeError",
      "ForeignFieldError"
    ];
    var FieldError = class extends Error {
      constructor(fieldOrOneof, message, name = "FieldValueInvalidError") {
        super(message);
        this.name = name;
        this.field = () => fieldOrOneof;
      }
    };
    exports2.FieldError = FieldError;
    function isFieldError(arg) {
      return arg instanceof Error && errorNames.includes(arg.name) && "field" in arg && typeof arg.field == "function";
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/scalar.js
var require_scalar = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/scalar.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scalarEquals = scalarEquals;
    exports2.scalarZeroValue = scalarZeroValue;
    exports2.isScalarZeroValue = isScalarZeroValue;
    var proto_int64_js_1 = require_proto_int64();
    var descriptors_js_1 = require_descriptors();
    function scalarEquals(type, a, b) {
      if (a === b) {
        return true;
      }
      if (type == descriptors_js_1.ScalarType.BYTES) {
        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
          return false;
        }
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) {
            return false;
          }
        }
        return true;
      }
      switch (type) {
        case descriptors_js_1.ScalarType.UINT64:
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.SINT64:
          return a == b;
      }
      return false;
    }
    function scalarZeroValue(type, longAsString) {
      switch (type) {
        case descriptors_js_1.ScalarType.STRING:
          return "";
        case descriptors_js_1.ScalarType.BOOL:
          return false;
        case descriptors_js_1.ScalarType.DOUBLE:
        case descriptors_js_1.ScalarType.FLOAT:
          return 0;
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.UINT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.SINT64:
          return longAsString ? "0" : proto_int64_js_1.protoInt64.zero;
        case descriptors_js_1.ScalarType.BYTES:
          return new Uint8Array(0);
        default:
          return 0;
      }
    }
    function isScalarZeroValue(type, value) {
      switch (type) {
        case descriptors_js_1.ScalarType.BOOL:
          return value === false;
        case descriptors_js_1.ScalarType.STRING:
          return value === "";
        case descriptors_js_1.ScalarType.BYTES:
          return value instanceof Uint8Array && !value.byteLength;
        default:
          return value == 0;
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/unsafe.js
var require_unsafe = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/unsafe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unsafeLocal = void 0;
    exports2.unsafeOneofCase = unsafeOneofCase;
    exports2.unsafeIsSet = unsafeIsSet;
    exports2.unsafeIsSetExplicit = unsafeIsSetExplicit;
    exports2.unsafeGet = unsafeGet;
    exports2.unsafeSet = unsafeSet;
    exports2.unsafeClear = unsafeClear;
    var scalar_js_1 = require_scalar();
    var IMPLICIT = 2;
    exports2.unsafeLocal = /* @__PURE__ */ Symbol.for("reflect unsafe local");
    function unsafeOneofCase(target, oneof) {
      const c = target[oneof.localName].case;
      if (c === void 0) {
        return c;
      }
      return oneof.fields.find((f) => f.localName === c);
    }
    function unsafeIsSet(target, field) {
      const name = field.localName;
      if (field.oneof) {
        return target[field.oneof.localName].case === name;
      }
      if (field.presence != IMPLICIT) {
        return target[name] !== void 0 && Object.prototype.hasOwnProperty.call(target, name);
      }
      switch (field.fieldKind) {
        case "list":
          return target[name].length > 0;
        case "map":
          return Object.keys(target[name]).length > 0;
        case "scalar":
          return !(0, scalar_js_1.isScalarZeroValue)(field.scalar, target[name]);
        case "enum":
          return target[name] !== field.enum.values[0].number;
      }
      throw new Error("message field with implicit presence");
    }
    function unsafeIsSetExplicit(target, localName) {
      return Object.prototype.hasOwnProperty.call(target, localName) && target[localName] !== void 0;
    }
    function unsafeGet(target, field) {
      if (field.oneof) {
        const oneof = target[field.oneof.localName];
        if (oneof.case === field.localName) {
          return oneof.value;
        }
        return void 0;
      }
      return target[field.localName];
    }
    function unsafeSet(target, field, value) {
      if (field.oneof) {
        target[field.oneof.localName] = {
          case: field.localName,
          value
        };
      } else {
        target[field.localName] = value;
      }
    }
    function unsafeClear(target, field) {
      const name = field.localName;
      if (field.oneof) {
        const oneofLocalName = field.oneof.localName;
        if (target[oneofLocalName].case === name) {
          target[oneofLocalName] = { case: void 0 };
        }
      } else if (field.presence != IMPLICIT) {
        delete target[name];
      } else {
        switch (field.fieldKind) {
          case "map":
            target[name] = {};
            break;
          case "list":
            target[name] = [];
            break;
          case "enum":
            target[name] = field.enum.values[0].number;
            break;
          case "scalar":
            target[name] = (0, scalar_js_1.scalarZeroValue)(field.scalar, field.longAsString);
            break;
        }
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/guard.js
var require_guard = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/guard.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isObject = isObject;
    exports2.isOneofADT = isOneofADT;
    exports2.isReflectList = isReflectList;
    exports2.isReflectMap = isReflectMap;
    exports2.isReflectMessage = isReflectMessage;
    var unsafe_js_1 = require_unsafe();
    function isObject(arg) {
      return arg !== null && typeof arg == "object" && !Array.isArray(arg);
    }
    function isOneofADT(arg) {
      return arg !== null && typeof arg == "object" && "case" in arg && (typeof arg.case == "string" && "value" in arg && arg.value != null || arg.case === void 0 && (!("value" in arg) || arg.value === void 0));
    }
    function isReflectList(arg, field) {
      var _a, _b, _c, _d;
      if (isObject(arg) && unsafe_js_1.unsafeLocal in arg && "add" in arg && "field" in arg && typeof arg.field == "function") {
        if (field !== void 0) {
          const a = field;
          const b = arg.field();
          return a.listKind == b.listKind && a.scalar === b.scalar && ((_a = a.message) === null || _a === void 0 ? void 0 : _a.typeName) === ((_b = b.message) === null || _b === void 0 ? void 0 : _b.typeName) && ((_c = a.enum) === null || _c === void 0 ? void 0 : _c.typeName) === ((_d = b.enum) === null || _d === void 0 ? void 0 : _d.typeName);
        }
        return true;
      }
      return false;
    }
    function isReflectMap(arg, field) {
      var _a, _b, _c, _d;
      if (isObject(arg) && unsafe_js_1.unsafeLocal in arg && "has" in arg && "field" in arg && typeof arg.field == "function") {
        if (field !== void 0) {
          const a = field, b = arg.field();
          return a.mapKey === b.mapKey && a.mapKind == b.mapKind && a.scalar === b.scalar && ((_a = a.message) === null || _a === void 0 ? void 0 : _a.typeName) === ((_b = b.message) === null || _b === void 0 ? void 0 : _b.typeName) && ((_c = a.enum) === null || _c === void 0 ? void 0 : _c.typeName) === ((_d = b.enum) === null || _d === void 0 ? void 0 : _d.typeName);
        }
        return true;
      }
      return false;
    }
    function isReflectMessage(arg, messageDesc) {
      return isObject(arg) && unsafe_js_1.unsafeLocal in arg && "desc" in arg && isObject(arg.desc) && arg.desc.kind === "message" && (messageDesc === void 0 || arg.desc.typeName == messageDesc.typeName);
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/reflect-check.js
var require_reflect_check = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/reflect-check.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkField = checkField;
    exports2.checkListItem = checkListItem;
    exports2.checkMapEntry = checkMapEntry;
    exports2.formatVal = formatVal;
    var descriptors_js_1 = require_descriptors();
    var is_message_js_1 = require_is_message();
    var error_js_1 = require_error();
    var guard_js_1 = require_guard();
    var binary_encoding_js_1 = require_binary_encoding();
    var text_encoding_js_1 = require_text_encoding();
    var proto_int64_js_1 = require_proto_int64();
    function checkField(field, value) {
      const check = field.fieldKind == "list" ? (0, guard_js_1.isReflectList)(value, field) : field.fieldKind == "map" ? (0, guard_js_1.isReflectMap)(value, field) : checkSingular(field, value);
      if (check === true) {
        return void 0;
      }
      let reason;
      switch (field.fieldKind) {
        case "list":
          reason = `expected ${formatReflectList(field)}, got ${formatVal(value)}`;
          break;
        case "map":
          reason = `expected ${formatReflectMap(field)}, got ${formatVal(value)}`;
          break;
        default: {
          reason = reasonSingular(field, value, check);
        }
      }
      return new error_js_1.FieldError(field, reason);
    }
    function checkListItem(field, index, value) {
      const check = checkSingular(field, value);
      if (check !== true) {
        return new error_js_1.FieldError(field, `list item #${index + 1}: ${reasonSingular(field, value, check)}`);
      }
      return void 0;
    }
    function checkMapEntry(field, key, value) {
      const checkKey = checkScalarValue(key, field.mapKey);
      if (checkKey !== true) {
        return new error_js_1.FieldError(field, `invalid map key: ${reasonSingular({ scalar: field.mapKey }, key, checkKey)}`);
      }
      const checkVal = checkSingular(field, value);
      if (checkVal !== true) {
        return new error_js_1.FieldError(field, `map entry ${formatVal(key)}: ${reasonSingular(field, value, checkVal)}`);
      }
      return void 0;
    }
    function checkSingular(field, value) {
      if (field.scalar !== void 0) {
        return checkScalarValue(value, field.scalar);
      }
      if (field.enum !== void 0) {
        if (field.enum.open) {
          return Number.isInteger(value);
        }
        return field.enum.values.some((v) => v.number === value);
      }
      return (0, guard_js_1.isReflectMessage)(value, field.message);
    }
    function checkScalarValue(value, scalar) {
      switch (scalar) {
        case descriptors_js_1.ScalarType.DOUBLE:
          return typeof value == "number";
        case descriptors_js_1.ScalarType.FLOAT:
          if (typeof value != "number") {
            return false;
          }
          if (Number.isNaN(value) || !Number.isFinite(value)) {
            return true;
          }
          if (value > binary_encoding_js_1.FLOAT32_MAX || value < binary_encoding_js_1.FLOAT32_MIN) {
            return `${value.toFixed()} out of range`;
          }
          return true;
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.SINT32:
          if (typeof value !== "number" || !Number.isInteger(value)) {
            return false;
          }
          if (value > binary_encoding_js_1.INT32_MAX || value < binary_encoding_js_1.INT32_MIN) {
            return `${value.toFixed()} out of range`;
          }
          return true;
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.UINT32:
          if (typeof value !== "number" || !Number.isInteger(value)) {
            return false;
          }
          if (value > binary_encoding_js_1.UINT32_MAX || value < 0) {
            return `${value.toFixed()} out of range`;
          }
          return true;
        case descriptors_js_1.ScalarType.BOOL:
          return typeof value == "boolean";
        case descriptors_js_1.ScalarType.STRING:
          if (typeof value != "string") {
            return false;
          }
          return (0, text_encoding_js_1.getTextEncoding)().checkUtf8(value) || "invalid UTF8";
        case descriptors_js_1.ScalarType.BYTES:
          return value instanceof Uint8Array;
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.SINT64:
          if (typeof value == "bigint" || typeof value == "number" || typeof value == "string" && value.length > 0) {
            try {
              proto_int64_js_1.protoInt64.parse(value);
              return true;
            } catch (_) {
              return `${value} out of range`;
            }
          }
          return false;
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.UINT64:
          if (typeof value == "bigint" || typeof value == "number" || typeof value == "string" && value.length > 0) {
            try {
              proto_int64_js_1.protoInt64.uParse(value);
              return true;
            } catch (_) {
              return `${value} out of range`;
            }
          }
          return false;
      }
    }
    function reasonSingular(field, val, details) {
      details = typeof details == "string" ? `: ${details}` : `, got ${formatVal(val)}`;
      if (field.scalar !== void 0) {
        return `expected ${scalarTypeDescription(field.scalar)}` + details;
      }
      if (field.enum !== void 0) {
        return `expected ${field.enum.toString()}` + details;
      }
      return `expected ${formatReflectMessage(field.message)}` + details;
    }
    function formatVal(val) {
      switch (typeof val) {
        case "object":
          if (val === null) {
            return "null";
          }
          if (val instanceof Uint8Array) {
            return `Uint8Array(${val.length})`;
          }
          if (Array.isArray(val)) {
            return `Array(${val.length})`;
          }
          if ((0, guard_js_1.isReflectList)(val)) {
            return formatReflectList(val.field());
          }
          if ((0, guard_js_1.isReflectMap)(val)) {
            return formatReflectMap(val.field());
          }
          if ((0, guard_js_1.isReflectMessage)(val)) {
            return formatReflectMessage(val.desc);
          }
          if ((0, is_message_js_1.isMessage)(val)) {
            return `message ${val.$typeName}`;
          }
          return "object";
        case "string":
          return val.length > 30 ? "string" : `"${val.split('"').join('\\"')}"`;
        case "boolean":
          return String(val);
        case "number":
          return String(val);
        case "bigint":
          return String(val) + "n";
        default:
          return typeof val;
      }
    }
    function formatReflectMessage(desc) {
      return `ReflectMessage (${desc.typeName})`;
    }
    function formatReflectList(field) {
      switch (field.listKind) {
        case "message":
          return `ReflectList (${field.message.toString()})`;
        case "enum":
          return `ReflectList (${field.enum.toString()})`;
        case "scalar":
          return `ReflectList (${descriptors_js_1.ScalarType[field.scalar]})`;
      }
    }
    function formatReflectMap(field) {
      switch (field.mapKind) {
        case "message":
          return `ReflectMap (${descriptors_js_1.ScalarType[field.mapKey]}, ${field.message.toString()})`;
        case "enum":
          return `ReflectMap (${descriptors_js_1.ScalarType[field.mapKey]}, ${field.enum.toString()})`;
        case "scalar":
          return `ReflectMap (${descriptors_js_1.ScalarType[field.mapKey]}, ${descriptors_js_1.ScalarType[field.scalar]})`;
      }
    }
    function scalarTypeDescription(scalar) {
      switch (scalar) {
        case descriptors_js_1.ScalarType.STRING:
          return "string";
        case descriptors_js_1.ScalarType.BOOL:
          return "boolean";
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.SINT64:
        case descriptors_js_1.ScalarType.SFIXED64:
          return "bigint (int64)";
        case descriptors_js_1.ScalarType.UINT64:
        case descriptors_js_1.ScalarType.FIXED64:
          return "bigint (uint64)";
        case descriptors_js_1.ScalarType.BYTES:
          return "Uint8Array";
        case descriptors_js_1.ScalarType.DOUBLE:
          return "number (float64)";
        case descriptors_js_1.ScalarType.FLOAT:
          return "number (float32)";
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.UINT32:
          return "number (uint32)";
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.SINT32:
          return "number (int32)";
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wkt/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wkt/wrappers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isWrapper = isWrapper;
    exports2.isWrapperDesc = isWrapperDesc;
    function isWrapper(arg) {
      return isWrapperTypeName(arg.$typeName);
    }
    function isWrapperDesc(messageDesc) {
      const f = messageDesc.fields[0];
      return isWrapperTypeName(messageDesc.typeName) && f !== void 0 && f.fieldKind == "scalar" && f.name == "value" && f.number == 1;
    }
    function isWrapperTypeName(name) {
      return name.startsWith("google.protobuf.") && [
        "DoubleValue",
        "FloatValue",
        "Int64Value",
        "UInt64Value",
        "Int32Value",
        "UInt32Value",
        "BoolValue",
        "StringValue",
        "BytesValue"
      ].includes(name.substring(16));
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/create.js
var require_create = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/create.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.create = create;
    var is_message_js_1 = require_is_message();
    var descriptors_js_1 = require_descriptors();
    var scalar_js_1 = require_scalar();
    var guard_js_1 = require_guard();
    var unsafe_js_1 = require_unsafe();
    var wrappers_js_1 = require_wrappers();
    var EDITION_PROTO3 = 999;
    var EDITION_PROTO2 = 998;
    var IMPLICIT = 2;
    function create(schema, init) {
      if ((0, is_message_js_1.isMessage)(init, schema)) {
        return init;
      }
      const message = createZeroMessage(schema);
      if (init !== void 0) {
        initMessage(schema, message, init);
      }
      return message;
    }
    function initMessage(messageDesc, message, init) {
      for (const member of messageDesc.members) {
        let value = init[member.localName];
        if (value == null) {
          continue;
        }
        let field;
        if (member.kind == "oneof") {
          const oneofField = (0, unsafe_js_1.unsafeOneofCase)(init, member);
          if (!oneofField) {
            continue;
          }
          field = oneofField;
          value = (0, unsafe_js_1.unsafeGet)(init, oneofField);
        } else {
          field = member;
        }
        switch (field.fieldKind) {
          case "message":
            value = toMessage(field, value);
            break;
          case "scalar":
            value = initScalar(field, value);
            break;
          case "list":
            value = initList(field, value);
            break;
          case "map":
            value = initMap(field, value);
            break;
        }
        (0, unsafe_js_1.unsafeSet)(message, field, value);
      }
      return message;
    }
    function initScalar(field, value) {
      if (field.scalar == descriptors_js_1.ScalarType.BYTES) {
        return toU8Arr(value);
      }
      return value;
    }
    function initMap(field, value) {
      if ((0, guard_js_1.isObject)(value)) {
        if (field.scalar == descriptors_js_1.ScalarType.BYTES) {
          return convertObjectValues(value, toU8Arr);
        }
        if (field.mapKind == "message") {
          return convertObjectValues(value, (val) => toMessage(field, val));
        }
      }
      return value;
    }
    function initList(field, value) {
      if (Array.isArray(value)) {
        if (field.scalar == descriptors_js_1.ScalarType.BYTES) {
          return value.map(toU8Arr);
        }
        if (field.listKind == "message") {
          return value.map((item) => toMessage(field, item));
        }
      }
      return value;
    }
    function toMessage(field, value) {
      if (field.fieldKind == "message" && !field.oneof && (0, wrappers_js_1.isWrapperDesc)(field.message)) {
        return initScalar(field.message.fields[0], value);
      }
      if ((0, guard_js_1.isObject)(value)) {
        if (field.message.typeName == "google.protobuf.Struct" && field.parent.typeName !== "google.protobuf.Value") {
          return value;
        }
        if (!(0, is_message_js_1.isMessage)(value, field.message)) {
          return create(field.message, value);
        }
      }
      return value;
    }
    function toU8Arr(value) {
      return Array.isArray(value) ? new Uint8Array(value) : value;
    }
    function convertObjectValues(obj, fn) {
      const ret = {};
      for (const entry of Object.entries(obj)) {
        ret[entry[0]] = fn(entry[1]);
      }
      return ret;
    }
    var tokenZeroMessageField = /* @__PURE__ */ Symbol();
    var messagePrototypes = /* @__PURE__ */ new WeakMap();
    function createZeroMessage(desc) {
      let msg;
      if (!needsPrototypeChain(desc)) {
        msg = {
          $typeName: desc.typeName
        };
        for (const member of desc.members) {
          if (member.kind == "oneof" || member.presence == IMPLICIT) {
            msg[member.localName] = createZeroField(member);
          }
        }
      } else {
        const cached = messagePrototypes.get(desc);
        let prototype;
        let members;
        if (cached) {
          ({ prototype, members } = cached);
        } else {
          prototype = {};
          members = /* @__PURE__ */ new Set();
          for (const member of desc.members) {
            if (member.kind == "oneof") {
              continue;
            }
            if (member.fieldKind != "scalar" && member.fieldKind != "enum") {
              continue;
            }
            if (member.presence == IMPLICIT) {
              continue;
            }
            members.add(member);
            prototype[member.localName] = createZeroField(member);
          }
          messagePrototypes.set(desc, { prototype, members });
        }
        msg = Object.create(prototype);
        msg.$typeName = desc.typeName;
        for (const member of desc.members) {
          if (members.has(member)) {
            continue;
          }
          if (member.kind == "field") {
            if (member.fieldKind == "message") {
              continue;
            }
            if (member.fieldKind == "scalar" || member.fieldKind == "enum") {
              if (member.presence != IMPLICIT) {
                continue;
              }
            }
          }
          msg[member.localName] = createZeroField(member);
        }
      }
      return msg;
    }
    function needsPrototypeChain(desc) {
      switch (desc.file.edition) {
        case EDITION_PROTO3:
          return false;
        case EDITION_PROTO2:
          return true;
        default:
          return desc.fields.some((f) => f.presence != IMPLICIT && f.fieldKind != "message" && !f.oneof);
      }
    }
    function createZeroField(field) {
      if (field.kind == "oneof") {
        return { case: void 0 };
      }
      if (field.fieldKind == "list") {
        return [];
      }
      if (field.fieldKind == "map") {
        return {};
      }
      if (field.fieldKind == "message") {
        return tokenZeroMessageField;
      }
      const defaultValue = field.getDefaultValue();
      if (defaultValue !== void 0) {
        return field.fieldKind == "scalar" && field.longAsString ? defaultValue.toString() : defaultValue;
      }
      return field.fieldKind == "scalar" ? (0, scalar_js_1.scalarZeroValue)(field.scalar, field.longAsString) : field.enum.values[0].number;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/reflect/reflect.js
var require_reflect = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/reflect/reflect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reflect = reflect;
    exports2.reflectList = reflectList;
    exports2.reflectMap = reflectMap;
    var descriptors_js_1 = require_descriptors();
    var reflect_check_js_1 = require_reflect_check();
    var error_js_1 = require_error();
    var unsafe_js_1 = require_unsafe();
    var create_js_1 = require_create();
    var wrappers_js_1 = require_wrappers();
    var scalar_js_1 = require_scalar();
    var proto_int64_js_1 = require_proto_int64();
    var guard_js_1 = require_guard();
    function reflect(messageDesc, message, check = true) {
      return new ReflectMessageImpl(messageDesc, message, check);
    }
    var messageSortedFields = /* @__PURE__ */ new WeakMap();
    var ReflectMessageImpl = class {
      get sortedFields() {
        const cached = messageSortedFields.get(this.desc);
        if (cached) {
          return cached;
        }
        const sortedFields = this.desc.fields.concat().sort((a, b) => a.number - b.number);
        messageSortedFields.set(this.desc, sortedFields);
        return sortedFields;
      }
      constructor(messageDesc, message, check = true) {
        this.lists = /* @__PURE__ */ new Map();
        this.maps = /* @__PURE__ */ new Map();
        this.check = check;
        this.desc = messageDesc;
        this.message = this[unsafe_js_1.unsafeLocal] = message !== null && message !== void 0 ? message : (0, create_js_1.create)(messageDesc);
        this.fields = messageDesc.fields;
        this.oneofs = messageDesc.oneofs;
        this.members = messageDesc.members;
      }
      findNumber(number) {
        if (!this._fieldsByNumber) {
          this._fieldsByNumber = new Map(this.desc.fields.map((f) => [f.number, f]));
        }
        return this._fieldsByNumber.get(number);
      }
      oneofCase(oneof) {
        assertOwn(this.message, oneof);
        return (0, unsafe_js_1.unsafeOneofCase)(this.message, oneof);
      }
      isSet(field) {
        assertOwn(this.message, field);
        return (0, unsafe_js_1.unsafeIsSet)(this.message, field);
      }
      clear(field) {
        assertOwn(this.message, field);
        (0, unsafe_js_1.unsafeClear)(this.message, field);
      }
      get(field) {
        assertOwn(this.message, field);
        const value = (0, unsafe_js_1.unsafeGet)(this.message, field);
        switch (field.fieldKind) {
          case "list":
            let list = this.lists.get(field);
            if (!list || list[unsafe_js_1.unsafeLocal] !== value) {
              this.lists.set(
                field,
                // biome-ignore lint/suspicious/noAssignInExpressions: no
                list = new ReflectListImpl(field, value, this.check)
              );
            }
            return list;
          case "map":
            let map = this.maps.get(field);
            if (!map || map[unsafe_js_1.unsafeLocal] !== value) {
              this.maps.set(
                field,
                // biome-ignore lint/suspicious/noAssignInExpressions: no
                map = new ReflectMapImpl(field, value, this.check)
              );
            }
            return map;
          case "message":
            return messageToReflect(field, value, this.check);
          case "scalar":
            return value === void 0 ? (0, scalar_js_1.scalarZeroValue)(field.scalar, false) : longToReflect(field, value);
          case "enum":
            return value !== null && value !== void 0 ? value : field.enum.values[0].number;
        }
      }
      set(field, value) {
        assertOwn(this.message, field);
        if (this.check) {
          const err = (0, reflect_check_js_1.checkField)(field, value);
          if (err) {
            throw err;
          }
        }
        let local;
        if (field.fieldKind == "message") {
          local = messageToLocal(field, value);
        } else if ((0, guard_js_1.isReflectMap)(value) || (0, guard_js_1.isReflectList)(value)) {
          local = value[unsafe_js_1.unsafeLocal];
        } else {
          local = longToLocal(field, value);
        }
        (0, unsafe_js_1.unsafeSet)(this.message, field, local);
      }
      getUnknown() {
        return this.message.$unknown;
      }
      setUnknown(value) {
        this.message.$unknown = value;
      }
    };
    function assertOwn(owner, member) {
      if (member.parent.typeName !== owner.$typeName) {
        throw new error_js_1.FieldError(member, `cannot use ${member.toString()} with message ${owner.$typeName}`, "ForeignFieldError");
      }
    }
    function reflectList(field, unsafeInput, check = true) {
      return new ReflectListImpl(field, unsafeInput !== null && unsafeInput !== void 0 ? unsafeInput : [], check);
    }
    var ReflectListImpl = class {
      field() {
        return this._field;
      }
      get size() {
        return this._arr.length;
      }
      constructor(field, unsafeInput, check) {
        this._field = field;
        this._arr = this[unsafe_js_1.unsafeLocal] = unsafeInput;
        this.check = check;
      }
      get(index) {
        const item = this._arr[index];
        return item === void 0 ? void 0 : listItemToReflect(this._field, item, this.check);
      }
      set(index, item) {
        if (index < 0 || index >= this._arr.length) {
          throw new error_js_1.FieldError(this._field, `list item #${index + 1}: out of range`);
        }
        if (this.check) {
          const err = (0, reflect_check_js_1.checkListItem)(this._field, index, item);
          if (err) {
            throw err;
          }
        }
        this._arr[index] = listItemToLocal(this._field, item);
      }
      add(item) {
        if (this.check) {
          const err = (0, reflect_check_js_1.checkListItem)(this._field, this._arr.length, item);
          if (err) {
            throw err;
          }
        }
        this._arr.push(listItemToLocal(this._field, item));
        return void 0;
      }
      clear() {
        this._arr.splice(0, this._arr.length);
      }
      [Symbol.iterator]() {
        return this.values();
      }
      keys() {
        return this._arr.keys();
      }
      *values() {
        for (const item of this._arr) {
          yield listItemToReflect(this._field, item, this.check);
        }
      }
      *entries() {
        for (let i = 0; i < this._arr.length; i++) {
          yield [i, listItemToReflect(this._field, this._arr[i], this.check)];
        }
      }
    };
    function reflectMap(field, unsafeInput, check = true) {
      return new ReflectMapImpl(field, unsafeInput, check);
    }
    var ReflectMapImpl = class {
      constructor(field, unsafeInput, check = true) {
        this.obj = this[unsafe_js_1.unsafeLocal] = unsafeInput !== null && unsafeInput !== void 0 ? unsafeInput : {};
        this.check = check;
        this._field = field;
      }
      field() {
        return this._field;
      }
      set(key, value) {
        if (this.check) {
          const err = (0, reflect_check_js_1.checkMapEntry)(this._field, key, value);
          if (err) {
            throw err;
          }
        }
        this.obj[mapKeyToLocal(key)] = mapValueToLocal(this._field, value);
        return this;
      }
      delete(key) {
        const k = mapKeyToLocal(key);
        const has = Object.prototype.hasOwnProperty.call(this.obj, k);
        if (has) {
          delete this.obj[k];
        }
        return has;
      }
      clear() {
        for (const key of Object.keys(this.obj)) {
          delete this.obj[key];
        }
      }
      get(key) {
        let val = this.obj[mapKeyToLocal(key)];
        if (val !== void 0) {
          val = mapValueToReflect(this._field, val, this.check);
        }
        return val;
      }
      has(key) {
        return Object.prototype.hasOwnProperty.call(this.obj, mapKeyToLocal(key));
      }
      *keys() {
        for (const objKey of Object.keys(this.obj)) {
          yield mapKeyToReflect(objKey, this._field.mapKey);
        }
      }
      *entries() {
        for (const objEntry of Object.entries(this.obj)) {
          yield [
            mapKeyToReflect(objEntry[0], this._field.mapKey),
            mapValueToReflect(this._field, objEntry[1], this.check)
          ];
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      get size() {
        return Object.keys(this.obj).length;
      }
      *values() {
        for (const val of Object.values(this.obj)) {
          yield mapValueToReflect(this._field, val, this.check);
        }
      }
      forEach(callbackfn, thisArg) {
        for (const mapEntry of this.entries()) {
          callbackfn.call(thisArg, mapEntry[1], mapEntry[0], this);
        }
      }
    };
    function messageToLocal(field, value) {
      if (!(0, guard_js_1.isReflectMessage)(value)) {
        return value;
      }
      if ((0, wrappers_js_1.isWrapper)(value.message) && !field.oneof && field.fieldKind == "message") {
        return value.message.value;
      }
      if (value.desc.typeName == "google.protobuf.Struct" && field.parent.typeName != "google.protobuf.Value") {
        return wktStructToLocal(value.message);
      }
      return value.message;
    }
    function messageToReflect(field, value, check) {
      if (value !== void 0) {
        if ((0, wrappers_js_1.isWrapperDesc)(field.message) && !field.oneof && field.fieldKind == "message") {
          value = {
            $typeName: field.message.typeName,
            value: longToReflect(field.message.fields[0], value)
          };
        } else if (field.message.typeName == "google.protobuf.Struct" && field.parent.typeName != "google.protobuf.Value" && (0, guard_js_1.isObject)(value)) {
          value = wktStructToReflect(value);
        }
      }
      return new ReflectMessageImpl(field.message, value, check);
    }
    function listItemToLocal(field, value) {
      if (field.listKind == "message") {
        return messageToLocal(field, value);
      }
      return longToLocal(field, value);
    }
    function listItemToReflect(field, value, check) {
      if (field.listKind == "message") {
        return messageToReflect(field, value, check);
      }
      return longToReflect(field, value);
    }
    function mapValueToLocal(field, value) {
      if (field.mapKind == "message") {
        return messageToLocal(field, value);
      }
      return longToLocal(field, value);
    }
    function mapValueToReflect(field, value, check) {
      if (field.mapKind == "message") {
        return messageToReflect(field, value, check);
      }
      return value;
    }
    function mapKeyToLocal(key) {
      return typeof key == "string" || typeof key == "number" ? key : String(key);
    }
    function mapKeyToReflect(key, type) {
      switch (type) {
        case descriptors_js_1.ScalarType.STRING:
          return key;
        case descriptors_js_1.ScalarType.INT32:
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.UINT32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.SINT32: {
          const n = Number.parseInt(key);
          if (Number.isFinite(n)) {
            return n;
          }
          break;
        }
        case descriptors_js_1.ScalarType.BOOL:
          switch (key) {
            case "true":
              return true;
            case "false":
              return false;
          }
          break;
        case descriptors_js_1.ScalarType.UINT64:
        case descriptors_js_1.ScalarType.FIXED64:
          try {
            return proto_int64_js_1.protoInt64.uParse(key);
          } catch (_a) {
          }
          break;
        default:
          try {
            return proto_int64_js_1.protoInt64.parse(key);
          } catch (_b) {
          }
          break;
      }
      return key;
    }
    function longToReflect(field, value) {
      switch (field.scalar) {
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.SINT64:
          if ("longAsString" in field && field.longAsString && typeof value == "string") {
            value = proto_int64_js_1.protoInt64.parse(value);
          }
          break;
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.UINT64:
          if ("longAsString" in field && field.longAsString && typeof value == "string") {
            value = proto_int64_js_1.protoInt64.uParse(value);
          }
          break;
      }
      return value;
    }
    function longToLocal(field, value) {
      switch (field.scalar) {
        case descriptors_js_1.ScalarType.INT64:
        case descriptors_js_1.ScalarType.SFIXED64:
        case descriptors_js_1.ScalarType.SINT64:
          if ("longAsString" in field && field.longAsString) {
            value = String(value);
          } else if (typeof value == "string" || typeof value == "number") {
            value = proto_int64_js_1.protoInt64.parse(value);
          }
          break;
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.UINT64:
          if ("longAsString" in field && field.longAsString) {
            value = String(value);
          } else if (typeof value == "string" || typeof value == "number") {
            value = proto_int64_js_1.protoInt64.uParse(value);
          }
          break;
      }
      return value;
    }
    function wktStructToReflect(json) {
      const struct = {
        $typeName: "google.protobuf.Struct",
        fields: {}
      };
      if ((0, guard_js_1.isObject)(json)) {
        for (const [k, v] of Object.entries(json)) {
          struct.fields[k] = wktValueToReflect(v);
        }
      }
      return struct;
    }
    function wktStructToLocal(val) {
      const json = {};
      for (const [k, v] of Object.entries(val.fields)) {
        json[k] = wktValueToLocal(v);
      }
      return json;
    }
    function wktValueToLocal(val) {
      switch (val.kind.case) {
        case "structValue":
          return wktStructToLocal(val.kind.value);
        case "listValue":
          return val.kind.value.values.map(wktValueToLocal);
        case "nullValue":
        case void 0:
          return null;
        default:
          return val.kind.value;
      }
    }
    function wktValueToReflect(json) {
      const value = {
        $typeName: "google.protobuf.Value",
        kind: { case: void 0 }
      };
      switch (typeof json) {
        case "number":
          value.kind = { case: "numberValue", value: json };
          break;
        case "string":
          value.kind = { case: "stringValue", value: json };
          break;
        case "boolean":
          value.kind = { case: "boolValue", value: json };
          break;
        case "object":
          if (json === null) {
            const nullValue = 0;
            value.kind = { case: "nullValue", value: nullValue };
          } else if (Array.isArray(json)) {
            const listValue = {
              $typeName: "google.protobuf.ListValue",
              values: []
            };
            if (Array.isArray(json)) {
              for (const e of json) {
                listValue.values.push(wktValueToReflect(e));
              }
            }
            value.kind = {
              case: "listValue",
              value: listValue
            };
          } else {
            value.kind = {
              case: "structValue",
              value: wktStructToReflect(json)
            };
          }
          break;
      }
      return value;
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/to-binary.js
var require_to_binary = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/to-binary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.toBinary = toBinary;
    exports2.writeField = writeField;
    var reflect_js_1 = require_reflect();
    var binary_encoding_js_1 = require_binary_encoding();
    var descriptors_js_1 = require_descriptors();
    var LEGACY_REQUIRED = 3;
    var writeDefaults = {
      writeUnknownFields: true
    };
    function makeWriteOptions(options) {
      return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
    }
    function toBinary(schema, message, options) {
      return writeFields(new binary_encoding_js_1.BinaryWriter(), makeWriteOptions(options), (0, reflect_js_1.reflect)(schema, message)).finish();
    }
    function writeFields(writer, opts, msg) {
      var _a;
      for (const f of msg.sortedFields) {
        if (!msg.isSet(f)) {
          if (f.presence == LEGACY_REQUIRED) {
            throw new Error(`cannot encode ${f} to binary: required field not set`);
          }
          continue;
        }
        writeField(writer, opts, msg, f);
      }
      if (opts.writeUnknownFields) {
        for (const { no, wireType, data } of (_a = msg.getUnknown()) !== null && _a !== void 0 ? _a : []) {
          writer.tag(no, wireType).raw(data);
        }
      }
      return writer;
    }
    function writeField(writer, opts, msg, field) {
      var _a;
      switch (field.fieldKind) {
        case "scalar":
        case "enum":
          writeScalar(writer, msg.desc.typeName, field.name, (_a = field.scalar) !== null && _a !== void 0 ? _a : descriptors_js_1.ScalarType.INT32, field.number, msg.get(field));
          break;
        case "list":
          writeListField(writer, opts, field, msg.get(field));
          break;
        case "message":
          writeMessageField(writer, opts, field, msg.get(field));
          break;
        case "map":
          for (const [key, val] of msg.get(field)) {
            writeMapEntry(writer, opts, field, key, val);
          }
          break;
      }
    }
    function writeScalar(writer, msgName, fieldName, scalarType, fieldNo, value) {
      writeScalarValue(writer.tag(fieldNo, writeTypeOfScalar(scalarType)), msgName, fieldName, scalarType, value);
    }
    function writeMessageField(writer, opts, field, message) {
      if (field.delimitedEncoding) {
        writeFields(writer.tag(field.number, binary_encoding_js_1.WireType.StartGroup), opts, message).tag(field.number, binary_encoding_js_1.WireType.EndGroup);
      } else {
        writeFields(writer.tag(field.number, binary_encoding_js_1.WireType.LengthDelimited).fork(), opts, message).join();
      }
    }
    function writeListField(writer, opts, field, list) {
      var _a;
      if (field.listKind == "message") {
        for (const item of list) {
          writeMessageField(writer, opts, field, item);
        }
        return;
      }
      const scalarType = (_a = field.scalar) !== null && _a !== void 0 ? _a : descriptors_js_1.ScalarType.INT32;
      if (field.packed) {
        if (!list.size) {
          return;
        }
        writer.tag(field.number, binary_encoding_js_1.WireType.LengthDelimited).fork();
        for (const item of list) {
          writeScalarValue(writer, field.parent.typeName, field.name, scalarType, item);
        }
        writer.join();
        return;
      }
      for (const item of list) {
        writeScalar(writer, field.parent.typeName, field.name, scalarType, field.number, item);
      }
    }
    function writeMapEntry(writer, opts, field, key, value) {
      var _a;
      writer.tag(field.number, binary_encoding_js_1.WireType.LengthDelimited).fork();
      writeScalar(writer, field.parent.typeName, field.name, field.mapKey, 1, key);
      switch (field.mapKind) {
        case "scalar":
        case "enum":
          writeScalar(writer, field.parent.typeName, field.name, (_a = field.scalar) !== null && _a !== void 0 ? _a : descriptors_js_1.ScalarType.INT32, 2, value);
          break;
        case "message":
          writeFields(writer.tag(2, binary_encoding_js_1.WireType.LengthDelimited).fork(), opts, value).join();
          break;
      }
      writer.join();
    }
    function writeScalarValue(writer, msgName, fieldName, type, value) {
      try {
        switch (type) {
          case descriptors_js_1.ScalarType.STRING:
            writer.string(value);
            break;
          case descriptors_js_1.ScalarType.BOOL:
            writer.bool(value);
            break;
          case descriptors_js_1.ScalarType.DOUBLE:
            writer.double(value);
            break;
          case descriptors_js_1.ScalarType.FLOAT:
            writer.float(value);
            break;
          case descriptors_js_1.ScalarType.INT32:
            writer.int32(value);
            break;
          case descriptors_js_1.ScalarType.INT64:
            writer.int64(value);
            break;
          case descriptors_js_1.ScalarType.UINT64:
            writer.uint64(value);
            break;
          case descriptors_js_1.ScalarType.FIXED64:
            writer.fixed64(value);
            break;
          case descriptors_js_1.ScalarType.BYTES:
            writer.bytes(value);
            break;
          case descriptors_js_1.ScalarType.FIXED32:
            writer.fixed32(value);
            break;
          case descriptors_js_1.ScalarType.SFIXED32:
            writer.sfixed32(value);
            break;
          case descriptors_js_1.ScalarType.SFIXED64:
            writer.sfixed64(value);
            break;
          case descriptors_js_1.ScalarType.SINT64:
            writer.sint64(value);
            break;
          case descriptors_js_1.ScalarType.UINT32:
            writer.uint32(value);
            break;
          case descriptors_js_1.ScalarType.SINT32:
            writer.sint32(value);
            break;
        }
      } catch (e) {
        if (e instanceof Error) {
          throw new Error(`cannot encode field ${msgName}.${fieldName} to binary: ${e.message}`);
        }
        throw e;
      }
    }
    function writeTypeOfScalar(type) {
      switch (type) {
        case descriptors_js_1.ScalarType.BYTES:
        case descriptors_js_1.ScalarType.STRING:
          return binary_encoding_js_1.WireType.LengthDelimited;
        case descriptors_js_1.ScalarType.DOUBLE:
        case descriptors_js_1.ScalarType.FIXED64:
        case descriptors_js_1.ScalarType.SFIXED64:
          return binary_encoding_js_1.WireType.Bit64;
        case descriptors_js_1.ScalarType.FIXED32:
        case descriptors_js_1.ScalarType.SFIXED32:
        case descriptors_js_1.ScalarType.FLOAT:
          return binary_encoding_js_1.WireType.Bit32;
        default:
          return binary_encoding_js_1.WireType.Varint;
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/from-binary.js
var require_from_binary = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/from-binary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromBinary = fromBinary;
    exports2.mergeFromBinary = mergeFromBinary;
    exports2.readField = readField;
    var descriptors_js_1 = require_descriptors();
    var scalar_js_1 = require_scalar();
    var reflect_js_1 = require_reflect();
    var binary_encoding_js_1 = require_binary_encoding();
    var varint_js_1 = require_varint();
    var readDefaults = {
      readUnknownFields: true
    };
    function makeReadOptions(options) {
      return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
    }
    function fromBinary(schema, bytes, options) {
      const msg = (0, reflect_js_1.reflect)(schema, void 0, false);
      readMessage(msg, new binary_encoding_js_1.BinaryReader(bytes), makeReadOptions(options), false, bytes.byteLength);
      return msg.message;
    }
    function mergeFromBinary(schema, target, bytes, options) {
      readMessage((0, reflect_js_1.reflect)(schema, target, false), new binary_encoding_js_1.BinaryReader(bytes), makeReadOptions(options), false, bytes.byteLength);
      return target;
    }
    function readMessage(message, reader, options, delimited, lengthOrDelimitedFieldNo) {
      var _a;
      const end = delimited ? reader.len : reader.pos + lengthOrDelimitedFieldNo;
      let fieldNo;
      let wireType;
      const unknownFields = (_a = message.getUnknown()) !== null && _a !== void 0 ? _a : [];
      while (reader.pos < end) {
        [fieldNo, wireType] = reader.tag();
        if (delimited && wireType == binary_encoding_js_1.WireType.EndGroup) {
          break;
        }
        const field = message.findNumber(fieldNo);
        if (!field) {
          const data = reader.skip(wireType, fieldNo);
          if (options.readUnknownFields) {
            unknownFields.push({ no: fieldNo, wireType, data });
          }
          continue;
        }
        readField(message, reader, field, wireType, options);
      }
      if (delimited) {
        if (wireType != binary_encoding_js_1.WireType.EndGroup || fieldNo !== lengthOrDelimitedFieldNo) {
          throw new Error("invalid end group tag");
        }
      }
      if (unknownFields.length > 0) {
        message.setUnknown(unknownFields);
      }
    }
    function readField(message, reader, field, wireType, options) {
      var _a;
      switch (field.fieldKind) {
        case "scalar":
          message.set(field, readScalar(reader, field.scalar));
          break;
        case "enum":
          const val = readScalar(reader, descriptors_js_1.ScalarType.INT32);
          if (field.enum.open) {
            message.set(field, val);
          } else {
            const ok = field.enum.values.some((v) => v.number === val);
            if (ok) {
              message.set(field, val);
            } else if (options.readUnknownFields) {
              const bytes = [];
              (0, varint_js_1.varint32write)(val, bytes);
              const unknownFields = (_a = message.getUnknown()) !== null && _a !== void 0 ? _a : [];
              unknownFields.push({
                no: field.number,
                wireType,
                data: new Uint8Array(bytes)
              });
              message.setUnknown(unknownFields);
            }
          }
          break;
        case "message":
          message.set(field, readMessageField(reader, options, field, message.get(field)));
          break;
        case "list":
          readListField(reader, wireType, message.get(field), options);
          break;
        case "map":
          readMapEntry(reader, message.get(field), options);
          break;
      }
    }
    function readMapEntry(reader, map, options) {
      const field = map.field();
      let key;
      let val;
      const len = reader.uint32();
      const end = reader.pos + len;
      while (reader.pos < end) {
        const [fieldNo] = reader.tag();
        switch (fieldNo) {
          case 1:
            key = readScalar(reader, field.mapKey);
            break;
          case 2:
            switch (field.mapKind) {
              case "scalar":
                val = readScalar(reader, field.scalar);
                break;
              case "enum":
                val = reader.int32();
                break;
              case "message":
                val = readMessageField(reader, options, field);
                break;
            }
            break;
        }
      }
      if (key === void 0) {
        key = (0, scalar_js_1.scalarZeroValue)(field.mapKey, false);
      }
      if (val === void 0) {
        switch (field.mapKind) {
          case "scalar":
            val = (0, scalar_js_1.scalarZeroValue)(field.scalar, false);
            break;
          case "enum":
            val = field.enum.values[0].number;
            break;
          case "message":
            val = (0, reflect_js_1.reflect)(field.message, void 0, false);
            break;
        }
      }
      map.set(key, val);
    }
    function readListField(reader, wireType, list, options) {
      var _a;
      const field = list.field();
      if (field.listKind === "message") {
        list.add(readMessageField(reader, options, field));
        return;
      }
      const scalarType = (_a = field.scalar) !== null && _a !== void 0 ? _a : descriptors_js_1.ScalarType.INT32;
      const packed = wireType == binary_encoding_js_1.WireType.LengthDelimited && scalarType != descriptors_js_1.ScalarType.STRING && scalarType != descriptors_js_1.ScalarType.BYTES;
      if (!packed) {
        list.add(readScalar(reader, scalarType));
        return;
      }
      const e = reader.uint32() + reader.pos;
      while (reader.pos < e) {
        list.add(readScalar(reader, scalarType));
      }
    }
    function readMessageField(reader, options, field, mergeMessage) {
      const delimited = field.delimitedEncoding;
      const message = mergeMessage !== null && mergeMessage !== void 0 ? mergeMessage : (0, reflect_js_1.reflect)(field.message, void 0, false);
      readMessage(message, reader, options, delimited, delimited ? field.number : reader.uint32());
      return message;
    }
    function readScalar(reader, type) {
      switch (type) {
        case descriptors_js_1.ScalarType.STRING:
          return reader.string();
        case descriptors_js_1.ScalarType.BOOL:
          return reader.bool();
        case descriptors_js_1.ScalarType.DOUBLE:
          return reader.double();
        case descriptors_js_1.ScalarType.FLOAT:
          return reader.float();
        case descriptors_js_1.ScalarType.INT32:
          return reader.int32();
        case descriptors_js_1.ScalarType.INT64:
          return reader.int64();
        case descriptors_js_1.ScalarType.UINT64:
          return reader.uint64();
        case descriptors_js_1.ScalarType.FIXED64:
          return reader.fixed64();
        case descriptors_js_1.ScalarType.BYTES:
          return reader.bytes();
        case descriptors_js_1.ScalarType.FIXED32:
          return reader.fixed32();
        case descriptors_js_1.ScalarType.SFIXED32:
          return reader.sfixed32();
        case descriptors_js_1.ScalarType.SFIXED64:
          return reader.sfixed64();
        case descriptors_js_1.ScalarType.SINT64:
          return reader.sint64();
        case descriptors_js_1.ScalarType.UINT32:
          return reader.uint32();
        case descriptors_js_1.ScalarType.SINT32:
          return reader.sint32();
      }
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/size-delimited.js
var require_size_delimited = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/size-delimited.js"(exports2) {
    "use strict";
    var __asyncValues = exports2 && exports2.__asyncValues || function(o) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var m = o[Symbol.asyncIterator], i;
      return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
      }, i);
      function verb(n) {
        i[n] = o[n] && function(v) {
          return new Promise(function(resolve, reject) {
            v = o[n](v), settle(resolve, reject, v.done, v.value);
          });
        };
      }
      function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v2) {
          resolve({ value: v2, done: d });
        }, reject);
      }
    };
    var __await = exports2 && exports2.__await || function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    var __asyncGenerator = exports2 && exports2.__asyncGenerator || function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i, q = [];
      return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
        return this;
      }, i;
      function awaitReturn(f) {
        return function(v) {
          return Promise.resolve(v).then(f, reject);
        };
      }
      function verb(n, f) {
        if (g[n]) {
          i[n] = function(v) {
            return new Promise(function(a, b) {
              q.push([n, v, a, b]) > 1 || resume(n, v);
            });
          };
          if (f) i[n] = f(i[n]);
        }
      }
      function resume(n, v) {
        try {
          step(g[n](v));
        } catch (e) {
          settle(q[0][3], e);
        }
      }
      function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
      }
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sizeDelimitedEncode = sizeDelimitedEncode;
    exports2.sizeDelimitedDecodeStream = sizeDelimitedDecodeStream;
    exports2.sizeDelimitedPeek = sizeDelimitedPeek;
    var to_binary_js_1 = require_to_binary();
    var binary_encoding_js_1 = require_binary_encoding();
    var from_binary_js_1 = require_from_binary();
    function sizeDelimitedEncode(messageDesc, message, options) {
      const writer = new binary_encoding_js_1.BinaryWriter();
      writer.bytes((0, to_binary_js_1.toBinary)(messageDesc, message, options));
      return writer.finish();
    }
    function sizeDelimitedDecodeStream(messageDesc, iterable, options) {
      return __asyncGenerator(this, arguments, function* sizeDelimitedDecodeStream_1() {
        var _a, e_1, _b, _c;
        function append(buffer2, chunk) {
          const n = new Uint8Array(buffer2.byteLength + chunk.byteLength);
          n.set(buffer2);
          n.set(chunk, buffer2.length);
          return n;
        }
        let buffer = new Uint8Array(0);
        try {
          for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), _a = iterable_1_1.done, !_a; _d = true) {
            _c = iterable_1_1.value;
            _d = false;
            const chunk = _c;
            buffer = append(buffer, chunk);
            for (; ; ) {
              const size = sizeDelimitedPeek(buffer);
              if (size.eof) {
                break;
              }
              if (size.offset + size.size > buffer.byteLength) {
                break;
              }
              yield yield __await((0, from_binary_js_1.fromBinary)(messageDesc, buffer.subarray(size.offset, size.offset + size.size), options));
              buffer = buffer.subarray(size.offset + size.size);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (!_d && !_a && (_b = iterable_1.return)) yield __await(_b.call(iterable_1));
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        if (buffer.byteLength > 0) {
          throw new Error("incomplete data");
        }
      });
    }
    function sizeDelimitedPeek(data) {
      const sizeEof = { eof: true, size: null, offset: null };
      for (let i = 0; i < 10; i++) {
        if (i > data.byteLength) {
          return sizeEof;
        }
        if ((data[i] & 128) == 0) {
          const reader = new binary_encoding_js_1.BinaryReader(data);
          let size;
          try {
            size = reader.uint32();
          } catch (e) {
            if (e instanceof RangeError) {
              return sizeEof;
            }
            throw e;
          }
          return {
            eof: false,
            size,
            offset: reader.pos
          };
        }
      }
      throw new Error("invalid varint");
    }
  }
});

// node_modules/@bufbuild/protobuf/dist/cjs/wire/index.js
var require_wire = __commonJS({
  "node_modules/@bufbuild/protobuf/dist/cjs/wire/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_binary_encoding(), exports2);
    __exportStar(require_base64_encoding(), exports2);
    __exportStar(require_text_encoding(), exports2);
    __exportStar(require_text_format(), exports2);
    __exportStar(require_size_delimited(), exports2);
  }
});

// node_modules/tiktok-live-connector/dist/types/tiktok-schema.js
var require_tiktok_schema = __commonJS({
  "node_modules/tiktok-live-connector/dist/types/tiktok-schema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProfitRankType = exports2.MessageDisplayStyle = exports2.GiftSource = exports2.ExhibitionType = exports2.GoalMessageSource = exports2.PerceptionDialogIconType = exports2.CommentTag = exports2.IconDisplayType = exports2.RenderType = exports2.ShowType = exports2.HorizontalOnclickTriggerType = exports2.GiftMessageIgnoreConfig = exports2.UserMetricsType = exports2.TopicActionType = exports2.TagType = exports2.GiftMessageVersion = exports2.LinkmicGiftExpressionStrategy = exports2.MultiplierType = exports2.PunishTypeId = exports2.EmoteScene = exports2.UserEmoteUploadSource = exports2.RewardCondition = exports2.Scene = exports2.MessageType = exports2.LinkMessageType = exports2.CommonContentCase = exports2.EnvelopeDisplay = exports2.EnvelopeFollowShowStatus = exports2.EnvelopeBusinessType = exports2.BarrageType = exports2.LinkLayerMessageType = exports2.ControlAction = exports2.MemberMessageAction = exports2.LinkmicStatus = exports2.SubscribingStatus = exports2.OldSubscribeStatus = exports2.SubscribeType = exports2.ReplyStatus = exports2.BusinessCase = exports2.GroupStatus = exports2.KickoutReason = exports2.AgreeStatus = exports2.HashtagNamespace = exports2.LinkmicApplierSortSetting = exports2.TextType = exports2.EmotePrivateType = exports2.ContentSource = exports2.EmoteType = exports2.AuditStatus = exports2.protobufPackage = void 0;
    exports2.BadgeStruct_VerticalPaddingRule = exports2.BadgeStruct_HorizontalPaddingRule = exports2.BadgeStruct_Position = exports2.BadgeStruct_BadgeExhibitionType = exports2.BadgeStruct_DisplayStatus = exports2.BadgeStruct_BadgeSceneType = exports2.BadgeStruct_BadgePriorityType = exports2.BadgeStruct_BadgeDisplayType = exports2.Text_ShowType = exports2.CommonMessageData_IMDispatchStrategy = exports2.BattleInviteType = exports2.BattleType = exports2.SourceType = exports2.TagClassification = exports2.CohostLayoutMode = exports2.JoinType = exports2.PosIdentityType = exports2.LinkmicShareRevenueSetting = exports2.ContentInviteSource = exports2.LinkUserType = exports2.MultiGuestOutsideRoomInviteSource = exports2.ContentPositionType = exports2.OptPairStatus = exports2.CohostABTestType = exports2.PollEndType = exports2.LinkmicMultiLiveEnum = exports2.LinkMicUserAdminType = exports2.GuestMicCameraChangeScene = exports2.GuestMicCameraManageOp = exports2.MuteStatus = exports2.LinkRoleType = exports2.LinkmicRoleType = exports2.LinkSilenceStatus = exports2.LinkType = exports2.PlayScene = exports2.BattleABTestType = exports2.GiftPermissionType = exports2.Result = exports2.BattleAction = exports2.RewardStatus = exports2.BattleTaskMessageType = exports2.Reason = exports2.TriggerReason = exports2.RankTestMessageScene = exports2.PollAppealStatus = exports2.PollTemplateStatus = exports2.PollKind = exports2.HitABStatus = exports2.DisplayStyle = exports2.UnionAnimationInfoType = void 0;
    exports2.Gift_GiftSponsorInfo = exports2.Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry = exports2.Gift_CrossScreenEffectInfo_ActionEffectIdsEntry = exports2.Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry = exports2.Gift_CrossScreenEffectInfo = exports2.Gift_BatchGiftInfo = exports2.Gift_GiftPanelBanner = exports2.Gift = exports2.BadgeStruct_PaddingInfo = exports2.BadgeStruct_StringBadge = exports2.BadgeStruct_IconConfig = exports2.BadgeStruct_TextBadge = exports2.BadgeStruct_ImageBadge = exports2.BadgeStruct_CombineBadgeBackground = exports2.BadgeStruct_ProfileCardPanel = exports2.BadgeStruct_NumberConfig = exports2.BadgeStruct_ProjectionConfig = exports2.BadgeStruct_ProfileContent = exports2.BadgeStruct_ArrowConfig = exports2.BadgeStruct_CombineBadge = exports2.BadgeStruct = exports2.Image_Content = exports2.Image = exports2.Text_PatternRef = exports2.Text_TextPieceUser = exports2.Text_TextPiecePatternRef = exports2.Text_TextPieceGift = exports2.Text_TextFormat = exports2.Text_TextPiece = exports2.Text = exports2.CommonMessageData_LiveMessageID = exports2.CommonMessageData_LiveMessageSEI = exports2.CommonMessageData = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result = exports2.WebcastBarrageMessage_IconDisplayType = exports2.WebcastBarrageMessage_RenderType = exports2.WebcastBarrageMessage_ShowType = exports2.WebcastBarrageMessage_BarrageType = exports2.WebcastMemberMessage_HitABStatus = exports2.WebcastMemberMessage_DisplayStyle = exports2.EmoteUploadInfo_UserEmoteUploadSource = exports2.WebcastChatMessage_CommentTag = exports2.Emote_AuditInfo_AuditTaskType = exports2.User_FansClub_FansClubData_UserFansClubStatus = exports2.User_FansClub_FansClubData_BadgeIcon = exports2.User_FansClub_PreferntialType = exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType = exports2.User_EcommerceEntrance_EntranceType = exports2.User_EcommerceEntrance_CreatorType = exports2.User_LiveEventInfo_EventPayMethod = void 0;
    exports2.TimeStampContainer = exports2.ValueLabel = exports2.TikTokColor = exports2.Ranking = exports2.LiveStreamGoalIndicator = exports2.LiveStreamGoal_GoalStats_GoalComparison = exports2.LiveStreamGoal_GoalStats = exports2.LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution = exports2.LiveStreamGoal_LiveStreamGoalContributor = exports2.LiveStreamGoal_LiveStreamSubGoalGift = exports2.LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo = exports2.LiveStreamGoal_LiveStreamSubGoal = exports2.LiveStreamGoal_AuditInfo = exports2.LiveStreamGoal = exports2.UserIdentity = exports2.MsgFilter = exports2.PunishEventInfo = exports2.Emote_EmoteUploadInfo = exports2.Emote_AuditInfo = exports2.Emote = exports2.User_UserStats = exports2.User_UserAttr = exports2.User_SubscribeInfo = exports2.User_SubscribeBadge = exports2.User_PayGrade = exports2.User_OwnRoom = exports2.User_FollowInfo = exports2.User_FansClubInfo = exports2.User_FansClub_FansClubData = exports2.User_FansClub = exports2.User_EcommerceEntrance_ShowcaseEntranceInfo = exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage = exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel = exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel = exports2.User_EcommerceEntrance_ShopEntranceInfo = exports2.User_EcommerceEntrance = exports2.User_ComboBadgeInfo = exports2.User_Border = exports2.User_AuthorStats = exports2.User_AuthenticationInfo = exports2.User_AnchorLevel = exports2.User_ActivityInfo = exports2.User_LiveEventInfo_WalletPackage = exports2.User_LiveEventInfo = exports2.User = exports2.Gift_GiftBoxInfo = exports2.Gift_GiftSkinToGiftTextsInfo = exports2.Gift_GiftText = exports2.Gift_GiftSkin = exports2.Gift_UGGiftStructInfo = void 0;
    exports2.Player = exports2.MultiLiveAnchorPanelSettings = exports2.LinkerWaitingListChangeContent = exports2.LinkerUpdateUserSettingContent = exports2.LinkerUpdateUserContent_UpdateInfoEntry = exports2.LinkerUpdateUserContent = exports2.LinkmicUserToastContent = exports2.LinkerSysKickOutContent = exports2.LinkerSetting = exports2.LinkerReplyContent_LinkmicInfo = exports2.LinkerReplyContent = exports2.LinkerRandomMatchContent = exports2.LinkerMuteContent = exports2.LinkerMicIdxUpdateContent = exports2.LinkerMediaChangeContent_LinkerMediaChangeOperator = exports2.LinkerMediaChangeContent = exports2.LinkerListChangeContent = exports2.CohostListChangeContent = exports2.LinkerLinkedListChangeContent = exports2.LinkerLeaveContent = exports2.LinkerKickOutContent = exports2.CohostTopic = exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser = exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo = exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag = exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo = exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra = exports2.LinkerInviteContent_LinkerInviteMessageExtra = exports2.LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest = exports2.LinkerInviteContent_CohostABTestSetting_CohostABTestList = exports2.LinkerInviteContent_CohostABTestSetting = exports2.LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption = exports2.LinkerInviteContent_PerceptionDialogInfo = exports2.LinkerInviteContent_LinkmicUserInfo = exports2.LinkerInviteContent_InviteTopHostInfo = exports2.LinkerInviteContent_RtcExtInfoMapEntry = exports2.LinkerInviteContent = exports2.LinkerEnterContent = exports2.LinkerCreateContent = exports2.LinkerCloseContent = exports2.ListUser = exports2.LinkerCancelContent = exports2.LinkerAcceptNoticeContent = exports2.FanTicketRoomNoticeContent = exports2.UserFanTicket = exports2.PollUpdateVotesContent = exports2.VoteUser = exports2.PollOptionInfo = exports2.PollEndContent = exports2.PollStartContent = void 0;
    exports2.BusinessContent_ListChangeBizContent_UserInfosEntry = exports2.BusinessContent_ListChangeBizContent = exports2.BusinessContent_PermitJoinGroupBizContent = exports2.BusinessContent_CohostContent = exports2.BusinessContent = exports2.GroupChangeContent = exports2.P2PGroupChangeContent = exports2.CancelJoinGroupContent = exports2.MigrationDetails = exports2.PermitJoinGroupContent = exports2.LeaveJoinGroupContent = exports2.JoinDirectContent = exports2.FinishChannelContent = exports2.LeaveContent = exports2.CancelInviteContent = exports2.CancelApplyContent = exports2.PosIdentity = exports2.KickOutContent = exports2.ReplyInviteContent = exports2.PermitApplyContent = exports2.ApplyContent = exports2.InviteContent = exports2.MultiLiveContent_KickOutBizContent = exports2.MultiLiveContent_PermitBizContent = exports2.MultiLiveContent_ReplyBizContent = exports2.MultiLiveContent_InviteBizContent = exports2.MultiLiveContent_JoinDirectBizContent = exports2.MultiLiveContent_ApplyBizContent = exports2.MultiLiveContent = exports2.MicPositionData = exports2.ContentPosition = exports2.ListChangeContent = exports2.CreateChannelContent = exports2.RTCExtraInfo_RTCBitrateMap = exports2.RTCExtraInfo_RTCVideoParam = exports2.RTCExtraInfo_RTCLiveVideoParam = exports2.RTCExtraInfo_RTCEngineConfig = exports2.RTCExtraInfo_RTCOther = exports2.RTCExtraInfo_RTCInfoExtra = exports2.RTCExtraInfo_ByteRTCExtInfo = exports2.RTCExtraInfo_RTCMixBase = exports2.RTCExtraInfo = exports2.GroupChannelUser = exports2.GroupChannelAllUser = exports2.DSLConfig = exports2.GroupPlayer = exports2.LinkPosition = exports2.Position = exports2.LinkLayerListUser = exports2.AllListUser = void 0;
    exports2.WebsocketParam = exports2.Message = exports2.WebcastPushFrame_HeadersEntry = exports2.WebcastPushFrame = exports2.HeartbeatMessage = exports2.HighScoreControlCfg = exports2.BattleUserArmy = exports2.BattleUserArmies = exports2.BattleTeamUserArmies = exports2.BattleSetting = exports2.BattleTeamUser = exports2.GiftModeMeta = exports2.PublicAreaMessageCommon_UserInteractionInfo = exports2.PublicAreaMessageCommon_PortraitInfo = exports2.PublicAreaMessageCommon_PortraitTag = exports2.PublicAreaMessageCommon_UserMetrics = exports2.PublicAreaMessageCommon_CreatorSuccessInfo = exports2.PublicAreaMessageCommon_Topic = exports2.PublicAreaMessageCommon_TagItem = exports2.PublicAreaMessageCommon = exports2.PublicAreaCommon = exports2.Author = exports2.FansClubData_UserBadge_IconsEntry = exports2.FansClubData_UserBadge = exports2.FansClubData = exports2.FansClubMember_PreferDataEntry = exports2.FansClubMember = exports2.BorderInfo = exports2.GradeIcon = exports2.UserHonor = exports2.FontStyle = exports2.PrivilegeLogExtra = exports2.JoinGroupContent = exports2.BusinessContent_TopHostInfo = exports2.BusinessContent_Hashtag = exports2.BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo = exports2.BusinessContent_JoinGroupMessageExtra_RivalExtra = exports2.BusinessContent_JoinGroupMessageExtra = exports2.BusinessContent_PerceptionFeedbackOption = exports2.BusinessContent_PerceptionDialogInfo = exports2.BusinessContent_Tag = exports2.BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent = exports2.BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent = exports2.BusinessContent_JoinGroupBizContent_TagV2_UserInfo = exports2.BusinessContent_JoinGroupBizContent_TagV2 = exports2.BusinessContent_JoinGroupBizContent_RivalsGameTag = exports2.BusinessContent_JoinGroupBizContent = exports2.BusinessContent_CohostUserInfo_CohostStreamConfig = exports2.BusinessContent_CohostUserInfo = exports2.BusinessContent_ListChangeBizContent_VirtualWaitingUser = void 0;
    exports2.WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation = exports2.WebcastLinkMicBattle_TeamMatchCampaign = exports2.WebcastLinkMicBattle_BattleCombosEntry = exports2.WebcastLinkMicBattle_AnchorInfoEntry = exports2.WebcastLinkMicBattle_ArmiesEntry = exports2.WebcastLinkMicBattle_BattleResultEntry = exports2.WebcastLinkMicBattle = exports2.WebcastGiftMessage_SponsorshipInfo = exports2.WebcastGiftMessage_FlyingMicResources_TransitionConfig = exports2.WebcastGiftMessage_FlyingMicResources = exports2.WebcastGiftMessage_LynxGiftExtra = exports2.WebcastGiftMessage_AssetsModel_FaceRecognitionMeta = exports2.WebcastGiftMessage_AssetsModel_VideoResource = exports2.WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize = exports2.WebcastGiftMessage_AssetsModel_LokiExtraContent = exports2.WebcastGiftMessage_AssetsModel_ResourceModel = exports2.WebcastGiftMessage_AssetsModel_AssetExtra = exports2.WebcastGiftMessage_AssetsModel = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox = exports2.WebcastGiftMessage_GiftsBoxInfo = exports2.WebcastGiftMessage_MatchInfo = exports2.WebcastGiftMessage_GiftMonitorInfo = exports2.WebcastGiftMessage_GiftTrayInfo = exports2.WebcastGiftMessage_TextEffect_Detail = exports2.WebcastGiftMessage_TextEffect = exports2.WebcastGiftMessage_GiftIMPriority = exports2.WebcastGiftMessage_InteractiveGiftInfo = exports2.WebcastGiftMessage = exports2.WebcastMemberMessage_EffectConfigBean = exports2.WebcastMemberMessage_WaveAlgorithmData = exports2.WebcastMemberMessage_EffectConfig = exports2.WebcastMemberMessage_AdminPermissionsEntry = exports2.WebcastMemberMessage = exports2.WebcastSubEmote = exports2.WebcastEmoteChatMessage = exports2.EmoteUploadInfo = exports2.WebcastChatMessage_CommentQualityScore = exports2.WebcastChatMessage_UserIdentity = exports2.WebcastChatMessage = exports2.ImageModel_Content = exports2.ImageModel = exports2.WebcastRoomUserSeqMessage_Contributor = exports2.WebcastRoomUserSeqMessage = void 0;
    exports2.WebcastBarrageMessage_AnimationData = exports2.WebcastBarrageMessage_BarrageTypeSubscribeGiftParam = exports2.WebcastBarrageMessage_BarrageTypeFansLevelParam = exports2.WebcastBarrageMessage_BarrageTypeUserGradeParam = exports2.WebcastBarrageMessage_BarrageEvent_ParamsEntry = exports2.WebcastBarrageMessage_BarrageEvent = exports2.WebcastBarrageMessage = exports2.UserImageBadgeImage = exports2.UserImageBadge = exports2.UserBadge = exports2.UserBadgesAttributes = exports2.ProfilePicture = exports2.FollowInfo = exports2.TreasureBoxData = exports2.WebcastEnvelopeMessage_EnvelopeInfo = exports2.WebcastEnvelopeMessage = exports2.EmoteImage = exports2.EmoteDetails = exports2.WebcastHourlyRankMessage_RankContainer_RankingData2 = exports2.WebcastHourlyRankMessage_RankContainer_RankingData = exports2.WebcastHourlyRankMessage_RankContainer = exports2.WebcastHourlyRankMessage = exports2.RankItem = exports2.SystemMessage = exports2.WebcastLiveIntroMessage = exports2.WebcastMessageEventDetails = exports2.WebcastQuestionNewMessage_Question = exports2.WebcastQuestionNewMessage = exports2.LikeEffect = exports2.SpecifiedDisplayText = exports2.WebcastLikeMessage = exports2.WebcastSocialMessage = exports2.WebcastLinkMicArmiesGroup = exports2.WebcastLinkMicArmiesItems = exports2.WebcastLinkMicArmies_BattleItemsEntry = exports2.WebcastLinkMicArmies = exports2.WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest = exports2.WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList = exports2.WebcastLinkMicBattle_BattleABTestSetting = exports2.WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag = exports2.WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo = exports2.WebcastLinkMicBattle_BattleUserInfo = exports2.WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy = exports2.WebcastLinkMicBattle_BattleDisplayConfig = exports2.WebcastLinkMicBattle_BattleResult = exports2.WebcastLinkMicBattle_BattleComboInfo = exports2.WebcastLinkMicBattle_TeamUsersInfo = exports2.WebcastLinkMicBattle_SupportedActionsWrapper = exports2.WebcastLinkMicBattle_BattleInviteeGiftPermission = exports2.WebcastLinkMicBattle_BattleTeamResult = void 0;
    exports2.WebcastMsgDetectMessage_TimeInfo = exports2.WebcastMsgDetectMessage = exports2.WebcastUnauthorizedMemberMessage = exports2.WebcastLinkMicMethod = exports2.WebcastLinkMicFanTicketMethod = exports2.WebcastLinkmicBattleTaskMessage_BattleRewardSettle = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskSettle = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskUpdate = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart = exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem = exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt = exports2.WebcastLinkmicBattleTaskMessage = exports2.WebcastLinkMicBattlePunishFinish = exports2.WebcastRankTextMessage = exports2.WebcastPollMessage_PollBasicInfo = exports2.WebcastPollMessage_TemplateContent = exports2.WebcastPollMessage = exports2.WebcastRankUpdateMessage_RankUpdate = exports2.WebcastRankUpdateMessage_RankTabInfo = exports2.WebcastRankUpdateMessage_RankListTabInfo = exports2.WebcastRankUpdateMessage_UnionAnimationInfo = exports2.WebcastRankUpdateMessage = exports2.WebcastInRoomBannerMessage = exports2.WebcastImDeleteMessage = exports2.WebcastGoalUpdateMessage_GoalPinInfo = exports2.WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo = exports2.WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift = exports2.WebcastGoalUpdateMessage_LiveStreamSubGoal = exports2.WebcastGoalUpdateMessage = exports2.WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption = exports2.WebcastControlMessage_PerceptionDialogInfo = exports2.WebcastControlMessage_Extra = exports2.WebcastControlMessage = exports2.WebcastCaptionMessage_CaptionContent = exports2.WebcastCaptionMessage = exports2.WebcastRoomMessage = exports2.BaseProtoMessage = exports2.ProtoMessageFetchResult_WsParamsEntry = exports2.ProtoMessageFetchResult = exports2.WebcastBarrageMessage_RightLabel = exports2.WebcastBarrageMessage_DisplayControl_ShowResult = exports2.WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry = exports2.WebcastBarrageMessage_DisplayControl = exports2.WebcastBarrageMessage_BarrageTypeGiftGalleryParam = void 0;
    exports2.WebcastImEnterRoomMessage = exports2.WebcastBarrageMessageOld_TextPieceUser = exports2.WebcastBarrageMessageOld_TextPiece = exports2.WebcastBarrageMessageOld_Text = exports2.WebcastBarrageMessageOld = exports2.RoomVerifyMessage = exports2.WebcastLinkLayerMessage = exports2.WebcastLinkMessage = exports2.WebcastRoomPinMessage = exports2.WebcastOecLiveShoppingMessage_LiveShoppingDetails = exports2.WebcastOecLiveShoppingMessage_LiveShoppingData = exports2.WebcastOecLiveShoppingMessage = exports2.WebcastMsgDetectMessage_TriggerCondition = void 0;
    var wire_1 = require_wire();
    exports2.protobufPackage = "TikTok";
    var AuditStatus;
    (function(AuditStatus2) {
      AuditStatus2[AuditStatus2["AUDITSTATUSUNKNOWN"] = 0] = "AUDITSTATUSUNKNOWN";
      AuditStatus2[AuditStatus2["AUDITSTATUSPASS"] = 1] = "AUDITSTATUSPASS";
      AuditStatus2[AuditStatus2["AUDITSTATUSFAILED"] = 2] = "AUDITSTATUSFAILED";
      AuditStatus2[AuditStatus2["AUDITSTATUSREVIEWING"] = 3] = "AUDITSTATUSREVIEWING";
      AuditStatus2[AuditStatus2["AUDITSTATUSFORBIDDEN"] = 4] = "AUDITSTATUSFORBIDDEN";
      AuditStatus2[AuditStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(AuditStatus = exports2.AuditStatus || (exports2.AuditStatus = {}));
    var EmoteType;
    (function(EmoteType2) {
      EmoteType2[EmoteType2["EMOTETYPENORMAL"] = 0] = "EMOTETYPENORMAL";
      EmoteType2[EmoteType2["EMOTETYPEWITHSTICKER"] = 1] = "EMOTETYPEWITHSTICKER";
      EmoteType2[EmoteType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(EmoteType = exports2.EmoteType || (exports2.EmoteType = {}));
    var ContentSource;
    (function(ContentSource2) {
      ContentSource2[ContentSource2["CONTENTSOURCEUNKNOWN"] = 0] = "CONTENTSOURCEUNKNOWN";
      ContentSource2[ContentSource2["CONTENTSOURCENORMAL"] = 1] = "CONTENTSOURCENORMAL";
      ContentSource2[ContentSource2["CONTENTSOURCECAMERA"] = 2] = "CONTENTSOURCECAMERA";
      ContentSource2[ContentSource2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ContentSource = exports2.ContentSource || (exports2.ContentSource = {}));
    var EmotePrivateType;
    (function(EmotePrivateType2) {
      EmotePrivateType2[EmotePrivateType2["EMOTE_PRIVATE_TYPE_NORMAL"] = 0] = "EMOTE_PRIVATE_TYPE_NORMAL";
      EmotePrivateType2[EmotePrivateType2["EMOTE_PRIVATE_TYPE_SUB_WAVE"] = 1] = "EMOTE_PRIVATE_TYPE_SUB_WAVE";
      EmotePrivateType2[EmotePrivateType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(EmotePrivateType = exports2.EmotePrivateType || (exports2.EmotePrivateType = {}));
    var TextType;
    (function(TextType2) {
      TextType2[TextType2["DISPLAY_TEXT"] = 0] = "DISPLAY_TEXT";
      TextType2[TextType2["CONTENT"] = 1] = "CONTENT";
      TextType2[TextType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(TextType = exports2.TextType || (exports2.TextType = {}));
    var LinkmicApplierSortSetting;
    (function(LinkmicApplierSortSetting2) {
      LinkmicApplierSortSetting2[LinkmicApplierSortSetting2["LINKMIC_APPLIER_SORT_SETTING_NONE"] = 0] = "LINKMIC_APPLIER_SORT_SETTING_NONE";
      LinkmicApplierSortSetting2[LinkmicApplierSortSetting2["LINKMIC_APPLIER_SORT_SETTING_BY_GIFT_SCORE"] = 1] = "LINKMIC_APPLIER_SORT_SETTING_BY_GIFT_SCORE";
      LinkmicApplierSortSetting2[LinkmicApplierSortSetting2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LinkmicApplierSortSetting = exports2.LinkmicApplierSortSetting || (exports2.LinkmicApplierSortSetting = {}));
    var HashtagNamespace;
    (function(HashtagNamespace2) {
      HashtagNamespace2[HashtagNamespace2["GLOBAL"] = 0] = "GLOBAL";
      HashtagNamespace2[HashtagNamespace2["GAMING"] = 1] = "GAMING";
      HashtagNamespace2[HashtagNamespace2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(HashtagNamespace = exports2.HashtagNamespace || (exports2.HashtagNamespace = {}));
    var AgreeStatus;
    (function(AgreeStatus2) {
      AgreeStatus2[AgreeStatus2["AGREE_UNKNOWN"] = 0] = "AGREE_UNKNOWN";
      AgreeStatus2[AgreeStatus2["AGREE"] = 1] = "AGREE";
      AgreeStatus2[AgreeStatus2["REJECT"] = 2] = "REJECT";
      AgreeStatus2[AgreeStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(AgreeStatus = exports2.AgreeStatus || (exports2.AgreeStatus = {}));
    var KickoutReason;
    (function(KickoutReason2) {
      KickoutReason2[KickoutReason2["KICKOUT_REASON_UNKNOWN"] = 0] = "KICKOUT_REASON_UNKNOWN";
      KickoutReason2[KickoutReason2["KICKOUT_REASON_FIRST_FRAME_TIMEOUT"] = 1] = "KICKOUT_REASON_FIRST_FRAME_TIMEOUT";
      KickoutReason2[KickoutReason2["KICKOUT_REASON_BY_HOST"] = 2] = "KICKOUT_REASON_BY_HOST";
      KickoutReason2[KickoutReason2["KICKOUT_REASON_RTC_LOST_CONNECTION"] = 3] = "KICKOUT_REASON_RTC_LOST_CONNECTION";
      KickoutReason2[KickoutReason2["KICKOUT_REASON_BY_PUNISH"] = 4] = "KICKOUT_REASON_BY_PUNISH";
      KickoutReason2[KickoutReason2["KICKOUT_REASON_BY_ADMIN"] = 5] = "KICKOUT_REASON_BY_ADMIN";
      KickoutReason2[KickoutReason2["KICKOUT_REASON_HOST_REMOVE_ALL_GUESTS"] = 6] = "KICKOUT_REASON_HOST_REMOVE_ALL_GUESTS";
      KickoutReason2[KickoutReason2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(KickoutReason = exports2.KickoutReason || (exports2.KickoutReason = {}));
    var GroupStatus;
    (function(GroupStatus2) {
      GroupStatus2[GroupStatus2["GROUP_STATUS_UNKNOWN"] = 0] = "GROUP_STATUS_UNKNOWN";
      GroupStatus2[GroupStatus2["GROUP_STATUS_WAITING"] = 1] = "GROUP_STATUS_WAITING";
      GroupStatus2[GroupStatus2["GROUP_STATUS_LINKED"] = 3] = "GROUP_STATUS_LINKED";
      GroupStatus2[GroupStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(GroupStatus = exports2.GroupStatus || (exports2.GroupStatus = {}));
    var BusinessCase;
    (function(BusinessCase2) {
      BusinessCase2[BusinessCase2["BUSINESS_NOT_SET"] = 0] = "BUSINESS_NOT_SET";
      BusinessCase2[BusinessCase2["APPLY_BIZ_CONTENT"] = 1] = "APPLY_BIZ_CONTENT";
      BusinessCase2[BusinessCase2["INVITE_BIZ_CONTENT"] = 2] = "INVITE_BIZ_CONTENT";
      BusinessCase2[BusinessCase2["REPLY_BIZ_CONTENT"] = 3] = "REPLY_BIZ_CONTENT";
      BusinessCase2[BusinessCase2["PERMIT_BIZ_CONTENT"] = 4] = "PERMIT_BIZ_CONTENT";
      BusinessCase2[BusinessCase2["JOIN_DIRECT_BIZ_CONTENT"] = 5] = "JOIN_DIRECT_BIZ_CONTENT";
      BusinessCase2[BusinessCase2["KICK_OUT_BIZ_CONTENT"] = 6] = "KICK_OUT_BIZ_CONTENT";
      BusinessCase2[BusinessCase2["LIST_CHANGE_BIZ_CONTENT"] = 11] = "LIST_CHANGE_BIZ_CONTENT";
      BusinessCase2[BusinessCase2["MULTI_LIVE_CONTENT"] = 100] = "MULTI_LIVE_CONTENT";
      BusinessCase2[BusinessCase2["COHOST_CONTENT"] = 200] = "COHOST_CONTENT";
      BusinessCase2[BusinessCase2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BusinessCase = exports2.BusinessCase || (exports2.BusinessCase = {}));
    var ReplyStatus;
    (function(ReplyStatus2) {
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_UNKNOWN"] = 0] = "REPLY_STATUS_UNKNOWN";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_AGREE"] = 1] = "REPLY_STATUS_AGREE";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_PERSONALLY"] = 2] = "REPLY_STATUS_REFUSE_PERSONALLY";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_TYPE_NOT_SUPPORT"] = 3] = "REPLY_STATUS_REFUSE_TYPE_NOT_SUPPORT";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_PROCESSING_INVITATION"] = 4] = "REPLY_STATUS_REFUSE_PROCESSING_INVITATION";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_BY_TIMEOUT"] = 5] = "REPLY_STATUS_REFUSE_BY_TIMEOUT";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_EXCEPTION"] = 6] = "REPLY_STATUS_REFUSE_EXCEPTION";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_SYSTEM_NOT_SUPPORTED"] = 7] = "REPLY_STATUS_REFUSE_SYSTEM_NOT_SUPPORTED";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_SUBTYPE_DIFFERENCE"] = 8] = "REPLY_STATUS_REFUSE_SUBTYPE_DIFFERENCE";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_IN_MICROOM"] = 9] = "REPLY_STATUS_REFUSE_IN_MICROOM";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_NOT_LOAD_PLUGIN"] = 10] = "REPLY_STATUS_REFUSE_NOT_LOAD_PLUGIN";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_IN_MULTI_GUEST"] = 11] = "REPLY_STATUS_REFUSE_IN_MULTI_GUEST";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_PAUSE_LIVE"] = 12] = "REPLY_STATUS_REFUSE_PAUSE_LIVE";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_OPEN_CAMERA_DIALOG_SHOWING"] = 13] = "REPLY_STATUS_REFUSE_OPEN_CAMERA_DIALOG_SHOWING";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_DRAW_GUESSING"] = 14] = "REPLY_STATUS_REFUSE_DRAW_GUESSING";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_RANDOM_MATCHING"] = 15] = "REPLY_STATUS_REFUSE_RANDOM_MATCHING";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_IN_MATCH_PROCESSING"] = 16] = "REPLY_STATUS_REFUSE_IN_MATCH_PROCESSING";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_IN_MICROOM_FOR_MULTI_COHOST"] = 17] = "REPLY_STATUS_REFUSE_IN_MICROOM_FOR_MULTI_COHOST";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_COHOST_FINISHED"] = 18] = "REPLY_STATUS_REFUSE_COHOST_FINISHED";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_NOT_CONNECTED"] = 19] = "REPLY_STATUS_REFUSE_NOT_CONNECTED";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_LINKMIC_FULL"] = 20] = "REPLY_STATUS_REFUSE_LINKMIC_FULL";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_ARC_INCOMPATIBLE"] = 21] = "REPLY_STATUS_REFUSE_ARC_INCOMPATIBLE";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_PROCESSING_OTHER_INVITE"] = 22] = "REPLY_STATUS_REFUSE_PROCESSING_OTHER_INVITE";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_PROCESSING_OTHER_APPLY"] = 23] = "REPLY_STATUS_REFUSE_PROCESSING_OTHER_APPLY";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_IN_ANCHOR_COHOST"] = 24] = "REPLY_STATUS_REFUSE_IN_ANCHOR_COHOST";
      ReplyStatus2[ReplyStatus2["REPLY_STATUS_REFUSE_TOPIC_PAIRING"] = 25] = "REPLY_STATUS_REFUSE_TOPIC_PAIRING";
      ReplyStatus2[ReplyStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ReplyStatus = exports2.ReplyStatus || (exports2.ReplyStatus = {}));
    var SubscribeType;
    (function(SubscribeType2) {
      SubscribeType2[SubscribeType2["SUBSCRIBETYPE_ONCE"] = 0] = "SUBSCRIBETYPE_ONCE";
      SubscribeType2[SubscribeType2["SUBSCRIBETYPE_AUTO"] = 1] = "SUBSCRIBETYPE_AUTO";
      SubscribeType2[SubscribeType2["SUBSCRIBETYPE_DEFAULT"] = 100] = "SUBSCRIBETYPE_DEFAULT";
      SubscribeType2[SubscribeType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SubscribeType = exports2.SubscribeType || (exports2.SubscribeType = {}));
    var OldSubscribeStatus;
    (function(OldSubscribeStatus2) {
      OldSubscribeStatus2[OldSubscribeStatus2["OLD_SUBSCRIBE_STATUS_FIRST"] = 0] = "OLD_SUBSCRIBE_STATUS_FIRST";
      OldSubscribeStatus2[OldSubscribeStatus2["OLD_SUBSCRIBE_STATUS_RESUB"] = 1] = "OLD_SUBSCRIBE_STATUS_RESUB";
      OldSubscribeStatus2[OldSubscribeStatus2["OLD_SUBSCRIBE_STATUS_SUBIN_GRACE_PERIOD"] = 2] = "OLD_SUBSCRIBE_STATUS_SUBIN_GRACE_PERIOD";
      OldSubscribeStatus2[OldSubscribeStatus2["OLD_SUBSCRIBE_STATUS_SUB_NOTIN_GRACE_PERIOD"] = 3] = "OLD_SUBSCRIBE_STATUS_SUB_NOTIN_GRACE_PERIOD";
      OldSubscribeStatus2[OldSubscribeStatus2["OLD_SUBSCRIBE_STATUS_DEFAULT"] = 100] = "OLD_SUBSCRIBE_STATUS_DEFAULT";
      OldSubscribeStatus2[OldSubscribeStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(OldSubscribeStatus = exports2.OldSubscribeStatus || (exports2.OldSubscribeStatus = {}));
    var SubscribingStatus;
    (function(SubscribingStatus2) {
      SubscribingStatus2[SubscribingStatus2["SUBSCRIBING_STATUS_UNKNOWN"] = 0] = "SUBSCRIBING_STATUS_UNKNOWN";
      SubscribingStatus2[SubscribingStatus2["SUBSCRIBING_STATUS_ONCE"] = 1] = "SUBSCRIBING_STATUS_ONCE";
      SubscribingStatus2[SubscribingStatus2["SUBSCRIBING_STATUS_CIRCLE"] = 2] = "SUBSCRIBING_STATUS_CIRCLE";
      SubscribingStatus2[SubscribingStatus2["SUBSCRIBING_STATUS_CIRCLE_CANCEL"] = 3] = "SUBSCRIBING_STATUS_CIRCLE_CANCEL";
      SubscribingStatus2[SubscribingStatus2["SUBSCRIBING_STATUS_REFUND"] = 4] = "SUBSCRIBING_STATUS_REFUND";
      SubscribingStatus2[SubscribingStatus2["SUBSCRIBING_STATUS_IN_GRACE_PERIOD"] = 5] = "SUBSCRIBING_STATUS_IN_GRACE_PERIOD";
      SubscribingStatus2[SubscribingStatus2["SUBSCRIBING_STATUS_NOT_IN_GRACE_PERIOD"] = 6] = "SUBSCRIBING_STATUS_NOT_IN_GRACE_PERIOD";
      SubscribingStatus2[SubscribingStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SubscribingStatus = exports2.SubscribingStatus || (exports2.SubscribingStatus = {}));
    var LinkmicStatus;
    (function(LinkmicStatus2) {
      LinkmicStatus2[LinkmicStatus2["Disable"] = 0] = "Disable";
      LinkmicStatus2[LinkmicStatus2["Enable"] = 1] = "Enable";
      LinkmicStatus2[LinkmicStatus2["Just_Following"] = 2] = "Just_Following";
      LinkmicStatus2[LinkmicStatus2["Multi_Linking"] = 3] = "Multi_Linking";
      LinkmicStatus2[LinkmicStatus2["Multi_Linking_Only_Following"] = 4] = "Multi_Linking_Only_Following";
      LinkmicStatus2[LinkmicStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LinkmicStatus = exports2.LinkmicStatus || (exports2.LinkmicStatus = {}));
    var MemberMessageAction;
    (function(MemberMessageAction2) {
      MemberMessageAction2[MemberMessageAction2["UNKNOWN"] = 0] = "UNKNOWN";
      MemberMessageAction2[MemberMessageAction2["JOINED"] = 1] = "JOINED";
      MemberMessageAction2[MemberMessageAction2["SUBSCRIBED"] = 3] = "SUBSCRIBED";
      MemberMessageAction2[MemberMessageAction2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(MemberMessageAction = exports2.MemberMessageAction || (exports2.MemberMessageAction = {}));
    var ControlAction;
    (function(ControlAction2) {
      ControlAction2[ControlAction2["CONTROL_ACTION_FALLBACK_UNKNOWN"] = 0] = "CONTROL_ACTION_FALLBACK_UNKNOWN";
      ControlAction2[ControlAction2["CONTROL_ACTION_STREAM_PAUSED"] = 1] = "CONTROL_ACTION_STREAM_PAUSED";
      ControlAction2[ControlAction2["CONTROL_ACTION_STREAM_UNPAUSED"] = 2] = "CONTROL_ACTION_STREAM_UNPAUSED";
      ControlAction2[ControlAction2["CONTROL_ACTION_STREAM_ENDED"] = 3] = "CONTROL_ACTION_STREAM_ENDED";
      ControlAction2[ControlAction2["CONTROL_ACTION_STREAM_SUSPENDED"] = 4] = "CONTROL_ACTION_STREAM_SUSPENDED";
      ControlAction2[ControlAction2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ControlAction = exports2.ControlAction || (exports2.ControlAction = {}));
    var LinkLayerMessageType;
    (function(LinkLayerMessageType2) {
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Unknown"] = 0] = "Linker_Unknown";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Create"] = 1] = "Linker_Create";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Invite"] = 2] = "Linker_Invite";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Apply"] = 3] = "Linker_Apply";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Permit"] = 4] = "Linker_Permit";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Reply"] = 5] = "Linker_Reply";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Kick_Out"] = 6] = "Linker_Kick_Out";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Cancel_Apply"] = 7] = "Linker_Cancel_Apply";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Cancel_Invite"] = 8] = "Linker_Cancel_Invite";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Leave"] = 9] = "Linker_Leave";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Finish"] = 10] = "Linker_Finish";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_List_Change"] = 11] = "Linker_List_Change";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Join_Direct"] = 12] = "Linker_Join_Direct";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Join_Group"] = 13] = "Linker_Join_Group";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Permit_Group"] = 14] = "Linker_Permit_Group";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Cancel_Group"] = 15] = "Linker_Cancel_Group";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Leave_Group"] = 16] = "Linker_Leave_Group";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_P2P_Group_Change"] = 17] = "Linker_P2P_Group_Change";
      LinkLayerMessageType2[LinkLayerMessageType2["Linker_Group_Change"] = 18] = "Linker_Group_Change";
      LinkLayerMessageType2[LinkLayerMessageType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LinkLayerMessageType = exports2.LinkLayerMessageType || (exports2.LinkLayerMessageType = {}));
    var BarrageType;
    (function(BarrageType2) {
      BarrageType2[BarrageType2["BarrageType_Unknown"] = 0] = "BarrageType_Unknown";
      BarrageType2[BarrageType2["EComOrdering"] = 1] = "EComOrdering";
      BarrageType2[BarrageType2["EComBuying"] = 2] = "EComBuying";
      BarrageType2[BarrageType2["Normal"] = 3] = "Normal";
      BarrageType2[BarrageType2["Subscribe"] = 4] = "Subscribe";
      BarrageType2[BarrageType2["EventView"] = 5] = "EventView";
      BarrageType2[BarrageType2["EventRegistered"] = 6] = "EventRegistered";
      BarrageType2[BarrageType2["SubscribeGift"] = 7] = "SubscribeGift";
      BarrageType2[BarrageType2["UserUpgrade"] = 8] = "UserUpgrade";
      BarrageType2[BarrageType2["GradeUserEntranceNotification"] = 9] = "GradeUserEntranceNotification";
      BarrageType2[BarrageType2["FansLevelUpgrade"] = 10] = "FansLevelUpgrade";
      BarrageType2[BarrageType2["FansLevelEntrance"] = 11] = "FansLevelEntrance";
      BarrageType2[BarrageType2["GamePartnership"] = 12] = "GamePartnership";
      BarrageType2[BarrageType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BarrageType = exports2.BarrageType || (exports2.BarrageType = {}));
    var EnvelopeBusinessType;
    (function(EnvelopeBusinessType2) {
      EnvelopeBusinessType2[EnvelopeBusinessType2["BusinessTypeUnknown"] = 0] = "BusinessTypeUnknown";
      EnvelopeBusinessType2[EnvelopeBusinessType2["BusinessTypeUserDiamond"] = 1] = "BusinessTypeUserDiamond";
      EnvelopeBusinessType2[EnvelopeBusinessType2["BusinessTypePlatformDiamond"] = 2] = "BusinessTypePlatformDiamond";
      EnvelopeBusinessType2[EnvelopeBusinessType2["BusinessTypePlatformShell"] = 3] = "BusinessTypePlatformShell";
      EnvelopeBusinessType2[EnvelopeBusinessType2["BusinessTypePortal"] = 4] = "BusinessTypePortal";
      EnvelopeBusinessType2[EnvelopeBusinessType2["BusinessTypePlatformMerch"] = 5] = "BusinessTypePlatformMerch";
      EnvelopeBusinessType2[EnvelopeBusinessType2["BusinessTypeEoYDiamond"] = 6] = "BusinessTypeEoYDiamond";
      EnvelopeBusinessType2[EnvelopeBusinessType2["BusinessTypeFanClubGtM"] = 7] = "BusinessTypeFanClubGtM";
      EnvelopeBusinessType2[EnvelopeBusinessType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(EnvelopeBusinessType = exports2.EnvelopeBusinessType || (exports2.EnvelopeBusinessType = {}));
    var EnvelopeFollowShowStatus;
    (function(EnvelopeFollowShowStatus2) {
      EnvelopeFollowShowStatus2[EnvelopeFollowShowStatus2["ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_SHOW_UNKNOWN"] = 0] = "ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_SHOW_UNKNOWN";
      EnvelopeFollowShowStatus2[EnvelopeFollowShowStatus2["ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_SHOW"] = 1] = "ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_SHOW";
      EnvelopeFollowShowStatus2[EnvelopeFollowShowStatus2["ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_NOT_SHOW"] = 2] = "ENVELOPE_FOLLOW_SHOW_STATUS_ENVELOPE_FOLLOW_NOT_SHOW";
      EnvelopeFollowShowStatus2[EnvelopeFollowShowStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(EnvelopeFollowShowStatus = exports2.EnvelopeFollowShowStatus || (exports2.EnvelopeFollowShowStatus = {}));
    var EnvelopeDisplay;
    (function(EnvelopeDisplay2) {
      EnvelopeDisplay2[EnvelopeDisplay2["ENVELOPE_DISPLAY_UNKNOWN"] = 0] = "ENVELOPE_DISPLAY_UNKNOWN";
      EnvelopeDisplay2[EnvelopeDisplay2["ENVELOPE_DISPLAY_NEW"] = 1] = "ENVELOPE_DISPLAY_NEW";
      EnvelopeDisplay2[EnvelopeDisplay2["ENVELOPE_DISPLAY_HIDE"] = 2] = "ENVELOPE_DISPLAY_HIDE";
      EnvelopeDisplay2[EnvelopeDisplay2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(EnvelopeDisplay = exports2.EnvelopeDisplay || (exports2.EnvelopeDisplay = {}));
    var CommonContentCase;
    (function(CommonContentCase2) {
      CommonContentCase2[CommonContentCase2["COMMON_CONTENT_NOT_SET"] = 0] = "COMMON_CONTENT_NOT_SET";
      CommonContentCase2[CommonContentCase2["CREATE_CHANNEL_CONTENT"] = 100] = "CREATE_CHANNEL_CONTENT";
      CommonContentCase2[CommonContentCase2["LIST_CHANGE_CONTENT"] = 102] = "LIST_CHANGE_CONTENT";
      CommonContentCase2[CommonContentCase2["INVITE_CONTENT"] = 103] = "INVITE_CONTENT";
      CommonContentCase2[CommonContentCase2["APPLY_CONTENT"] = 104] = "APPLY_CONTENT";
      CommonContentCase2[CommonContentCase2["PERMIT_APPLY_CONTENT"] = 105] = "PERMIT_APPLY_CONTENT";
      CommonContentCase2[CommonContentCase2["REPLY_INVITE_CONTENT"] = 106] = "REPLY_INVITE_CONTENT";
      CommonContentCase2[CommonContentCase2["KICK_OUT_CONTENT"] = 107] = "KICK_OUT_CONTENT";
      CommonContentCase2[CommonContentCase2["CANCEL_APPLY_CONTENT"] = 108] = "CANCEL_APPLY_CONTENT";
      CommonContentCase2[CommonContentCase2["CANCEL_INVITE_CONTENT"] = 109] = "CANCEL_INVITE_CONTENT";
      CommonContentCase2[CommonContentCase2["LEAVE_CONTENT"] = 110] = "LEAVE_CONTENT";
      CommonContentCase2[CommonContentCase2["FINISH_CONTENT"] = 111] = "FINISH_CONTENT";
      CommonContentCase2[CommonContentCase2["JOIN_DIRECT_CONTENT"] = 112] = "JOIN_DIRECT_CONTENT";
      CommonContentCase2[CommonContentCase2["JOIN_GROUP_CONTENT"] = 113] = "JOIN_GROUP_CONTENT";
      CommonContentCase2[CommonContentCase2["PERMIT_GROUP_CONTENT"] = 114] = "PERMIT_GROUP_CONTENT";
      CommonContentCase2[CommonContentCase2["CANCEL_GROUP_CONTENT"] = 115] = "CANCEL_GROUP_CONTENT";
      CommonContentCase2[CommonContentCase2["LEAVE_GROUP_CONTENT"] = 116] = "LEAVE_GROUP_CONTENT";
      CommonContentCase2[CommonContentCase2["P2P_GROUP_CHANGE_CONTENT"] = 117] = "P2P_GROUP_CHANGE_CONTENT";
      CommonContentCase2[CommonContentCase2["GROUP_CHANGE_CONTENT"] = 118] = "GROUP_CHANGE_CONTENT";
      CommonContentCase2[CommonContentCase2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(CommonContentCase = exports2.CommonContentCase || (exports2.CommonContentCase = {}));
    var LinkMessageType;
    (function(LinkMessageType2) {
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_UNKNOWN"] = 0] = "TYPE_LINKER_UNKNOWN";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_CREATE"] = 1] = "TYPE_LINKER_CREATE";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_CLOSE"] = 2] = "TYPE_LINKER_CLOSE";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_INVITE"] = 3] = "TYPE_LINKER_INVITE";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_APPLY"] = 4] = "TYPE_LINKER_APPLY";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_REPLY"] = 5] = "TYPE_LINKER_REPLY";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_ENTER"] = 6] = "TYPE_LINKER_ENTER";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_LEAVE"] = 7] = "TYPE_LINKER_LEAVE";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_PERMIT"] = 8] = "TYPE_LINKER_PERMIT";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_CANCEL_INVITE"] = 9] = "TYPE_LINKER_CANCEL_INVITE";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_WAITING_LIST_CHANGE"] = 10] = "TYPE_LINKER_WAITING_LIST_CHANGE";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_LINKED_LIST_CHANGE"] = 11] = "TYPE_LINKER_LINKED_LIST_CHANGE";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_UPDATE_USER"] = 12] = "TYPE_LINKER_UPDATE_USER";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_KICK_OUT"] = 13] = "TYPE_LINKER_KICK_OUT";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_CANCEL_APPLY"] = 14] = "TYPE_LINKER_CANCEL_APPLY";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_MUTE"] = 15] = "TYPE_LINKER_MUTE";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_MATCH"] = 16] = "TYPE_LINKER_MATCH";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_UPDATE_USER_SETTING"] = 17] = "TYPE_LINKER_UPDATE_USER_SETTING";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_MIC_IDX_UPDATE"] = 18] = "TYPE_LINKER_MIC_IDX_UPDATE";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_LEAVE_V2"] = 19] = "TYPE_LINKER_LEAVE_V2";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_WAITING_LIST_CHANGE_V2"] = 20] = "TYPE_LINKER_WAITING_LIST_CHANGE_V2";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_LINKED_LIST_CHANGE_V2"] = 21] = "TYPE_LINKER_LINKED_LIST_CHANGE_V2";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_COHOST_LIST_CHANGE"] = 22] = "TYPE_LINKER_COHOST_LIST_CHANGE";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_MEDIA_CHANGE"] = 23] = "TYPE_LINKER_MEDIA_CHANGE";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_ACCEPT_NOTICE"] = 24] = "TYPE_LINKER_ACCEPT_NOTICE";
      LinkMessageType2[LinkMessageType2["TYPE_LINKER_SYS_KICK_OUT"] = 101] = "TYPE_LINKER_SYS_KICK_OUT";
      LinkMessageType2[LinkMessageType2["TYPE_LINKMIC_USER_TOAST"] = 102] = "TYPE_LINKMIC_USER_TOAST";
      LinkMessageType2[LinkMessageType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LinkMessageType = exports2.LinkMessageType || (exports2.LinkMessageType = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2[MessageType2["MESSAGE_TYPE_SUB_SUCCESS"] = 0] = "MESSAGE_TYPE_SUB_SUCCESS";
      MessageType2[MessageType2["MESSAGE_TYPE_ANCHOR_REMINDER"] = 1] = "MESSAGE_TYPE_ANCHOR_REMINDER";
      MessageType2[MessageType2["MESSAGE_TYPE_ENTER_ROOM_EXPIRE_SOON"] = 2] = "MESSAGE_TYPE_ENTER_ROOM_EXPIRE_SOON";
      MessageType2[MessageType2["MESSAGE_TYPE_SUB_GOAL_CREATE_TO_ANCHOR"] = 3] = "MESSAGE_TYPE_SUB_GOAL_CREATE_TO_ANCHOR";
      MessageType2[MessageType2["MESSAGE_TYPE_SUB_GOAL_COMPLETE_TO_AUDIENCE"] = 4] = "MESSAGE_TYPE_SUB_GOAL_COMPLETE_TO_AUDIENCE";
      MessageType2[MessageType2["MESSAGE_TYPE_SUB_GOAL_COMPLETE_TO_ANCHOR"] = 5] = "MESSAGE_TYPE_SUB_GOAL_COMPLETE_TO_ANCHOR";
      MessageType2[MessageType2["MESSAGE_TYPE_SUB_GIFT_TIK_TOK_2_USER_NOTICE"] = 6] = "MESSAGE_TYPE_SUB_GIFT_TIK_TOK_2_USER_NOTICE";
      MessageType2[MessageType2["MESSAGE_TYPE_SUB_GIFT_TIK_TOK_2_ANCHOR_NOTICE"] = 7] = "MESSAGE_TYPE_SUB_GIFT_TIK_TOK_2_ANCHOR_NOTICE";
      MessageType2[MessageType2["MESSAGE_TYPE_SUB_GIFT_T_RECEIVES_END_NOTICE"] = 8] = "MESSAGE_TYPE_SUB_GIFT_T_RECEIVES_END_NOTICE";
      MessageType2[MessageType2["MESSAGE_TYPE_SUB_GIFTS_END_SUCCEED_ROOM_MESSAGE"] = 9] = "MESSAGE_TYPE_SUB_GIFTS_END_SUCCEED_ROOM_MESSAGE";
      MessageType2[MessageType2["MESSAGE_TYPE_SUB_GIFTS_END_SUCCEED_ANCHOR_NOTICE"] = 10] = "MESSAGE_TYPE_SUB_GIFTS_END_SUCCEED_ANCHOR_NOTICE";
      MessageType2[MessageType2["MESSAGE_TYPE_SUB_GIFT_LOW_VERSION_UPGRADE_NOTICE"] = 11] = "MESSAGE_TYPE_SUB_GIFT_LOW_VERSION_UPGRADE_NOTICE";
      MessageType2[MessageType2["MESSAGE_TYPE_SUB_GIFT_USER_BUY_AU_TH_NOTICE"] = 12] = "MESSAGE_TYPE_SUB_GIFT_USER_BUY_AU_TH_NOTICE";
      MessageType2[MessageType2["MESSAGE_TYPE_SUB_COMMON_TEXT_NOTICE"] = 13] = "MESSAGE_TYPE_SUB_COMMON_TEXT_NOTICE";
      MessageType2[MessageType2["MESSAGE_TYPE_SUB_MODERATOR_PIN_PERK"] = 14] = "MESSAGE_TYPE_SUB_MODERATOR_PIN_PERK";
      MessageType2[MessageType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
    var Scene;
    (function(Scene2) {
      Scene2[Scene2["SCENE_UNKNOWN"] = 0] = "SCENE_UNKNOWN";
      Scene2[Scene2["SCENE_CO_HOST"] = 2] = "SCENE_CO_HOST";
      Scene2[Scene2["SCENE_MULTI_LIVE"] = 4] = "SCENE_MULTI_LIVE";
      Scene2[Scene2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Scene = exports2.Scene || (exports2.Scene = {}));
    var RewardCondition;
    (function(RewardCondition2) {
      RewardCondition2[RewardCondition2["REWARD_CONDITION_SUBSCRIPTION"] = 0] = "REWARD_CONDITION_SUBSCRIPTION";
      RewardCondition2[RewardCondition2["REWARD_CONDITION_SUB_WAVE_CUSTOM"] = 1] = "REWARD_CONDITION_SUB_WAVE_CUSTOM";
      RewardCondition2[RewardCondition2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(RewardCondition = exports2.RewardCondition || (exports2.RewardCondition = {}));
    var UserEmoteUploadSource;
    (function(UserEmoteUploadSource2) {
      UserEmoteUploadSource2[UserEmoteUploadSource2["USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR"] = 0] = "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR";
      UserEmoteUploadSource2[UserEmoteUploadSource2["USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER"] = 1] = "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER";
      UserEmoteUploadSource2[UserEmoteUploadSource2["USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR"] = 2] = "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR";
      UserEmoteUploadSource2[UserEmoteUploadSource2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(UserEmoteUploadSource = exports2.UserEmoteUploadSource || (exports2.UserEmoteUploadSource = {}));
    var EmoteScene;
    (function(EmoteScene2) {
      EmoteScene2[EmoteScene2["EMOTE_SCENE_SUBSCRIPTION"] = 0] = "EMOTE_SCENE_SUBSCRIPTION";
      EmoteScene2[EmoteScene2["EMOTE_SCENE_GAME"] = 1] = "EMOTE_SCENE_GAME";
      EmoteScene2[EmoteScene2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(EmoteScene = exports2.EmoteScene || (exports2.EmoteScene = {}));
    var PunishTypeId;
    (function(PunishTypeId2) {
      PunishTypeId2[PunishTypeId2["PUNISH_TYPE_IDUN_KNOWN"] = 0] = "PUNISH_TYPE_IDUN_KNOWN";
      PunishTypeId2[PunishTypeId2["PUNISH_TYPE_ID_BAN_LINK_MIC"] = 9] = "PUNISH_TYPE_ID_BAN_LINK_MIC";
      PunishTypeId2[PunishTypeId2["PUNISH_TYPE_ID_BAN_GAME_PARTNERSHIP"] = 25] = "PUNISH_TYPE_ID_BAN_GAME_PARTNERSHIP";
      PunishTypeId2[PunishTypeId2["PUNISH_TYPE_ID_REMOVE_GAME_PARTNERSHIP"] = 26] = "PUNISH_TYPE_ID_REMOVE_GAME_PARTNERSHIP";
      PunishTypeId2[PunishTypeId2["PUNISH_TYPE_ID_BANCO_HOST_LINK_MIC"] = 55] = "PUNISH_TYPE_ID_BANCO_HOST_LINK_MIC";
      PunishTypeId2[PunishTypeId2["PUNISH_TYPE_ID_AUTHORITY_LIMIT_MATCH"] = 57] = "PUNISH_TYPE_ID_AUTHORITY_LIMIT_MATCH";
      PunishTypeId2[PunishTypeId2["PUNISH_TYPE_ID_BAN_VOICE_CHAT"] = 59] = "PUNISH_TYPE_ID_BAN_VOICE_CHAT";
      PunishTypeId2[PunishTypeId2["PUNISH_TYPE_ID_BAN_LIVE_GOAL"] = 64] = "PUNISH_TYPE_ID_BAN_LIVE_GOAL";
      PunishTypeId2[PunishTypeId2["PUNISH_TYPE_ID_VIEWER_LIMIT"] = 70] = "PUNISH_TYPE_ID_VIEWER_LIMIT";
      PunishTypeId2[PunishTypeId2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(PunishTypeId = exports2.PunishTypeId || (exports2.PunishTypeId = {}));
    var MultiplierType;
    (function(MultiplierType2) {
      MultiplierType2[MultiplierType2["MULTIPLIER_TYPE_UNSPECIFIED"] = 0] = "MULTIPLIER_TYPE_UNSPECIFIED";
      MultiplierType2[MultiplierType2["MULTIPLIER_TYPE_CRITICAL_STRIKE"] = 1] = "MULTIPLIER_TYPE_CRITICAL_STRIKE";
      MultiplierType2[MultiplierType2["MULTIPLIER_TYPE_TOP_2"] = 2] = "MULTIPLIER_TYPE_TOP_2";
      MultiplierType2[MultiplierType2["MULTIPLIER_TYPE_TOP_3"] = 3] = "MULTIPLIER_TYPE_TOP_3";
      MultiplierType2[MultiplierType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(MultiplierType = exports2.MultiplierType || (exports2.MultiplierType = {}));
    var LinkmicGiftExpressionStrategy;
    (function(LinkmicGiftExpressionStrategy2) {
      LinkmicGiftExpressionStrategy2[LinkmicGiftExpressionStrategy2["LINKMIC_GIFT_EXPRESSION_STRATEGY_CONTROL_V_1"] = 0] = "LINKMIC_GIFT_EXPRESSION_STRATEGY_CONTROL_V_1";
      LinkmicGiftExpressionStrategy2[LinkmicGiftExpressionStrategy2["LINKMIC_GIFT_EXPRESSION_STRATEGY_EXPERIMENT_V_1"] = 1] = "LINKMIC_GIFT_EXPRESSION_STRATEGY_EXPERIMENT_V_1";
      LinkmicGiftExpressionStrategy2[LinkmicGiftExpressionStrategy2["LINKMIC_GIFT_EXPRESSION_STRATEGY_EXPERIMENT_V_2"] = 2] = "LINKMIC_GIFT_EXPRESSION_STRATEGY_EXPERIMENT_V_2";
      LinkmicGiftExpressionStrategy2[LinkmicGiftExpressionStrategy2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LinkmicGiftExpressionStrategy = exports2.LinkmicGiftExpressionStrategy || (exports2.LinkmicGiftExpressionStrategy = {}));
    var GiftMessageVersion;
    (function(GiftMessageVersion2) {
      GiftMessageVersion2[GiftMessageVersion2["GIFT_MESSAGE_VERSION_0"] = 0] = "GIFT_MESSAGE_VERSION_0";
      GiftMessageVersion2[GiftMessageVersion2["GIFT_MESSAGE_VERSION_1"] = 1] = "GIFT_MESSAGE_VERSION_1";
      GiftMessageVersion2[GiftMessageVersion2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(GiftMessageVersion = exports2.GiftMessageVersion || (exports2.GiftMessageVersion = {}));
    var TagType;
    (function(TagType2) {
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_UNKNOWN"] = 0] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_UNKNOWN";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_USER_GRADE"] = 1] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_USER_GRADE";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FANS_LEVEL"] = 2] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FANS_LEVEL";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_WATCH_ME_DAYS_AGO"] = 3] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_WATCH_ME_DAYS_AGO";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_CUSTOM"] = 4] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_CUSTOM";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_TITLE_GIFT"] = 5] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_TITLE_GIFT";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FIRST_JOINED_TEAM"] = 6] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FIRST_JOINED_TEAM";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_PAY_ACCOMPANY_DAYS"] = 7] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_PAY_ACCOMPANY_DAYS";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_SPONSOR_GIFT_LAST_ROOM"] = 8] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_SPONSOR_GIFT_LAST_ROOM";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_MATCH_MVP_LAST_ROOM"] = 9] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_MATCH_MVP_LAST_ROOM";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_LARGE_AMOUNT_GIFT_LAST_ROOM"] = 10] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_LARGE_AMOUNT_GIFT_LAST_ROOM";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_COMMENT_LAST_ROOM"] = 11] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_COMMENT_LAST_ROOM";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_TITLED_GIFT"] = 12] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_TITLED_GIFT";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_MEET_ANNIVERSARY"] = 13] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_MEET_ANNIVERSARY";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FANS_SLEEP"] = 14] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FANS_SLEEP";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_NOT_SEND_HEART_ME"] = 15] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_NOT_SEND_HEART_ME";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_NOT_JOIN_TEAM"] = 16] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_NOT_JOIN_TEAM";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FIRST_WATCH_LIVE"] = 17] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FIRST_WATCH_LIVE";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_COMMENT"] = 18] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_COMMENT";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_GIFT_TIMES"] = 19] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_GIFT_TIMES";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_WATCH_LIVE_DURATION"] = 20] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_WATCH_LIVE_DURATION";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_GIFT"] = 21] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_GIFT";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_LIVE_CONTRIBUTION_TOP"] = 22] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_RECENT_LIVE_CONTRIBUTION_TOP";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_JUST_UPGRADE"] = 28] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_JUST_UPGRADE";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_WATCH_DURATION"] = 29] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_WATCH_DURATION";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_COMMENT_NUM"] = 30] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_COMMENT_NUM";
      TagType2[TagType2["TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_GIFT_SENT_NUM"] = 31] = "TAG_TYPE_CREATOR_CR_M_TAG_TYPE_FAN_TOTAL_GIFT_SENT_NUM";
      TagType2[TagType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(TagType = exports2.TagType || (exports2.TagType = {}));
    var TopicActionType;
    (function(TopicActionType2) {
      TopicActionType2[TopicActionType2["TOPIC_ACTION_TYPE_UNKNOWN"] = 0] = "TOPIC_ACTION_TYPE_UNKNOWN";
      TopicActionType2[TopicActionType2["TOPIC_ACTION_TYPE_FOLLOW"] = 1] = "TOPIC_ACTION_TYPE_FOLLOW";
      TopicActionType2[TopicActionType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(TopicActionType = exports2.TopicActionType || (exports2.TopicActionType = {}));
    var UserMetricsType;
    (function(UserMetricsType2) {
      UserMetricsType2[UserMetricsType2["USER_METRICS_TYPE_UNKNOWN"] = 0] = "USER_METRICS_TYPE_UNKNOWN";
      UserMetricsType2[UserMetricsType2["USER_METRICS_TYPE_GRADE"] = 1] = "USER_METRICS_TYPE_GRADE";
      UserMetricsType2[UserMetricsType2["USER_METRICS_TYPE_SUBSCRIBE"] = 2] = "USER_METRICS_TYPE_SUBSCRIBE";
      UserMetricsType2[UserMetricsType2["USER_METRICS_TYPE_FOLLOW"] = 3] = "USER_METRICS_TYPE_FOLLOW";
      UserMetricsType2[UserMetricsType2["USER_METRICS_TYPE_FANS_CLUB"] = 4] = "USER_METRICS_TYPE_FANS_CLUB";
      UserMetricsType2[UserMetricsType2["USER_METRICS_TYPE_TOP_VIEWER"] = 5] = "USER_METRICS_TYPE_TOP_VIEWER";
      UserMetricsType2[UserMetricsType2["USER_METRICS_TYPE_GIFT"] = 6] = "USER_METRICS_TYPE_GIFT";
      UserMetricsType2[UserMetricsType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(UserMetricsType = exports2.UserMetricsType || (exports2.UserMetricsType = {}));
    var GiftMessageIgnoreConfig;
    (function(GiftMessageIgnoreConfig2) {
      GiftMessageIgnoreConfig2[GiftMessageIgnoreConfig2["GIFT_MESSAGE_IGNORE_CONFIG_NOT_IGNORE"] = 0] = "GIFT_MESSAGE_IGNORE_CONFIG_NOT_IGNORE";
      GiftMessageIgnoreConfig2[GiftMessageIgnoreConfig2["GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_TRAY"] = 1] = "GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_TRAY";
      GiftMessageIgnoreConfig2[GiftMessageIgnoreConfig2["GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_PS_M"] = 2] = "GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_PS_M";
      GiftMessageIgnoreConfig2[GiftMessageIgnoreConfig2["GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_TRAY_AND_PS_M"] = 3] = "GIFT_MESSAGE_IGNORE_CONFIG_IGNORE_TRAY_AND_PS_M";
      GiftMessageIgnoreConfig2[GiftMessageIgnoreConfig2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(GiftMessageIgnoreConfig = exports2.GiftMessageIgnoreConfig || (exports2.GiftMessageIgnoreConfig = {}));
    var HorizontalOnclickTriggerType;
    (function(HorizontalOnclickTriggerType2) {
      HorizontalOnclickTriggerType2[HorizontalOnclickTriggerType2["HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_UNKNOWN"] = 0] = "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_UNKNOWN";
      HorizontalOnclickTriggerType2[HorizontalOnclickTriggerType2["HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_LEFT"] = 1] = "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_LEFT";
      HorizontalOnclickTriggerType2[HorizontalOnclickTriggerType2["HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_MIDDLE"] = 2] = "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_MIDDLE";
      HorizontalOnclickTriggerType2[HorizontalOnclickTriggerType2["HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_RIGHT"] = 3] = "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_RIGHT";
      HorizontalOnclickTriggerType2[HorizontalOnclickTriggerType2["HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_ALL_AREA"] = 4] = "HORIZONTAL_ONCLICK_TRIGGER_TYPE_ONCLICK_TRIGGER_TYPE_ALL_AREA";
      HorizontalOnclickTriggerType2[HorizontalOnclickTriggerType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(HorizontalOnclickTriggerType = exports2.HorizontalOnclickTriggerType || (exports2.HorizontalOnclickTriggerType = {}));
    var ShowType;
    (function(ShowType2) {
      ShowType2[ShowType2["SHOW_TYPE_NORMAL"] = 0] = "SHOW_TYPE_NORMAL";
      ShowType2[ShowType2["SHOW_TYPE_FADE_IN_OUT"] = 1] = "SHOW_TYPE_FADE_IN_OUT";
      ShowType2[ShowType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ShowType = exports2.ShowType || (exports2.ShowType = {}));
    var RenderType;
    (function(RenderType2) {
      RenderType2[RenderType2["RENDER_TYPE_NATIVE"] = 0] = "RENDER_TYPE_NATIVE";
      RenderType2[RenderType2["RENDER_TYPE_HYBRID"] = 1] = "RENDER_TYPE_HYBRID";
      RenderType2[RenderType2["RENDER_TYPE_ALPHA"] = 2] = "RENDER_TYPE_ALPHA";
      RenderType2[RenderType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(RenderType = exports2.RenderType || (exports2.RenderType = {}));
    var IconDisplayType;
    (function(IconDisplayType2) {
      IconDisplayType2[IconDisplayType2["ICON_DISPLAY_TYPE_IMAGE"] = 0] = "ICON_DISPLAY_TYPE_IMAGE";
      IconDisplayType2[IconDisplayType2["ICON_DISPLAY_TYPE_BADGE"] = 1] = "ICON_DISPLAY_TYPE_BADGE";
      IconDisplayType2[IconDisplayType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(IconDisplayType = exports2.IconDisplayType || (exports2.IconDisplayType = {}));
    var CommentTag;
    (function(CommentTag2) {
      CommentTag2[CommentTag2["COMMENT_TAG_NORMAL"] = 0] = "COMMENT_TAG_NORMAL";
      CommentTag2[CommentTag2["COMMENT_TAG_CANDIDATE"] = 1] = "COMMENT_TAG_CANDIDATE";
      CommentTag2[CommentTag2["COMMENT_TAG_OVERAGE"] = 2] = "COMMENT_TAG_OVERAGE";
      CommentTag2[CommentTag2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(CommentTag = exports2.CommentTag || (exports2.CommentTag = {}));
    var PerceptionDialogIconType;
    (function(PerceptionDialogIconType2) {
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_NONE"] = 0] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_NONE";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_WARNING"] = 1] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_WARNING";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LINK_MIC"] = 2] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LINK_MIC";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_GUEST_LINK_MIC"] = 3] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_GUEST_LINK_MIC";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LIVE"] = 4] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LIVE";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_TREASURE_BOX"] = 5] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_TREASURE_BOX";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_MUTE"] = 6] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_MUTE";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_GAMEPAD_ACCESS_REVOKED"] = 7] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_GAMEPAD_ACCESS_REVOKED";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_SINGLE_ROOM"] = 8] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_SINGLE_ROOM";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_ALL_ROOM"] = 9] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_ALL_ROOM";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_GREEN_SCREEN"] = 10] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_BAN_REPORT_LIVE_GREEN_SCREEN";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_GIFT"] = 11] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_GIFT";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_APPEAL_SUCCESS"] = 12] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_APPEAL_SUCCESS";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_MATCH"] = 13] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_MATCH";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LIVE_GOAL"] = 14] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_LIVE_GOAL";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_SUBSCRIPTION"] = 15] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_SUBSCRIPTION";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_STAR_COMMENT"] = 16] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_STAR_COMMENT";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_RANKING"] = 17] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_RANKING";
      PerceptionDialogIconType2[PerceptionDialogIconType2["PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_COMMON"] = 18] = "PERCEPTION_DIALOG_ICON_TYPE_ICON_TYPE_COMMON";
      PerceptionDialogIconType2[PerceptionDialogIconType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(PerceptionDialogIconType = exports2.PerceptionDialogIconType || (exports2.PerceptionDialogIconType = {}));
    var GoalMessageSource;
    (function(GoalMessageSource2) {
      GoalMessageSource2[GoalMessageSource2["GOAL_MESSAGE_SOURCE_UNKNOWN"] = 0] = "GOAL_MESSAGE_SOURCE_UNKNOWN";
      GoalMessageSource2[GoalMessageSource2["GOAL_MESSAGE_SOURCE_COMMIT"] = 1] = "GOAL_MESSAGE_SOURCE_COMMIT";
      GoalMessageSource2[GoalMessageSource2["GOAL_MESSAGE_SOURCE_PROGRESS_UPDATE"] = 2] = "GOAL_MESSAGE_SOURCE_PROGRESS_UPDATE";
      GoalMessageSource2[GoalMessageSource2["GOAL_MESSAGE_SOURCE_PIN"] = 3] = "GOAL_MESSAGE_SOURCE_PIN";
      GoalMessageSource2[GoalMessageSource2["GOAL_MESSAGE_SOURCE_UNPIN"] = 4] = "GOAL_MESSAGE_SOURCE_UNPIN";
      GoalMessageSource2[GoalMessageSource2["GOAL_MESSAGE_SOURCE_REVIEW_CALLBACK"] = 5] = "GOAL_MESSAGE_SOURCE_REVIEW_CALLBACK";
      GoalMessageSource2[GoalMessageSource2["GOAL_MESSAGE_SOURCE_SUSPEND"] = 6] = "GOAL_MESSAGE_SOURCE_SUSPEND";
      GoalMessageSource2[GoalMessageSource2["GOAL_MESSAGE_SOURCE_CHALLENGE_PROMPT"] = 7] = "GOAL_MESSAGE_SOURCE_CHALLENGE_PROMPT";
      GoalMessageSource2[GoalMessageSource2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(GoalMessageSource = exports2.GoalMessageSource || (exports2.GoalMessageSource = {}));
    var ExhibitionType;
    (function(ExhibitionType2) {
      ExhibitionType2[ExhibitionType2["EXHIBITION_TYPE_DEFAULT"] = 0] = "EXHIBITION_TYPE_DEFAULT";
      ExhibitionType2[ExhibitionType2["EXHIBITION_TYPE_FOLD"] = 1] = "EXHIBITION_TYPE_FOLD";
      ExhibitionType2[ExhibitionType2["EXHIBITION_TYPE_PUBLIC_SCREEN"] = 2] = "EXHIBITION_TYPE_PUBLIC_SCREEN";
      ExhibitionType2[ExhibitionType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ExhibitionType = exports2.ExhibitionType || (exports2.ExhibitionType = {}));
    var GiftSource;
    (function(GiftSource2) {
      GiftSource2[GiftSource2["GIFT_SOURCE_UNKNOWN"] = 0] = "GIFT_SOURCE_UNKNOWN";
      GiftSource2[GiftSource2["GIFT_SOURCE_PLATFORM"] = 1] = "GIFT_SOURCE_PLATFORM";
      GiftSource2[GiftSource2["GIFT_SOURCE_USER_BUY_RANDOM"] = 2] = "GIFT_SOURCE_USER_BUY_RANDOM";
      GiftSource2[GiftSource2["GIFT_SOURCE_USER_BUY_SPECIFIC"] = 3] = "GIFT_SOURCE_USER_BUY_SPECIFIC";
      GiftSource2[GiftSource2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(GiftSource = exports2.GiftSource || (exports2.GiftSource = {}));
    var MessageDisplayStyle;
    (function(MessageDisplayStyle2) {
      MessageDisplayStyle2[MessageDisplayStyle2["MESSAGE_DISPLAY_STYLE_DEFAULT"] = 0] = "MESSAGE_DISPLAY_STYLE_DEFAULT";
      MessageDisplayStyle2[MessageDisplayStyle2["MESSAGE_DISPLAY_STYLE_POPUP"] = 1] = "MESSAGE_DISPLAY_STYLE_POPUP";
      MessageDisplayStyle2[MessageDisplayStyle2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(MessageDisplayStyle = exports2.MessageDisplayStyle || (exports2.MessageDisplayStyle = {}));
    var ProfitRankType;
    (function(ProfitRankType2) {
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_HOURLY_RANK"] = 0] = "PROFIT_RANK_TYPE_TYPE_HOURLY_RANK";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_WEEKLY_RANK"] = 1] = "PROFIT_RANK_TYPE_TYPE_WEEKLY_RANK";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_HOURLY_STAR_RANK"] = 2] = "PROFIT_RANK_TYPE_TYPE_HOURLY_STAR_RANK";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_WEEKLY_RISING_RANK_ACTIVITY"] = 3] = "PROFIT_RANK_TYPE_TYPE_WEEKLY_RISING_RANK_ACTIVITY";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_WEEKLY_RISING_RANK"] = 4] = "PROFIT_RANK_TYPE_TYPE_WEEKLY_RISING_RANK";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_WEEKLY_ROOKIE"] = 5] = "PROFIT_RANK_TYPE_TYPE_WEEKLY_ROOKIE";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_E_COMMERCE_WEEKLY"] = 6] = "PROFIT_RANK_TYPE_TYPE_E_COMMERCE_WEEKLY";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_E_COMMERCE_DAILY"] = 7] = "PROFIT_RANK_TYPE_TYPE_E_COMMERCE_DAILY";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_DAILY_RANK"] = 8] = "PROFIT_RANK_TYPE_TYPE_DAILY_RANK";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_FIRST_GIFT_RANK"] = 9] = "PROFIT_RANK_TYPE_TYPE_FIRST_GIFT_RANK";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_GAME_RANK"] = 10] = "PROFIT_RANK_TYPE_TYPE_GAME_RANK";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_DAILY_GAME"] = 11] = "PROFIT_RANK_TYPE_TYPE_DAILY_GAME";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_HALL_OF_FAME_RANK"] = 12] = "PROFIT_RANK_TYPE_TYPE_HALL_OF_FAME_RANK";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_RANK_LEAGUE"] = 13] = "PROFIT_RANK_TYPE_TYPE_RANK_LEAGUE";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_DAILY_ROOKIE"] = 14] = "PROFIT_RANK_TYPE_DAILY_ROOKIE";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_TEAM_RANK"] = 15] = "PROFIT_RANK_TYPE_TYPE_TEAM_RANK";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_CLASS_RANK"] = 16] = "PROFIT_RANK_TYPE_TYPE_CLASS_RANK";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_DAILY_GAME_PUB_G"] = 20] = "PROFIT_RANK_TYPE_TYPE_DAILY_GAME_PUB_G";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_DAILY_GAME_MLB_B"] = 21] = "PROFIT_RANK_TYPE_TYPE_DAILY_GAME_MLB_B";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_DAILY_GAME_FREE_FIRE"] = 22] = "PROFIT_RANK_TYPE_TYPE_DAILY_GAME_FREE_FIRE";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_ONE"] = 23] = "PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_ONE";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_TWO"] = 24] = "PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_TWO";
      ProfitRankType2[ProfitRankType2["PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_THREE"] = 25] = "PROFIT_RANK_TYPE_TYPE_WEEKLY_GAME_SUBCATEGORY_THREE";
      ProfitRankType2[ProfitRankType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ProfitRankType = exports2.ProfitRankType || (exports2.ProfitRankType = {}));
    var UnionAnimationInfoType;
    (function(UnionAnimationInfoType2) {
      UnionAnimationInfoType2[UnionAnimationInfoType2["UNION_ANIMATION_INFO_TYPE_NO_UNION_ANIMATION"] = 0] = "UNION_ANIMATION_INFO_TYPE_NO_UNION_ANIMATION";
      UnionAnimationInfoType2[UnionAnimationInfoType2["UNION_ANIMATION_INFO_TYPE_LOOP"] = 1] = "UNION_ANIMATION_INFO_TYPE_LOOP";
      UnionAnimationInfoType2[UnionAnimationInfoType2["UNION_ANIMATION_INFO_TYPE_LOCK"] = 2] = "UNION_ANIMATION_INFO_TYPE_LOCK";
      UnionAnimationInfoType2[UnionAnimationInfoType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(UnionAnimationInfoType = exports2.UnionAnimationInfoType || (exports2.UnionAnimationInfoType = {}));
    var DisplayStyle;
    (function(DisplayStyle2) {
      DisplayStyle2[DisplayStyle2["DISPLAY_STYLE_NORMAL"] = 0] = "DISPLAY_STYLE_NORMAL";
      DisplayStyle2[DisplayStyle2["DISPLAY_STYLE_STAY"] = 1] = "DISPLAY_STYLE_STAY";
      DisplayStyle2[DisplayStyle2["DISPLAY_STYLE_CHAT"] = 2] = "DISPLAY_STYLE_CHAT";
      DisplayStyle2[DisplayStyle2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(DisplayStyle = exports2.DisplayStyle || (exports2.DisplayStyle = {}));
    var HitABStatus;
    (function(HitABStatus2) {
      HitABStatus2[HitABStatus2["HIT_A_B_STATUS_HIT_AB_STATUS_NO_HIT"] = 0] = "HIT_A_B_STATUS_HIT_AB_STATUS_NO_HIT";
      HitABStatus2[HitABStatus2["HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_EXTERNAL_LINK_NEW_TEXT"] = 1] = "HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_EXTERNAL_LINK_NEW_TEXT";
      HitABStatus2[HitABStatus2["HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_RE_POST_NEW_TEXT"] = 2] = "HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_RE_POST_NEW_TEXT";
      HitABStatus2[HitABStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(HitABStatus = exports2.HitABStatus || (exports2.HitABStatus = {}));
    var PollKind;
    (function(PollKind2) {
      PollKind2[PollKind2["POLL_KIND_NORMAL"] = 0] = "POLL_KIND_NORMAL";
      PollKind2[PollKind2["POLL_KIND_GIFT"] = 1] = "POLL_KIND_GIFT";
      PollKind2[PollKind2["POLL_KIND_CUSTOMIZABLE"] = 2] = "POLL_KIND_CUSTOMIZABLE";
      PollKind2[PollKind2["POLL_KIND_CUSTOMIZABLE_GIFT"] = 3] = "POLL_KIND_CUSTOMIZABLE_GIFT";
      PollKind2[PollKind2["POLL_KIND_QUICK_GIFT"] = 4] = "POLL_KIND_QUICK_GIFT";
      PollKind2[PollKind2["POLL_KIND_EMOTE"] = 5] = "POLL_KIND_EMOTE";
      PollKind2[PollKind2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(PollKind = exports2.PollKind || (exports2.PollKind = {}));
    var PollTemplateStatus;
    (function(PollTemplateStatus2) {
      PollTemplateStatus2[PollTemplateStatus2["POLL_TEMPLATE_STATUS_TO_BE_REVIEWED"] = 0] = "POLL_TEMPLATE_STATUS_TO_BE_REVIEWED";
      PollTemplateStatus2[PollTemplateStatus2["POLL_TEMPLATE_STATUS_UNDER_REVIEW"] = 1] = "POLL_TEMPLATE_STATUS_UNDER_REVIEW";
      PollTemplateStatus2[PollTemplateStatus2["POLL_TEMPLATE_STATUS_REVIEWED"] = 2] = "POLL_TEMPLATE_STATUS_REVIEWED";
      PollTemplateStatus2[PollTemplateStatus2["POLL_TEMPLATE_STATUS_REFUSED"] = 3] = "POLL_TEMPLATE_STATUS_REFUSED";
      PollTemplateStatus2[PollTemplateStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(PollTemplateStatus = exports2.PollTemplateStatus || (exports2.PollTemplateStatus = {}));
    var PollAppealStatus;
    (function(PollAppealStatus2) {
      PollAppealStatus2[PollAppealStatus2["POLL_APPEAL_STATUS_UNKNOWN"] = 0] = "POLL_APPEAL_STATUS_UNKNOWN";
      PollAppealStatus2[PollAppealStatus2["POLL_APPEAL_STATUS_PASS"] = 1] = "POLL_APPEAL_STATUS_PASS";
      PollAppealStatus2[PollAppealStatus2["POLL_APPEAL_STATUS_FAIL"] = 2] = "POLL_APPEAL_STATUS_FAIL";
      PollAppealStatus2[PollAppealStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(PollAppealStatus = exports2.PollAppealStatus || (exports2.PollAppealStatus = {}));
    var RankTestMessageScene;
    (function(RankTestMessageScene2) {
      RankTestMessageScene2[RankTestMessageScene2["RANK_TEST_MESSAGE_SCENE_UNKNOWN"] = 0] = "RANK_TEST_MESSAGE_SCENE_UNKNOWN";
      RankTestMessageScene2[RankTestMessageScene2["RANK_TEST_MESSAGE_SCENE_ONLINE_AUDIENCE_TOP_N_UPDATE_PUBLIC_SCREEN"] = 1] = "RANK_TEST_MESSAGE_SCENE_ONLINE_AUDIENCE_TOP_N_UPDATE_PUBLIC_SCREEN";
      RankTestMessageScene2[RankTestMessageScene2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(RankTestMessageScene = exports2.RankTestMessageScene || (exports2.RankTestMessageScene = {}));
    var TriggerReason;
    (function(TriggerReason2) {
      TriggerReason2[TriggerReason2["TRIGGER_REASON_UNKNOWN"] = 0] = "TRIGGER_REASON_UNKNOWN";
      TriggerReason2[TriggerReason2["TRIGGER_REASON_SCORE_UPDATE"] = 1] = "TRIGGER_REASON_SCORE_UPDATE";
      TriggerReason2[TriggerReason2["TRIGGER_REASON_BATTLE_END"] = 2] = "TRIGGER_REASON_BATTLE_END";
      TriggerReason2[TriggerReason2["TRIGGER_REASON_OPT_OUT_UPDATE"] = 3] = "TRIGGER_REASON_OPT_OUT_UPDATE";
      TriggerReason2[TriggerReason2["TRIGGER_REASON_KEEP_ALIVE"] = 4] = "TRIGGER_REASON_KEEP_ALIVE";
      TriggerReason2[TriggerReason2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(TriggerReason = exports2.TriggerReason || (exports2.TriggerReason = {}));
    var Reason;
    (function(Reason2) {
      Reason2[Reason2["REASON_TIME_UP"] = 0] = "REASON_TIME_UP";
      Reason2[Reason2["REASON_CUT_SHORT"] = 1] = "REASON_CUT_SHORT";
      Reason2[Reason2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Reason = exports2.Reason || (exports2.Reason = {}));
    var BattleTaskMessageType;
    (function(BattleTaskMessageType2) {
      BattleTaskMessageType2[BattleTaskMessageType2["BATTLE_TASK_MESSAGE_TYPE_START"] = 0] = "BATTLE_TASK_MESSAGE_TYPE_START";
      BattleTaskMessageType2[BattleTaskMessageType2["BATTLE_TASK_MESSAGE_TYPE_TASK_UPDATE"] = 1] = "BATTLE_TASK_MESSAGE_TYPE_TASK_UPDATE";
      BattleTaskMessageType2[BattleTaskMessageType2["BATTLE_TASK_MESSAGE_TYPE_TASK_SETTLE"] = 2] = "BATTLE_TASK_MESSAGE_TYPE_TASK_SETTLE";
      BattleTaskMessageType2[BattleTaskMessageType2["BATTLE_TASK_MESSAGE_TYPE_REWARD_SETTLE"] = 3] = "BATTLE_TASK_MESSAGE_TYPE_REWARD_SETTLE";
      BattleTaskMessageType2[BattleTaskMessageType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BattleTaskMessageType = exports2.BattleTaskMessageType || (exports2.BattleTaskMessageType = {}));
    var RewardStatus;
    (function(RewardStatus2) {
      RewardStatus2[RewardStatus2["REWARD_STATUS_SUCCEED"] = 0] = "REWARD_STATUS_SUCCEED";
      RewardStatus2[RewardStatus2["REWARD_STATUS_FAILED"] = 1] = "REWARD_STATUS_FAILED";
      RewardStatus2[RewardStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(RewardStatus = exports2.RewardStatus || (exports2.RewardStatus = {}));
    var BattleAction;
    (function(BattleAction2) {
      BattleAction2[BattleAction2["BATTLE_ACTION_UNKNOWN"] = 0] = "BATTLE_ACTION_UNKNOWN";
      BattleAction2[BattleAction2["BATTLE_ACTION_INVITE"] = 1] = "BATTLE_ACTION_INVITE";
      BattleAction2[BattleAction2["BATTLE_ACTION_REJECT"] = 2] = "BATTLE_ACTION_REJECT";
      BattleAction2[BattleAction2["BATTLE_ACTION_CANCEL"] = 3] = "BATTLE_ACTION_CANCEL";
      BattleAction2[BattleAction2["BATTLE_ACTION_OPEN"] = 4] = "BATTLE_ACTION_OPEN";
      BattleAction2[BattleAction2["BATTLE_ACTION_FINISH"] = 5] = "BATTLE_ACTION_FINISH";
      BattleAction2[BattleAction2["BATTLE_ACTION_CUT_SHORT"] = 6] = "BATTLE_ACTION_CUT_SHORT";
      BattleAction2[BattleAction2["BATTLE_ACTION_ACCEPT"] = 7] = "BATTLE_ACTION_ACCEPT";
      BattleAction2[BattleAction2["BATTLE_ACTION_QUIT_APPLY"] = 8] = "BATTLE_ACTION_QUIT_APPLY";
      BattleAction2[BattleAction2["BATTLE_ACTION_DECLINE_QUIT"] = 9] = "BATTLE_ACTION_DECLINE_QUIT";
      BattleAction2[BattleAction2["BATTLE_ACTION_DECLINE_OFF_QUIT"] = 10] = "BATTLE_ACTION_DECLINE_OFF_QUIT";
      BattleAction2[BattleAction2["BATTLE_ACTION_LEAVE_LINK_MIC"] = 11] = "BATTLE_ACTION_LEAVE_LINK_MIC";
      BattleAction2[BattleAction2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BattleAction = exports2.BattleAction || (exports2.BattleAction = {}));
    var Result;
    (function(Result2) {
      Result2[Result2["RESULT_WIN"] = 0] = "RESULT_WIN";
      Result2[Result2["RESULT_LOSE"] = 1] = "RESULT_LOSE";
      Result2[Result2["RESULT_DRAW"] = 2] = "RESULT_DRAW";
      Result2[Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Result = exports2.Result || (exports2.Result = {}));
    var GiftPermissionType;
    (function(GiftPermissionType2) {
      GiftPermissionType2[GiftPermissionType2["GIFT_PERMISSION_TYPE_UNKNOWN_TYPE"] = 0] = "GIFT_PERMISSION_TYPE_UNKNOWN_TYPE";
      GiftPermissionType2[GiftPermissionType2["GIFT_PERMISSION_TYPE_NO_GIFT_PERMISSION"] = 1] = "GIFT_PERMISSION_TYPE_NO_GIFT_PERMISSION";
      GiftPermissionType2[GiftPermissionType2["GIFT_PERMISSION_TYPE_ANCHOR_CLOSE"] = 2] = "GIFT_PERMISSION_TYPE_ANCHOR_CLOSE";
      GiftPermissionType2[GiftPermissionType2["GIFT_PERMISSION_TYPE_HAS_GIFT_PERMISSION"] = 3] = "GIFT_PERMISSION_TYPE_HAS_GIFT_PERMISSION";
      GiftPermissionType2[GiftPermissionType2["GIFT_PERMISSION_TYPE_ANCHOR_BANNED"] = 4] = "GIFT_PERMISSION_TYPE_ANCHOR_BANNED";
      GiftPermissionType2[GiftPermissionType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(GiftPermissionType = exports2.GiftPermissionType || (exports2.GiftPermissionType = {}));
    var BattleABTestType;
    (function(BattleABTestType2) {
      BattleABTestType2[BattleABTestType2["BATTLE_A_B_TEST_TYPE_UNKNOWN_AB_TEST_TYPE"] = 0] = "BATTLE_A_B_TEST_TYPE_UNKNOWN_AB_TEST_TYPE";
      BattleABTestType2[BattleABTestType2["BATTLE_A_B_TEST_TYPE_MEANWHILE_INVITE"] = 1] = "BATTLE_A_B_TEST_TYPE_MEANWHILE_INVITE";
      BattleABTestType2[BattleABTestType2["BATTLE_A_B_TEST_TYPE_SPECIFIED_GIFT"] = 2] = "BATTLE_A_B_TEST_TYPE_SPECIFIED_GIFT";
      BattleABTestType2[BattleABTestType2["BATTLE_A_B_TEST_TYPE_RT_C_MESSAGE_CHANNEL"] = 3] = "BATTLE_A_B_TEST_TYPE_RT_C_MESSAGE_CHANNEL";
      BattleABTestType2[BattleABTestType2["BATTLE_A_B_TEST_TYPE_CONNECTION_TIME_OUT"] = 4] = "BATTLE_A_B_TEST_TYPE_CONNECTION_TIME_OUT";
      BattleABTestType2[BattleABTestType2["BATTLE_A_B_TEST_TYPE_REMATCH_SKIP_TEAMMATE"] = 5] = "BATTLE_A_B_TEST_TYPE_REMATCH_SKIP_TEAMMATE";
      BattleABTestType2[BattleABTestType2["BATTLE_A_B_TEST_TYPE_OPT_INVITEE_4048"] = 6] = "BATTLE_A_B_TEST_TYPE_OPT_INVITEE_4048";
      BattleABTestType2[BattleABTestType2["BATTLE_A_B_TEST_TYPE_BATTLE_AB_TEST_TYPE_TIME_CALIBRATE"] = 7] = "BATTLE_A_B_TEST_TYPE_BATTLE_AB_TEST_TYPE_TIME_CALIBRATE";
      BattleABTestType2[BattleABTestType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BattleABTestType = exports2.BattleABTestType || (exports2.BattleABTestType = {}));
    var PlayScene;
    (function(PlayScene2) {
      PlayScene2[PlayScene2["PLAY_SCENE_UNKNOWN"] = 0] = "PLAY_SCENE_UNKNOWN";
      PlayScene2[PlayScene2["PLAY_SCENE_COUNTDOWN_FOR_ALL"] = 1] = "PLAY_SCENE_COUNTDOWN_FOR_ALL";
      PlayScene2[PlayScene2["PLAY_SCENE_COUNTDOWN_FOR_SINGLE"] = 2] = "PLAY_SCENE_COUNTDOWN_FOR_SINGLE";
      PlayScene2[PlayScene2["PLAY_SCENE_LIVE_SHOW"] = 3] = "PLAY_SCENE_LIVE_SHOW";
      PlayScene2[PlayScene2["PLAY_SCENE_AIG_C"] = 4] = "PLAY_SCENE_AIG_C";
      PlayScene2[PlayScene2["PLAY_SCENE_KARAOKE"] = 5] = "PLAY_SCENE_KARAOKE";
      PlayScene2[PlayScene2["PLAY_SCENE_DRAW_GUESS"] = 6] = "PLAY_SCENE_DRAW_GUESS";
      PlayScene2[PlayScene2["PLAY_SCENE_ENLARGE_GRID"] = 7] = "PLAY_SCENE_ENLARGE_GRID";
      PlayScene2[PlayScene2["PLAY_SCENE_GIFT_PRIORITY_LINK"] = 8] = "PLAY_SCENE_GIFT_PRIORITY_LINK";
      PlayScene2[PlayScene2["PLAY_SCENE_GIFT_THRESHOLD_LINK"] = 9] = "PLAY_SCENE_GIFT_THRESHOLD_LINK";
      PlayScene2[PlayScene2["PLAY_SCENE_NOTICE_BOARD"] = 10] = "PLAY_SCENE_NOTICE_BOARD";
      PlayScene2[PlayScene2["PLAY_SCENE_PLAY_BOOK"] = 11] = "PLAY_SCENE_PLAY_BOOK";
      PlayScene2[PlayScene2["PLAY_SCENE_GUEST_SHOWDOWN"] = 12] = "PLAY_SCENE_GUEST_SHOWDOWN";
      PlayScene2[PlayScene2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(PlayScene = exports2.PlayScene || (exports2.PlayScene = {}));
    var LinkType;
    (function(LinkType2) {
      LinkType2[LinkType2["LINK_TYPE_TYPE_UNKNOWN"] = 0] = "LINK_TYPE_TYPE_UNKNOWN";
      LinkType2[LinkType2["LINK_TYPE_TYPE_VIDEO"] = 1] = "LINK_TYPE_TYPE_VIDEO";
      LinkType2[LinkType2["LINK_TYPE_TYPE_AUDIO"] = 2] = "LINK_TYPE_TYPE_AUDIO";
      LinkType2[LinkType2["LINK_TYPE_TYPE_VIRTUAL"] = 3] = "LINK_TYPE_TYPE_VIRTUAL";
      LinkType2[LinkType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LinkType = exports2.LinkType || (exports2.LinkType = {}));
    var LinkSilenceStatus;
    (function(LinkSilenceStatus2) {
      LinkSilenceStatus2[LinkSilenceStatus2["LINK_SILENCE_STATUS_STATUS_UN_SILENCE"] = 0] = "LINK_SILENCE_STATUS_STATUS_UN_SILENCE";
      LinkSilenceStatus2[LinkSilenceStatus2["LINK_SILENCE_STATUS_STATUS_SILENCE_BY_SELF"] = 1] = "LINK_SILENCE_STATUS_STATUS_SILENCE_BY_SELF";
      LinkSilenceStatus2[LinkSilenceStatus2["LINK_SILENCE_STATUS_STATUS_SILENCE_BY_OWNER"] = 2] = "LINK_SILENCE_STATUS_STATUS_SILENCE_BY_OWNER";
      LinkSilenceStatus2[LinkSilenceStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LinkSilenceStatus = exports2.LinkSilenceStatus || (exports2.LinkSilenceStatus = {}));
    var LinkmicRoleType;
    (function(LinkmicRoleType2) {
      LinkmicRoleType2[LinkmicRoleType2["LINKMIC_ROLE_TYPE_ROLE_TYPE_UNKOWN"] = 0] = "LINKMIC_ROLE_TYPE_ROLE_TYPE_UNKOWN";
      LinkmicRoleType2[LinkmicRoleType2["LINKMIC_ROLE_TYPE_LEADER"] = 1] = "LINKMIC_ROLE_TYPE_LEADER";
      LinkmicRoleType2[LinkmicRoleType2["LINKMIC_ROLE_TYPE_PLAYER"] = 2] = "LINKMIC_ROLE_TYPE_PLAYER";
      LinkmicRoleType2[LinkmicRoleType2["LINKMIC_ROLE_TYPE_INVITEE"] = 3] = "LINKMIC_ROLE_TYPE_INVITEE";
      LinkmicRoleType2[LinkmicRoleType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LinkmicRoleType = exports2.LinkmicRoleType || (exports2.LinkmicRoleType = {}));
    var LinkRoleType;
    (function(LinkRoleType2) {
      LinkRoleType2[LinkRoleType2["LINK_ROLE_TYPE_TYPE_ROLE_TYPE_UNKOWN"] = 0] = "LINK_ROLE_TYPE_TYPE_ROLE_TYPE_UNKOWN";
      LinkRoleType2[LinkRoleType2["LINK_ROLE_TYPE_TYPE_LEADER"] = 1] = "LINK_ROLE_TYPE_TYPE_LEADER";
      LinkRoleType2[LinkRoleType2["LINK_ROLE_TYPE_TYPE_PLAYER"] = 2] = "LINK_ROLE_TYPE_TYPE_PLAYER";
      LinkRoleType2[LinkRoleType2["LINK_ROLE_TYPE_TYPE_INVITEE"] = 3] = "LINK_ROLE_TYPE_TYPE_INVITEE";
      LinkRoleType2[LinkRoleType2["LINK_ROLE_TYPE_TYPE_APPLIER"] = 4] = "LINK_ROLE_TYPE_TYPE_APPLIER";
      LinkRoleType2[LinkRoleType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LinkRoleType = exports2.LinkRoleType || (exports2.LinkRoleType = {}));
    var MuteStatus;
    (function(MuteStatus2) {
      MuteStatus2[MuteStatus2["MUTE_STATUS_MUTE"] = 0] = "MUTE_STATUS_MUTE";
      MuteStatus2[MuteStatus2["MUTE_STATUS_UN_MUTE"] = 1] = "MUTE_STATUS_UN_MUTE";
      MuteStatus2[MuteStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(MuteStatus = exports2.MuteStatus || (exports2.MuteStatus = {}));
    var GuestMicCameraManageOp;
    (function(GuestMicCameraManageOp2) {
      GuestMicCameraManageOp2[GuestMicCameraManageOp2["GUEST_MIC_CAMERA_MANAGE_OP_OPEN_MIC"] = 0] = "GUEST_MIC_CAMERA_MANAGE_OP_OPEN_MIC";
      GuestMicCameraManageOp2[GuestMicCameraManageOp2["GUEST_MIC_CAMERA_MANAGE_OP_OPEN_CAMERA"] = 1] = "GUEST_MIC_CAMERA_MANAGE_OP_OPEN_CAMERA";
      GuestMicCameraManageOp2[GuestMicCameraManageOp2["GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_MIC"] = 2] = "GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_MIC";
      GuestMicCameraManageOp2[GuestMicCameraManageOp2["GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_CAMERA"] = 3] = "GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_CAMERA";
      GuestMicCameraManageOp2[GuestMicCameraManageOp2["GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_MIC_PUNISH"] = 4] = "GUEST_MIC_CAMERA_MANAGE_OP_CLOSE_MIC_PUNISH";
      GuestMicCameraManageOp2[GuestMicCameraManageOp2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(GuestMicCameraManageOp = exports2.GuestMicCameraManageOp || (exports2.GuestMicCameraManageOp = {}));
    var GuestMicCameraChangeScene;
    (function(GuestMicCameraChangeScene2) {
      GuestMicCameraChangeScene2[GuestMicCameraChangeScene2["GUEST_MIC_CAMERA_CHANGE_SCENE_CHANGE_SCENE_UNKNOWN"] = 0] = "GUEST_MIC_CAMERA_CHANGE_SCENE_CHANGE_SCENE_UNKNOWN";
      GuestMicCameraChangeScene2[GuestMicCameraChangeScene2["GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_ANCHOR_AUTO"] = 1] = "GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_ANCHOR_AUTO";
      GuestMicCameraChangeScene2[GuestMicCameraChangeScene2["GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_SERVER_NORMAL"] = 2] = "GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_SERVER_NORMAL";
      GuestMicCameraChangeScene2[GuestMicCameraChangeScene2["GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_SHOW_END"] = 3] = "GUEST_MIC_CAMERA_CHANGE_SCENE_LIVE_SHOW_BY_SHOW_END";
      GuestMicCameraChangeScene2[GuestMicCameraChangeScene2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(GuestMicCameraChangeScene = exports2.GuestMicCameraChangeScene || (exports2.GuestMicCameraChangeScene = {}));
    var LinkMicUserAdminType;
    (function(LinkMicUserAdminType2) {
      LinkMicUserAdminType2[LinkMicUserAdminType2["LINK_MIC_USER_ADMIN_TYPE_UNDEFINED_TYPE"] = 0] = "LINK_MIC_USER_ADMIN_TYPE_UNDEFINED_TYPE";
      LinkMicUserAdminType2[LinkMicUserAdminType2["LINK_MIC_USER_ADMIN_TYPE_MANAGER_TYPE"] = 1] = "LINK_MIC_USER_ADMIN_TYPE_MANAGER_TYPE";
      LinkMicUserAdminType2[LinkMicUserAdminType2["LINK_MIC_USER_ADMIN_TYPE_HOST_TYPE"] = 2] = "LINK_MIC_USER_ADMIN_TYPE_HOST_TYPE";
      LinkMicUserAdminType2[LinkMicUserAdminType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LinkMicUserAdminType = exports2.LinkMicUserAdminType || (exports2.LinkMicUserAdminType = {}));
    var LinkmicMultiLiveEnum;
    (function(LinkmicMultiLiveEnum2) {
      LinkmicMultiLiveEnum2[LinkmicMultiLiveEnum2["LINKMIC_MULTI_LIVE_ENUM_DEFAULT"] = 0] = "LINKMIC_MULTI_LIVE_ENUM_DEFAULT";
      LinkmicMultiLiveEnum2[LinkmicMultiLiveEnum2["LINKMIC_MULTI_LIVE_ENUM_ANCHOR_USE_NEW_LAYOUT"] = 1] = "LINKMIC_MULTI_LIVE_ENUM_ANCHOR_USE_NEW_LAYOUT";
      LinkmicMultiLiveEnum2[LinkmicMultiLiveEnum2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LinkmicMultiLiveEnum = exports2.LinkmicMultiLiveEnum || (exports2.LinkmicMultiLiveEnum = {}));
    var PollEndType;
    (function(PollEndType2) {
      PollEndType2[PollEndType2["POLL_END_TYPE_POLL_END_BY_TIME"] = 0] = "POLL_END_TYPE_POLL_END_BY_TIME";
      PollEndType2[PollEndType2["POLL_END_TYPE_POLL_END_BY_OWNER"] = 1] = "POLL_END_TYPE_POLL_END_BY_OWNER";
      PollEndType2[PollEndType2["POLL_END_TYPE_POLL_END_BY_OTHER"] = 2] = "POLL_END_TYPE_POLL_END_BY_OTHER";
      PollEndType2[PollEndType2["POLL_END_TYPE_POLL_END_BY_ADMIN"] = 3] = "POLL_END_TYPE_POLL_END_BY_ADMIN";
      PollEndType2[PollEndType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(PollEndType = exports2.PollEndType || (exports2.PollEndType = {}));
    var CohostABTestType;
    (function(CohostABTestType2) {
      CohostABTestType2[CohostABTestType2["COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_UNKNOWN"] = 0] = "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_UNKNOWN";
      CohostABTestType2[CohostABTestType2["COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_LINK_TIME_OUT_STRATEGY"] = 1] = "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_LINK_TIME_OUT_STRATEGY";
      CohostABTestType2[CohostABTestType2["COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_COHOST_RESERVATION"] = 2] = "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_COHOST_RESERVATION";
      CohostABTestType2[CohostABTestType2["COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_QUICK_PAIR_NEW_ARCH_SWITCH"] = 3] = "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_QUICK_PAIR_NEW_ARCH_SWITCH";
      CohostABTestType2[CohostABTestType2["COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_COHOST_INVITATION_TEXT"] = 4] = "COHOST_A_B_TEST_TYPE_COHOST_AB_TEST_TYPE_COHOST_INVITATION_TEXT";
      CohostABTestType2[CohostABTestType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(CohostABTestType = exports2.CohostABTestType || (exports2.CohostABTestType = {}));
    var OptPairStatus;
    (function(OptPairStatus2) {
      OptPairStatus2[OptPairStatus2["OPT_PAIR_STATUS_UNKNOWN"] = 0] = "OPT_PAIR_STATUS_UNKNOWN";
      OptPairStatus2[OptPairStatus2["OPT_PAIR_STATUS_OFFLINE"] = 1] = "OPT_PAIR_STATUS_OFFLINE";
      OptPairStatus2[OptPairStatus2["OPT_PAIR_STATUS_FINISHED"] = 2] = "OPT_PAIR_STATUS_FINISHED";
      OptPairStatus2[OptPairStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(OptPairStatus = exports2.OptPairStatus || (exports2.OptPairStatus = {}));
    var ContentPositionType;
    (function(ContentPositionType2) {
      ContentPositionType2[ContentPositionType2["CONTENT_POSITION_TYPE_UNKNOWN"] = 0] = "CONTENT_POSITION_TYPE_UNKNOWN";
      ContentPositionType2[ContentPositionType2["CONTENT_POSITION_TYPE_STREAM"] = 1] = "CONTENT_POSITION_TYPE_STREAM";
      ContentPositionType2[ContentPositionType2["CONTENT_POSITION_TYPE_LIVE_STUDIO_STREAM_PORTRAIT"] = 2] = "CONTENT_POSITION_TYPE_LIVE_STUDIO_STREAM_PORTRAIT";
      ContentPositionType2[ContentPositionType2["CONTENT_POSITION_TYPE_LIVE_STUDIO_STREAM_LANDSCAPE"] = 3] = "CONTENT_POSITION_TYPE_LIVE_STUDIO_STREAM_LANDSCAPE";
      ContentPositionType2[ContentPositionType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ContentPositionType = exports2.ContentPositionType || (exports2.ContentPositionType = {}));
    var MultiGuestOutsideRoomInviteSource;
    (function(MultiGuestOutsideRoomInviteSource2) {
      MultiGuestOutsideRoomInviteSource2[MultiGuestOutsideRoomInviteSource2["MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_UNKNOWN"] = 0] = "MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_UNKNOWN";
      MultiGuestOutsideRoomInviteSource2[MultiGuestOutsideRoomInviteSource2["MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_PANEL"] = 1] = "MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_PANEL";
      MultiGuestOutsideRoomInviteSource2[MultiGuestOutsideRoomInviteSource2["MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_CAPSULE"] = 2] = "MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_CAPSULE";
      MultiGuestOutsideRoomInviteSource2[MultiGuestOutsideRoomInviteSource2["MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_EMPTY_POSITION"] = 3] = "MULTI_GUEST_OUTSIDE_ROOM_INVITE_SOURCE_OUTSIDE_ROOM_INVITE_SOURCE_EMPTY_POSITION";
      MultiGuestOutsideRoomInviteSource2[MultiGuestOutsideRoomInviteSource2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(MultiGuestOutsideRoomInviteSource = exports2.MultiGuestOutsideRoomInviteSource || (exports2.MultiGuestOutsideRoomInviteSource = {}));
    var LinkUserType;
    (function(LinkUserType2) {
      LinkUserType2[LinkUserType2["LINK_USER_TYPE_DEFAULT"] = 0] = "LINK_USER_TYPE_DEFAULT";
      LinkUserType2[LinkUserType2["LINK_USER_TYPE_KARAOKE"] = 1] = "LINK_USER_TYPE_KARAOKE";
      LinkUserType2[LinkUserType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LinkUserType = exports2.LinkUserType || (exports2.LinkUserType = {}));
    var ContentInviteSource;
    (function(ContentInviteSource2) {
      ContentInviteSource2[ContentInviteSource2["CONTENT_INVITE_SOURCE_INVITE_SOURCE_UNKNOWN"] = 0] = "CONTENT_INVITE_SOURCE_INVITE_SOURCE_UNKNOWN";
      ContentInviteSource2[ContentInviteSource2["CONTENT_INVITE_SOURCE_INVITE_SOURCE_PANEL_GO_LIVE"] = 1] = "CONTENT_INVITE_SOURCE_INVITE_SOURCE_PANEL_GO_LIVE";
      ContentInviteSource2[ContentInviteSource2["CONTENT_INVITE_SOURCE_INVITE_SOURCE_MUTUAL_NOTICE"] = 2] = "CONTENT_INVITE_SOURCE_INVITE_SOURCE_MUTUAL_NOTICE";
      ContentInviteSource2[ContentInviteSource2["CONTENT_INVITE_SOURCE_INVITE_SOURCE_USER_PROFILE"] = 3] = "CONTENT_INVITE_SOURCE_INVITE_SOURCE_USER_PROFILE";
      ContentInviteSource2[ContentInviteSource2["CONTENT_INVITE_SOURCE_INVITE_SOURCE_RESERVE"] = 4] = "CONTENT_INVITE_SOURCE_INVITE_SOURCE_RESERVE";
      ContentInviteSource2[ContentInviteSource2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(ContentInviteSource = exports2.ContentInviteSource || (exports2.ContentInviteSource = {}));
    var LinkmicShareRevenueSetting;
    (function(LinkmicShareRevenueSetting2) {
      LinkmicShareRevenueSetting2[LinkmicShareRevenueSetting2["LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_NOT_SET"] = 0] = "LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_NOT_SET";
      LinkmicShareRevenueSetting2[LinkmicShareRevenueSetting2["LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_OPEN"] = 1] = "LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_OPEN";
      LinkmicShareRevenueSetting2[LinkmicShareRevenueSetting2["LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_CLOSE"] = 2] = "LINKMIC_SHARE_REVENUE_SETTING_LINK_MIC_SHARE_REVENUE_CLOSE";
      LinkmicShareRevenueSetting2[LinkmicShareRevenueSetting2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(LinkmicShareRevenueSetting = exports2.LinkmicShareRevenueSetting || (exports2.LinkmicShareRevenueSetting = {}));
    var PosIdentityType;
    (function(PosIdentityType2) {
      PosIdentityType2[PosIdentityType2["POS_IDENTITY_TYPE_IDENTITY_EMPTY_SLOT"] = 0] = "POS_IDENTITY_TYPE_IDENTITY_EMPTY_SLOT";
      PosIdentityType2[PosIdentityType2["POS_IDENTITY_TYPE_IDENTITY_RT_C_USER_ID"] = 1] = "POS_IDENTITY_TYPE_IDENTITY_RT_C_USER_ID";
      PosIdentityType2[PosIdentityType2["POS_IDENTITY_TYPE_IDENTITY_RT_C_STREAM_ID"] = 2] = "POS_IDENTITY_TYPE_IDENTITY_RT_C_STREAM_ID";
      PosIdentityType2[PosIdentityType2["POS_IDENTITY_TYPE_IDENTITY_LIVE_USER_ID"] = 3] = "POS_IDENTITY_TYPE_IDENTITY_LIVE_USER_ID";
      PosIdentityType2[PosIdentityType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(PosIdentityType = exports2.PosIdentityType || (exports2.PosIdentityType = {}));
    var JoinType;
    (function(JoinType2) {
      JoinType2[JoinType2["JOIN_TYPE_UNKNOWN"] = 0] = "JOIN_TYPE_UNKNOWN";
      JoinType2[JoinType2["JOIN_TYPE_CHANNEL_APPLY"] = 1] = "JOIN_TYPE_CHANNEL_APPLY";
      JoinType2[JoinType2["JOIN_TYPE_CHANNEL_INVITE"] = 2] = "JOIN_TYPE_CHANNEL_INVITE";
      JoinType2[JoinType2["JOIN_TYPE_GROUP_APPLY"] = 100] = "JOIN_TYPE_GROUP_APPLY";
      JoinType2[JoinType2["JOIN_TYPE_GROUP_APPLY_FOLLOW"] = 101] = "JOIN_TYPE_GROUP_APPLY_FOLLOW";
      JoinType2[JoinType2["JOIN_TYPE_GROUP_INVITE"] = 102] = "JOIN_TYPE_GROUP_INVITE";
      JoinType2[JoinType2["JOIN_TYPE_GROUP_INVITE_FOLLOW"] = 103] = "JOIN_TYPE_GROUP_INVITE_FOLLOW";
      JoinType2[JoinType2["JOIN_TYPE_GROUP_OWNER_JOIN"] = 104] = "JOIN_TYPE_GROUP_OWNER_JOIN";
      JoinType2[JoinType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(JoinType = exports2.JoinType || (exports2.JoinType = {}));
    var CohostLayoutMode;
    (function(CohostLayoutMode2) {
      CohostLayoutMode2[CohostLayoutMode2["COHOST_LAYOUT_MODE_NORMAL"] = 0] = "COHOST_LAYOUT_MODE_NORMAL";
      CohostLayoutMode2[CohostLayoutMode2["COHOST_LAYOUT_MODE_SCREEN_SHARE"] = 1] = "COHOST_LAYOUT_MODE_SCREEN_SHARE";
      CohostLayoutMode2[CohostLayoutMode2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(CohostLayoutMode = exports2.CohostLayoutMode || (exports2.CohostLayoutMode = {}));
    var TagClassification;
    (function(TagClassification2) {
      TagClassification2[TagClassification2["TAG_CLASSIFICATION_UNKNOWN"] = 0] = "TAG_CLASSIFICATION_UNKNOWN";
      TagClassification2[TagClassification2["TAG_CLASSIFICATION_COHOST_HISTORY"] = 1] = "TAG_CLASSIFICATION_COHOST_HISTORY";
      TagClassification2[TagClassification2["TAG_CLASSIFICATION_FIRST_DEGREE_RELATION"] = 2] = "TAG_CLASSIFICATION_FIRST_DEGREE_RELATION";
      TagClassification2[TagClassification2["TAG_CLASSIFICATION_SECOND_DEGREE_RELATION"] = 3] = "TAG_CLASSIFICATION_SECOND_DEGREE_RELATION";
      TagClassification2[TagClassification2["TAG_CLASSIFICATION_RANK"] = 4] = "TAG_CLASSIFICATION_RANK";
      TagClassification2[TagClassification2["TAG_CLASSIFICATION_SIMILAR_INTERESTS"] = 5] = "TAG_CLASSIFICATION_SIMILAR_INTERESTS";
      TagClassification2[TagClassification2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(TagClassification = exports2.TagClassification || (exports2.TagClassification = {}));
    var SourceType;
    (function(SourceType2) {
      SourceType2[SourceType2["SOURCE_TYPE_UNKNOWN"] = 0] = "SOURCE_TYPE_UNKNOWN";
      SourceType2[SourceType2["SOURCE_TYPE_FRIEND_LIST"] = 1] = "SOURCE_TYPE_FRIEND_LIST";
      SourceType2[SourceType2["SOURCE_TYPE_RECOMMEND_LIST"] = 2] = "SOURCE_TYPE_RECOMMEND_LIST";
      SourceType2[SourceType2["SOURCE_TYPE_RECENT"] = 3] = "SOURCE_TYPE_RECENT";
      SourceType2[SourceType2["SOURCE_TYPE_OTHER_FOLLOW"] = 4] = "SOURCE_TYPE_OTHER_FOLLOW";
      SourceType2[SourceType2["SOURCE_TYPE_QUICK_PAIR"] = 5] = "SOURCE_TYPE_QUICK_PAIR";
      SourceType2[SourceType2["SOURCE_TYPE_ACTIVITY"] = 6] = "SOURCE_TYPE_ACTIVITY";
      SourceType2[SourceType2["SOURCE_TYPE_QUICK_RECOMMEND"] = 7] = "SOURCE_TYPE_QUICK_RECOMMEND";
      SourceType2[SourceType2["SOURCE_TYPE_OFFICIAL_CHANNEL"] = 8] = "SOURCE_TYPE_OFFICIAL_CHANNEL";
      SourceType2[SourceType2["SOURCE_TYPE_BEST_TEAMMATE"] = 9] = "SOURCE_TYPE_BEST_TEAMMATE";
      SourceType2[SourceType2["SOURCE_TYPE_RESERVATION"] = 10] = "SOURCE_TYPE_RESERVATION";
      SourceType2[SourceType2["SOURCE_TYPE_PAIRING"] = 11] = "SOURCE_TYPE_PAIRING";
      SourceType2[SourceType2["SOURCE_TYPE_PAIRING_ON_RESERVATION"] = 12] = "SOURCE_TYPE_PAIRING_ON_RESERVATION";
      SourceType2[SourceType2["SOURCE_TYPE_TOPIC_QUICK_PAIR"] = 13] = "SOURCE_TYPE_TOPIC_QUICK_PAIR";
      SourceType2[SourceType2["SOURCE_TYPE_TOPIC_QUICK_RECOMMEND"] = 14] = "SOURCE_TYPE_TOPIC_QUICK_RECOMMEND";
      SourceType2[SourceType2["SOURCE_TYPE_ONLINE_FRIEND_CAPSULE"] = 15] = "SOURCE_TYPE_ONLINE_FRIEND_CAPSULE";
      SourceType2[SourceType2["SOURCE_TYPE_WEEKLY_RANK"] = 20] = "SOURCE_TYPE_WEEKLY_RANK";
      SourceType2[SourceType2["SOURCE_TYPE_HOURLY_RANK"] = 21] = "SOURCE_TYPE_HOURLY_RANK";
      SourceType2[SourceType2["SOURCE_TYPE_WEEKLY_RISING"] = 23] = "SOURCE_TYPE_WEEKLY_RISING";
      SourceType2[SourceType2["SOURCE_TYPE_WEEKLY_ROOKIE"] = 24] = "SOURCE_TYPE_WEEKLY_ROOKIE";
      SourceType2[SourceType2["SOURCE_TYPE_CONNECTION_LIST"] = 25] = "SOURCE_TYPE_CONNECTION_LIST";
      SourceType2[SourceType2["SOURCE_TYPE_DAILY_RANK"] = 26] = "SOURCE_TYPE_DAILY_RANK";
      SourceType2[SourceType2["SOURCE_TYPE_DAILY_RANK_HALL_OF_FAME"] = 27] = "SOURCE_TYPE_DAILY_RANK_HALL_OF_FAME";
      SourceType2[SourceType2["SOURCE_TYPE_RESERVATION_BUBBLE"] = 28] = "SOURCE_TYPE_RESERVATION_BUBBLE";
      SourceType2[SourceType2["SOURCE_TYPE_PAIRING_BUBBLE"] = 29] = "SOURCE_TYPE_PAIRING_BUBBLE";
      SourceType2[SourceType2["SOURCE_TYPE_LEAGUE_PHASE_ONE"] = 30] = "SOURCE_TYPE_LEAGUE_PHASE_ONE";
      SourceType2[SourceType2["SOURCE_TYPE_LEAGUE_PHASE_TWO"] = 31] = "SOURCE_TYPE_LEAGUE_PHASE_TWO";
      SourceType2[SourceType2["SOURCE_TYPE_LEAGUE_PHASE_THREE"] = 32] = "SOURCE_TYPE_LEAGUE_PHASE_THREE";
      SourceType2[SourceType2["SOURCE_TYPE_DAILY_ROOKIE"] = 33] = "SOURCE_TYPE_DAILY_ROOKIE";
      SourceType2[SourceType2["SOURCE_TYPE_MAY_KNOW_LIST"] = 34] = "SOURCE_TYPE_MAY_KNOW_LIST";
      SourceType2[SourceType2["SOURCE_TYPE_BANNER"] = 35] = "SOURCE_TYPE_BANNER";
      SourceType2[SourceType2["SOURCE_TYPE_FANS_TEAM_RANK"] = 36] = "SOURCE_TYPE_FANS_TEAM_RANK";
      SourceType2[SourceType2["SOURCE_TYPE_SEARCH"] = 37] = "SOURCE_TYPE_SEARCH";
      SourceType2[SourceType2["SOURCE_TYPE_E_OY_RANK_LIST"] = 38] = "SOURCE_TYPE_E_OY_RANK_LIST";
      SourceType2[SourceType2["SOURCE_TYPE_LEAGUE_CAMPAIGN_RANK"] = 39] = "SOURCE_TYPE_LEAGUE_CAMPAIGN_RANK";
      SourceType2[SourceType2["SOURCE_TYPE_CREATOR_CLASS_RANK"] = 40] = "SOURCE_TYPE_CREATOR_CLASS_RANK";
      SourceType2[SourceType2["SOURCE_TYPE_HISTORY"] = 41] = "SOURCE_TYPE_HISTORY";
      SourceType2[SourceType2["SOURCE_TYPE_QUICK_RECOMMEND_DURING_COHOST"] = 43] = "SOURCE_TYPE_QUICK_RECOMMEND_DURING_COHOST";
      SourceType2[SourceType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(SourceType = exports2.SourceType || (exports2.SourceType = {}));
    var BattleType;
    (function(BattleType2) {
      BattleType2[BattleType2["BATTLE_TYPE_UNKNOWN_BATTLE_TYPE"] = 0] = "BATTLE_TYPE_UNKNOWN_BATTLE_TYPE";
      BattleType2[BattleType2["BATTLE_TYPE_NORMAL_BATTLE"] = 1] = "BATTLE_TYPE_NORMAL_BATTLE";
      BattleType2[BattleType2["BATTLE_TYPE_TEAM_BATTLE"] = 2] = "BATTLE_TYPE_TEAM_BATTLE";
      BattleType2[BattleType2["BATTLE_TYPE_INDIVIDUAL_BATTLE"] = 3] = "BATTLE_TYPE_INDIVIDUAL_BATTLE";
      BattleType2[BattleType2["BATTLE_TYPE_1_V_N"] = 4] = "BATTLE_TYPE_1_V_N";
      BattleType2[BattleType2["BATTLE_TYPE_TAKE_THE_STAGE"] = 51] = "BATTLE_TYPE_TAKE_THE_STAGE";
      BattleType2[BattleType2["BATTLE_TYPE_GROUP_SHOW"] = 52] = "BATTLE_TYPE_GROUP_SHOW";
      BattleType2[BattleType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BattleType = exports2.BattleType || (exports2.BattleType = {}));
    var BattleInviteType;
    (function(BattleInviteType2) {
      BattleInviteType2[BattleInviteType2["BATTLE_INVITE_TYPE_NORMAL"] = 0] = "BATTLE_INVITE_TYPE_NORMAL";
      BattleInviteType2[BattleInviteType2["BATTLE_INVITE_TYPE_AGAIN"] = 1] = "BATTLE_INVITE_TYPE_AGAIN";
      BattleInviteType2[BattleInviteType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BattleInviteType = exports2.BattleInviteType || (exports2.BattleInviteType = {}));
    var CommonMessageData_IMDispatchStrategy;
    (function(CommonMessageData_IMDispatchStrategy2) {
      CommonMessageData_IMDispatchStrategy2[CommonMessageData_IMDispatchStrategy2["IM_DISPATCH_STRATEGY_DEFAULT"] = 0] = "IM_DISPATCH_STRATEGY_DEFAULT";
      CommonMessageData_IMDispatchStrategy2[CommonMessageData_IMDispatchStrategy2["IM_DISPATCH_STRATEGY_BYPASS_DISPATCH_QUEUE"] = 1] = "IM_DISPATCH_STRATEGY_BYPASS_DISPATCH_QUEUE";
      CommonMessageData_IMDispatchStrategy2[CommonMessageData_IMDispatchStrategy2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(CommonMessageData_IMDispatchStrategy = exports2.CommonMessageData_IMDispatchStrategy || (exports2.CommonMessageData_IMDispatchStrategy = {}));
    var Text_ShowType;
    (function(Text_ShowType2) {
      Text_ShowType2[Text_ShowType2["SHOW_TYPE_NORMAL"] = 0] = "SHOW_TYPE_NORMAL";
      Text_ShowType2[Text_ShowType2["SHOW_TYPE_FADE_IN_OUT"] = 1] = "SHOW_TYPE_FADE_IN_OUT";
      Text_ShowType2[Text_ShowType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Text_ShowType = exports2.Text_ShowType || (exports2.Text_ShowType = {}));
    var BadgeStruct_BadgeDisplayType;
    (function(BadgeStruct_BadgeDisplayType2) {
      BadgeStruct_BadgeDisplayType2[BadgeStruct_BadgeDisplayType2["BADGEDISPLAYTYPE_UNKNOWN"] = 0] = "BADGEDISPLAYTYPE_UNKNOWN";
      BadgeStruct_BadgeDisplayType2[BadgeStruct_BadgeDisplayType2["BADGEDISPLAYTYPE_IMAGE"] = 1] = "BADGEDISPLAYTYPE_IMAGE";
      BadgeStruct_BadgeDisplayType2[BadgeStruct_BadgeDisplayType2["BADGEDISPLAYTYPE_TEXT"] = 2] = "BADGEDISPLAYTYPE_TEXT";
      BadgeStruct_BadgeDisplayType2[BadgeStruct_BadgeDisplayType2["BADGEDISPLAYTYPE_STRING"] = 3] = "BADGEDISPLAYTYPE_STRING";
      BadgeStruct_BadgeDisplayType2[BadgeStruct_BadgeDisplayType2["BADGEDISPLAYTYPE_COMBINE"] = 4] = "BADGEDISPLAYTYPE_COMBINE";
      BadgeStruct_BadgeDisplayType2[BadgeStruct_BadgeDisplayType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BadgeStruct_BadgeDisplayType = exports2.BadgeStruct_BadgeDisplayType || (exports2.BadgeStruct_BadgeDisplayType = {}));
    var BadgeStruct_BadgePriorityType;
    (function(BadgeStruct_BadgePriorityType2) {
      BadgeStruct_BadgePriorityType2[BadgeStruct_BadgePriorityType2["BADGE_PRIORITY_TYPE_UNKNOWN"] = 0] = "BADGE_PRIORITY_TYPE_UNKNOWN";
      BadgeStruct_BadgePriorityType2[BadgeStruct_BadgePriorityType2["BADGE_PRIORITY_TYPE_STRONG_RELATION"] = 10] = "BADGE_PRIORITY_TYPE_STRONG_RELATION";
      BadgeStruct_BadgePriorityType2[BadgeStruct_BadgePriorityType2["BADGE_PRIORITY_TYPE_PLATFORM"] = 20] = "BADGE_PRIORITY_TYPE_PLATFORM";
      BadgeStruct_BadgePriorityType2[BadgeStruct_BadgePriorityType2["BADGE_PRIORITY_TYPE_RELATION"] = 30] = "BADGE_PRIORITY_TYPE_RELATION";
      BadgeStruct_BadgePriorityType2[BadgeStruct_BadgePriorityType2["BADGE_PRIORITY_TYPE_ACTIVITY"] = 40] = "BADGE_PRIORITY_TYPE_ACTIVITY";
      BadgeStruct_BadgePriorityType2[BadgeStruct_BadgePriorityType2["BADGE_PRIORITY_TYPE_RANK_LIST"] = 50] = "BADGE_PRIORITY_TYPE_RANK_LIST";
      BadgeStruct_BadgePriorityType2[BadgeStruct_BadgePriorityType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BadgeStruct_BadgePriorityType = exports2.BadgeStruct_BadgePriorityType || (exports2.BadgeStruct_BadgePriorityType = {}));
    var BadgeStruct_BadgeSceneType;
    (function(BadgeStruct_BadgeSceneType2) {
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["BADGE_SCENE_TYPE_UNKNOWN"] = 0] = "BADGE_SCENE_TYPE_UNKNOWN";
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["BADGE_SCENE_TYPE_ADMIN"] = 1] = "BADGE_SCENE_TYPE_ADMIN";
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["BADGE_SCENE_TYPE_FIRST_RECHARGE"] = 2] = "BADGE_SCENE_TYPE_FIRST_RECHARGE";
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["BADGE_SCENE_TYPE_FRIENDS"] = 3] = "BADGE_SCENE_TYPE_FRIENDS";
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["BADGE_SCENE_TYPE_SUBSCRIBER"] = 4] = "BADGE_SCENE_TYPE_SUBSCRIBER";
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["BADGE_SCENE_TYPE_ACTIVITY"] = 5] = "BADGE_SCENE_TYPE_ACTIVITY";
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["BADGE_SCENE_TYPE_RANK_LIST"] = 6] = "BADGE_SCENE_TYPE_RANK_LIST";
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["BADGE_SCENE_TYPE_NEW_SUBSCRIBER"] = 7] = "BADGE_SCENE_TYPE_NEW_SUBSCRIBER";
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["BADGE_SCENE_TYPE_USER_GRADE"] = 8] = "BADGE_SCENE_TYPE_USER_GRADE";
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["BADGE_SCENE_TYPE_STATE_CONTROLLED_MEDIA"] = 9] = "BADGE_SCENE_TYPE_STATE_CONTROLLED_MEDIA";
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["BADGE_SCENE_TYPE_FANS"] = 10] = "BADGE_SCENE_TYPE_FANS";
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["BADGE_SCENE_TYPE_LIVE_PRO"] = 11] = "BADGE_SCENE_TYPE_LIVE_PRO";
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["BADGE_SCENE_TYPE_ANCHOR"] = 12] = "BADGE_SCENE_TYPE_ANCHOR";
      BadgeStruct_BadgeSceneType2[BadgeStruct_BadgeSceneType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BadgeStruct_BadgeSceneType = exports2.BadgeStruct_BadgeSceneType || (exports2.BadgeStruct_BadgeSceneType = {}));
    var BadgeStruct_DisplayStatus;
    (function(BadgeStruct_DisplayStatus2) {
      BadgeStruct_DisplayStatus2[BadgeStruct_DisplayStatus2["DISPLAY_STATUS_NORMAL"] = 0] = "DISPLAY_STATUS_NORMAL";
      BadgeStruct_DisplayStatus2[BadgeStruct_DisplayStatus2["DISPLAY_STATUS_SHADOW"] = 1] = "DISPLAY_STATUS_SHADOW";
      BadgeStruct_DisplayStatus2[BadgeStruct_DisplayStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BadgeStruct_DisplayStatus = exports2.BadgeStruct_DisplayStatus || (exports2.BadgeStruct_DisplayStatus = {}));
    var BadgeStruct_BadgeExhibitionType;
    (function(BadgeStruct_BadgeExhibitionType2) {
      BadgeStruct_BadgeExhibitionType2[BadgeStruct_BadgeExhibitionType2["BADGE_EXHIBITION_TYPE_BADGE"] = 0] = "BADGE_EXHIBITION_TYPE_BADGE";
      BadgeStruct_BadgeExhibitionType2[BadgeStruct_BadgeExhibitionType2["BADGE_EXHIBITION_TYPE_IDENTITY_LABEL"] = 1] = "BADGE_EXHIBITION_TYPE_IDENTITY_LABEL";
      BadgeStruct_BadgeExhibitionType2[BadgeStruct_BadgeExhibitionType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BadgeStruct_BadgeExhibitionType = exports2.BadgeStruct_BadgeExhibitionType || (exports2.BadgeStruct_BadgeExhibitionType = {}));
    var BadgeStruct_Position;
    (function(BadgeStruct_Position2) {
      BadgeStruct_Position2[BadgeStruct_Position2["POSITIONUNKNOWN"] = 0] = "POSITIONUNKNOWN";
      BadgeStruct_Position2[BadgeStruct_Position2["POSITIONLEFT"] = 1] = "POSITIONLEFT";
      BadgeStruct_Position2[BadgeStruct_Position2["POSITIONRIGHT"] = 2] = "POSITIONRIGHT";
      BadgeStruct_Position2[BadgeStruct_Position2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BadgeStruct_Position = exports2.BadgeStruct_Position || (exports2.BadgeStruct_Position = {}));
    var BadgeStruct_HorizontalPaddingRule;
    (function(BadgeStruct_HorizontalPaddingRule2) {
      BadgeStruct_HorizontalPaddingRule2[BadgeStruct_HorizontalPaddingRule2["HORIZONTAL_PADDING_RULE_USE_MIDDLE_AND_WIDTH"] = 0] = "HORIZONTAL_PADDING_RULE_USE_MIDDLE_AND_WIDTH";
      BadgeStruct_HorizontalPaddingRule2[BadgeStruct_HorizontalPaddingRule2["HORIZONTAL_PADDING_RULE_USE_LEFT_AND_MIDDLE_AND_RIGHT"] = 1] = "HORIZONTAL_PADDING_RULE_USE_LEFT_AND_MIDDLE_AND_RIGHT";
      BadgeStruct_HorizontalPaddingRule2[BadgeStruct_HorizontalPaddingRule2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BadgeStruct_HorizontalPaddingRule = exports2.BadgeStruct_HorizontalPaddingRule || (exports2.BadgeStruct_HorizontalPaddingRule = {}));
    var BadgeStruct_VerticalPaddingRule;
    (function(BadgeStruct_VerticalPaddingRule2) {
      BadgeStruct_VerticalPaddingRule2[BadgeStruct_VerticalPaddingRule2["VERTICAL_PADDING_RULE_USE_DEFAULT"] = 0] = "VERTICAL_PADDING_RULE_USE_DEFAULT";
      BadgeStruct_VerticalPaddingRule2[BadgeStruct_VerticalPaddingRule2["VERTICAL_PADDING_RULE_USE_TOP_AND_BOTTOM"] = 1] = "VERTICAL_PADDING_RULE_USE_TOP_AND_BOTTOM";
      BadgeStruct_VerticalPaddingRule2[BadgeStruct_VerticalPaddingRule2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(BadgeStruct_VerticalPaddingRule = exports2.BadgeStruct_VerticalPaddingRule || (exports2.BadgeStruct_VerticalPaddingRule = {}));
    var User_LiveEventInfo_EventPayMethod;
    (function(User_LiveEventInfo_EventPayMethod2) {
      User_LiveEventInfo_EventPayMethod2[User_LiveEventInfo_EventPayMethod2["EVENTPAYMETHODINVALID"] = 0] = "EVENTPAYMETHODINVALID";
      User_LiveEventInfo_EventPayMethod2[User_LiveEventInfo_EventPayMethod2["EVENTPAYMETHODCOINS"] = 1] = "EVENTPAYMETHODCOINS";
      User_LiveEventInfo_EventPayMethod2[User_LiveEventInfo_EventPayMethod2["EVENTPAYMETHODCASH"] = 2] = "EVENTPAYMETHODCASH";
      User_LiveEventInfo_EventPayMethod2[User_LiveEventInfo_EventPayMethod2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(User_LiveEventInfo_EventPayMethod = exports2.User_LiveEventInfo_EventPayMethod || (exports2.User_LiveEventInfo_EventPayMethod = {}));
    var User_EcommerceEntrance_CreatorType;
    (function(User_EcommerceEntrance_CreatorType2) {
      User_EcommerceEntrance_CreatorType2[User_EcommerceEntrance_CreatorType2["UNDEFINED"] = 0] = "UNDEFINED";
      User_EcommerceEntrance_CreatorType2[User_EcommerceEntrance_CreatorType2["OFFICIAL"] = 1] = "OFFICIAL";
      User_EcommerceEntrance_CreatorType2[User_EcommerceEntrance_CreatorType2["MARKET"] = 2] = "MARKET";
      User_EcommerceEntrance_CreatorType2[User_EcommerceEntrance_CreatorType2["NORMAL"] = 3] = "NORMAL";
      User_EcommerceEntrance_CreatorType2[User_EcommerceEntrance_CreatorType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(User_EcommerceEntrance_CreatorType = exports2.User_EcommerceEntrance_CreatorType || (exports2.User_EcommerceEntrance_CreatorType = {}));
    var User_EcommerceEntrance_EntranceType;
    (function(User_EcommerceEntrance_EntranceType2) {
      User_EcommerceEntrance_EntranceType2[User_EcommerceEntrance_EntranceType2["PROFILE"] = 0] = "PROFILE";
      User_EcommerceEntrance_EntranceType2[User_EcommerceEntrance_EntranceType2["SHOWCASE"] = 1] = "SHOWCASE";
      User_EcommerceEntrance_EntranceType2[User_EcommerceEntrance_EntranceType2["SHOP"] = 2] = "SHOP";
      User_EcommerceEntrance_EntranceType2[User_EcommerceEntrance_EntranceType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(User_EcommerceEntrance_EntranceType = exports2.User_EcommerceEntrance_EntranceType || (exports2.User_EcommerceEntrance_EntranceType = {}));
    var User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType;
    (function(User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType2) {
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType2[User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType2["NONE"] = 0] = "NONE";
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType2[User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType2["OFFICIAL"] = 1] = "OFFICIAL";
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType2[User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType2["AUTHORIZED"] = 2] = "AUTHORIZED";
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType2[User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType2["STORE_BRAND_LABEL_TYPE_BLUE_V"] = 3] = "STORE_BRAND_LABEL_TYPE_BLUE_V";
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType2[User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType2["STORE_BRAND_LABEL_TYPE_TOP_CHOICE"] = 4] = "STORE_BRAND_LABEL_TYPE_TOP_CHOICE";
      User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType2[User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType = exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType || (exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreBrandLabelType = {}));
    var User_FansClub_PreferntialType;
    (function(User_FansClub_PreferntialType2) {
      User_FansClub_PreferntialType2[User_FansClub_PreferntialType2["PRESONALPROFILE"] = 0] = "PRESONALPROFILE";
      User_FansClub_PreferntialType2[User_FansClub_PreferntialType2["OTHERROOM"] = 1] = "OTHERROOM";
      User_FansClub_PreferntialType2[User_FansClub_PreferntialType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(User_FansClub_PreferntialType = exports2.User_FansClub_PreferntialType || (exports2.User_FansClub_PreferntialType = {}));
    var User_FansClub_FansClubData_BadgeIcon;
    (function(User_FansClub_FansClubData_BadgeIcon2) {
      User_FansClub_FansClubData_BadgeIcon2[User_FansClub_FansClubData_BadgeIcon2["UNKNOWN"] = 0] = "UNKNOWN";
      User_FansClub_FansClubData_BadgeIcon2[User_FansClub_FansClubData_BadgeIcon2["ICON"] = 1] = "ICON";
      User_FansClub_FansClubData_BadgeIcon2[User_FansClub_FansClubData_BadgeIcon2["SMALLICON"] = 2] = "SMALLICON";
      User_FansClub_FansClubData_BadgeIcon2[User_FansClub_FansClubData_BadgeIcon2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(User_FansClub_FansClubData_BadgeIcon = exports2.User_FansClub_FansClubData_BadgeIcon || (exports2.User_FansClub_FansClubData_BadgeIcon = {}));
    var User_FansClub_FansClubData_UserFansClubStatus;
    (function(User_FansClub_FansClubData_UserFansClubStatus2) {
      User_FansClub_FansClubData_UserFansClubStatus2[User_FansClub_FansClubData_UserFansClubStatus2["NOTJOINED"] = 0] = "NOTJOINED";
      User_FansClub_FansClubData_UserFansClubStatus2[User_FansClub_FansClubData_UserFansClubStatus2["ACTIVE"] = 1] = "ACTIVE";
      User_FansClub_FansClubData_UserFansClubStatus2[User_FansClub_FansClubData_UserFansClubStatus2["INACTIVE"] = 2] = "INACTIVE";
      User_FansClub_FansClubData_UserFansClubStatus2[User_FansClub_FansClubData_UserFansClubStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(User_FansClub_FansClubData_UserFansClubStatus = exports2.User_FansClub_FansClubData_UserFansClubStatus || (exports2.User_FansClub_FansClubData_UserFansClubStatus = {}));
    var Emote_AuditInfo_AuditTaskType;
    (function(Emote_AuditInfo_AuditTaskType2) {
      Emote_AuditInfo_AuditTaskType2[Emote_AuditInfo_AuditTaskType2["AUDIT_TASK_TYPE_DEFAULT"] = 0] = "AUDIT_TASK_TYPE_DEFAULT";
      Emote_AuditInfo_AuditTaskType2[Emote_AuditInfo_AuditTaskType2["AUDIT_TASK_TYPE_APPEAL"] = 1] = "AUDIT_TASK_TYPE_APPEAL";
      Emote_AuditInfo_AuditTaskType2[Emote_AuditInfo_AuditTaskType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(Emote_AuditInfo_AuditTaskType = exports2.Emote_AuditInfo_AuditTaskType || (exports2.Emote_AuditInfo_AuditTaskType = {}));
    var WebcastChatMessage_CommentTag;
    (function(WebcastChatMessage_CommentTag2) {
      WebcastChatMessage_CommentTag2[WebcastChatMessage_CommentTag2["COMMENT_TAG_NORMAL"] = 0] = "COMMENT_TAG_NORMAL";
      WebcastChatMessage_CommentTag2[WebcastChatMessage_CommentTag2["COMMENT_TAG_CANDIDATE"] = 1] = "COMMENT_TAG_CANDIDATE";
      WebcastChatMessage_CommentTag2[WebcastChatMessage_CommentTag2["COMMENT_TAG_OVERAGE"] = 2] = "COMMENT_TAG_OVERAGE";
      WebcastChatMessage_CommentTag2[WebcastChatMessage_CommentTag2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(WebcastChatMessage_CommentTag = exports2.WebcastChatMessage_CommentTag || (exports2.WebcastChatMessage_CommentTag = {}));
    var EmoteUploadInfo_UserEmoteUploadSource;
    (function(EmoteUploadInfo_UserEmoteUploadSource2) {
      EmoteUploadInfo_UserEmoteUploadSource2[EmoteUploadInfo_UserEmoteUploadSource2["USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR"] = 0] = "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_ANCHOR";
      EmoteUploadInfo_UserEmoteUploadSource2[EmoteUploadInfo_UserEmoteUploadSource2["USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER"] = 1] = "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_SUBSCRIBER";
      EmoteUploadInfo_UserEmoteUploadSource2[EmoteUploadInfo_UserEmoteUploadSource2["USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR"] = 2] = "USER_EMOTE_UPLOAD_SOURCE_EMOTE_UPLOAD_SOURCE_MODERATOR";
      EmoteUploadInfo_UserEmoteUploadSource2[EmoteUploadInfo_UserEmoteUploadSource2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(EmoteUploadInfo_UserEmoteUploadSource = exports2.EmoteUploadInfo_UserEmoteUploadSource || (exports2.EmoteUploadInfo_UserEmoteUploadSource = {}));
    var WebcastMemberMessage_DisplayStyle;
    (function(WebcastMemberMessage_DisplayStyle2) {
      WebcastMemberMessage_DisplayStyle2[WebcastMemberMessage_DisplayStyle2["DISPLAY_STYLE_NORMAL"] = 0] = "DISPLAY_STYLE_NORMAL";
      WebcastMemberMessage_DisplayStyle2[WebcastMemberMessage_DisplayStyle2["DISPLAY_STYLE_STAY"] = 1] = "DISPLAY_STYLE_STAY";
      WebcastMemberMessage_DisplayStyle2[WebcastMemberMessage_DisplayStyle2["DISPLAY_STYLE_CHAT"] = 2] = "DISPLAY_STYLE_CHAT";
      WebcastMemberMessage_DisplayStyle2[WebcastMemberMessage_DisplayStyle2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(WebcastMemberMessage_DisplayStyle = exports2.WebcastMemberMessage_DisplayStyle || (exports2.WebcastMemberMessage_DisplayStyle = {}));
    var WebcastMemberMessage_HitABStatus;
    (function(WebcastMemberMessage_HitABStatus2) {
      WebcastMemberMessage_HitABStatus2[WebcastMemberMessage_HitABStatus2["HIT_A_B_STATUS_HIT_AB_STATUS_NO_HIT"] = 0] = "HIT_A_B_STATUS_HIT_AB_STATUS_NO_HIT";
      WebcastMemberMessage_HitABStatus2[WebcastMemberMessage_HitABStatus2["HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_EXTERNAL_LINK_NEW_TEXT"] = 1] = "HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_EXTERNAL_LINK_NEW_TEXT";
      WebcastMemberMessage_HitABStatus2[WebcastMemberMessage_HitABStatus2["HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_RE_POST_NEW_TEXT"] = 2] = "HIT_A_B_STATUS_HIT_AB_STATUS_ENTER_FROM_RE_POST_NEW_TEXT";
      WebcastMemberMessage_HitABStatus2[WebcastMemberMessage_HitABStatus2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(WebcastMemberMessage_HitABStatus = exports2.WebcastMemberMessage_HitABStatus || (exports2.WebcastMemberMessage_HitABStatus = {}));
    var WebcastBarrageMessage_BarrageType;
    (function(WebcastBarrageMessage_BarrageType2) {
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_UNKNOWN"] = 0] = "BARRAGE_TYPE_UNKNOWN";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_E_COM_ORDERING"] = 1] = "BARRAGE_TYPE_E_COM_ORDERING";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_E_COM_BUYING"] = 2] = "BARRAGE_TYPE_E_COM_BUYING";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_NORMAL"] = 3] = "BARRAGE_TYPE_NORMAL";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_SUBSCRIBE"] = 4] = "BARRAGE_TYPE_SUBSCRIBE";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_EVENT_VIEW"] = 5] = "BARRAGE_TYPE_EVENT_VIEW";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_EVENT_REGISTERED"] = 6] = "BARRAGE_TYPE_EVENT_REGISTERED";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_SUBSCRIBE_GIFT"] = 7] = "BARRAGE_TYPE_SUBSCRIBE_GIFT";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_USER_UPGRADE"] = 8] = "BARRAGE_TYPE_USER_UPGRADE";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_GRADE_USER_ENTRANCE_NOTIFICATION"] = 9] = "BARRAGE_TYPE_GRADE_USER_ENTRANCE_NOTIFICATION";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_FANS_LEVEL_UPGRADE"] = 10] = "BARRAGE_TYPE_FANS_LEVEL_UPGRADE";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_FANS_LEVEL_ENTRANCE"] = 11] = "BARRAGE_TYPE_FANS_LEVEL_ENTRANCE";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_GAME_PARTNERSHIP"] = 12] = "BARRAGE_TYPE_GAME_PARTNERSHIP";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_GIFT_GALLERY"] = 13] = "BARRAGE_TYPE_GIFT_GALLERY";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_E_COM_BOUGHT"] = 14] = "BARRAGE_TYPE_E_COM_BOUGHT";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["BARRAGE_TYPE_COMMON_BARRAGE"] = 100] = "BARRAGE_TYPE_COMMON_BARRAGE";
      WebcastBarrageMessage_BarrageType2[WebcastBarrageMessage_BarrageType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(WebcastBarrageMessage_BarrageType = exports2.WebcastBarrageMessage_BarrageType || (exports2.WebcastBarrageMessage_BarrageType = {}));
    var WebcastBarrageMessage_ShowType;
    (function(WebcastBarrageMessage_ShowType2) {
      WebcastBarrageMessage_ShowType2[WebcastBarrageMessage_ShowType2["SHOW_TYPE_NORMAL"] = 0] = "SHOW_TYPE_NORMAL";
      WebcastBarrageMessage_ShowType2[WebcastBarrageMessage_ShowType2["SHOW_TYPE_FADE_IN_OUT"] = 1] = "SHOW_TYPE_FADE_IN_OUT";
      WebcastBarrageMessage_ShowType2[WebcastBarrageMessage_ShowType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(WebcastBarrageMessage_ShowType = exports2.WebcastBarrageMessage_ShowType || (exports2.WebcastBarrageMessage_ShowType = {}));
    var WebcastBarrageMessage_RenderType;
    (function(WebcastBarrageMessage_RenderType2) {
      WebcastBarrageMessage_RenderType2[WebcastBarrageMessage_RenderType2["RENDER_TYPE_NATIVE"] = 0] = "RENDER_TYPE_NATIVE";
      WebcastBarrageMessage_RenderType2[WebcastBarrageMessage_RenderType2["RENDER_TYPE_HYBRID"] = 1] = "RENDER_TYPE_HYBRID";
      WebcastBarrageMessage_RenderType2[WebcastBarrageMessage_RenderType2["RENDER_TYPE_ALPHA"] = 2] = "RENDER_TYPE_ALPHA";
      WebcastBarrageMessage_RenderType2[WebcastBarrageMessage_RenderType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(WebcastBarrageMessage_RenderType = exports2.WebcastBarrageMessage_RenderType || (exports2.WebcastBarrageMessage_RenderType = {}));
    var WebcastBarrageMessage_IconDisplayType;
    (function(WebcastBarrageMessage_IconDisplayType2) {
      WebcastBarrageMessage_IconDisplayType2[WebcastBarrageMessage_IconDisplayType2["ICON_DISPLAY_TYPE_IMAGE"] = 0] = "ICON_DISPLAY_TYPE_IMAGE";
      WebcastBarrageMessage_IconDisplayType2[WebcastBarrageMessage_IconDisplayType2["ICON_DISPLAY_TYPE_BADGE"] = 1] = "ICON_DISPLAY_TYPE_BADGE";
      WebcastBarrageMessage_IconDisplayType2[WebcastBarrageMessage_IconDisplayType2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(WebcastBarrageMessage_IconDisplayType = exports2.WebcastBarrageMessage_IconDisplayType || (exports2.WebcastBarrageMessage_IconDisplayType = {}));
    var WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result;
    (function(WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result2) {
      WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result2[WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result2["RESULT_SUCCEED"] = 0] = "RESULT_SUCCEED";
      WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result2[WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result2["RESULT_FAILED"] = 1] = "RESULT_FAILED";
      WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result2[WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result2["RESULT_BOTH_SUCCEED"] = 2] = "RESULT_BOTH_SUCCEED";
      WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result2[WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result2["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
    })(WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result || (exports2.WebcastLinkmicBattleTaskMessage_BattleTaskSettle_Result = {}));
    function createBaseCommonMessageData() {
      return {
        method: "",
        msgId: "0",
        roomId: "0",
        createTime: "0",
        monitor: 0,
        isShowMsg: false,
        describe: "",
        displayText: void 0,
        foldType: "0",
        anchorFoldType: "0",
        priorityScore: "0",
        logId: "",
        msgProcessFilterK: "",
        msgProcessFilterV: "",
        fromIdc: "",
        toIdc: "",
        filterMsgTagsList: [],
        sei: void 0,
        dependRootId: void 0,
        dependId: void 0,
        anchorPriorityScore: "0",
        roomMessageHeatLevel: "0",
        foldTypeForWeb: "0",
        anchorFoldTypeForWeb: "0",
        clientSendTime: "0",
        dispatchStrategy: 0
      };
    }
    exports2.CommonMessageData = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.method !== "") {
          writer.uint32(10).string(message.method);
        }
        if (message.msgId !== "0") {
          writer.uint32(16).int64(message.msgId);
        }
        if (message.roomId !== "0") {
          writer.uint32(24).int64(message.roomId);
        }
        if (message.createTime !== "0") {
          writer.uint32(32).int64(message.createTime);
        }
        if (message.monitor !== 0) {
          writer.uint32(40).int32(message.monitor);
        }
        if (message.isShowMsg !== false) {
          writer.uint32(48).bool(message.isShowMsg);
        }
        if (message.describe !== "") {
          writer.uint32(58).string(message.describe);
        }
        if (message.displayText !== void 0) {
          exports2.Text.encode(message.displayText, writer.uint32(66).fork()).join();
        }
        if (message.foldType !== "0") {
          writer.uint32(72).int64(message.foldType);
        }
        if (message.anchorFoldType !== "0") {
          writer.uint32(80).int64(message.anchorFoldType);
        }
        if (message.priorityScore !== "0") {
          writer.uint32(88).int64(message.priorityScore);
        }
        if (message.logId !== "") {
          writer.uint32(98).string(message.logId);
        }
        if (message.msgProcessFilterK !== "") {
          writer.uint32(106).string(message.msgProcessFilterK);
        }
        if (message.msgProcessFilterV !== "") {
          writer.uint32(114).string(message.msgProcessFilterV);
        }
        if (message.fromIdc !== "") {
          writer.uint32(122).string(message.fromIdc);
        }
        if (message.toIdc !== "") {
          writer.uint32(130).string(message.toIdc);
        }
        for (const v of message.filterMsgTagsList) {
          writer.uint32(138).string(v);
        }
        if (message.sei !== void 0) {
          exports2.CommonMessageData_LiveMessageSEI.encode(message.sei, writer.uint32(146).fork()).join();
        }
        if (message.dependRootId !== void 0) {
          exports2.CommonMessageData_LiveMessageID.encode(message.dependRootId, writer.uint32(154).fork()).join();
        }
        if (message.dependId !== void 0) {
          exports2.CommonMessageData_LiveMessageID.encode(message.dependId, writer.uint32(162).fork()).join();
        }
        if (message.anchorPriorityScore !== "0") {
          writer.uint32(168).int64(message.anchorPriorityScore);
        }
        if (message.roomMessageHeatLevel !== "0") {
          writer.uint32(176).int64(message.roomMessageHeatLevel);
        }
        if (message.foldTypeForWeb !== "0") {
          writer.uint32(184).int64(message.foldTypeForWeb);
        }
        if (message.anchorFoldTypeForWeb !== "0") {
          writer.uint32(192).int64(message.anchorFoldTypeForWeb);
        }
        if (message.clientSendTime !== "0") {
          writer.uint32(200).int64(message.clientSendTime);
        }
        if (message.dispatchStrategy !== 0) {
          writer.uint32(208).int32(message.dispatchStrategy);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommonMessageData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.method = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.msgId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.roomId = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.createTime = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.monitor = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.isShowMsg = reader.bool();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.describe = reader.string();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.displayText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.foldType = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.anchorFoldType = reader.int64().toString();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.priorityScore = reader.int64().toString();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.logId = reader.string();
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.msgProcessFilterK = reader.string();
              continue;
            }
            case 14: {
              if (tag !== 114) {
                break;
              }
              message.msgProcessFilterV = reader.string();
              continue;
            }
            case 15: {
              if (tag !== 122) {
                break;
              }
              message.fromIdc = reader.string();
              continue;
            }
            case 16: {
              if (tag !== 130) {
                break;
              }
              message.toIdc = reader.string();
              continue;
            }
            case 17: {
              if (tag !== 138) {
                break;
              }
              message.filterMsgTagsList.push(reader.string());
              continue;
            }
            case 18: {
              if (tag !== 146) {
                break;
              }
              message.sei = exports2.CommonMessageData_LiveMessageSEI.decode(reader, reader.uint32());
              continue;
            }
            case 19: {
              if (tag !== 154) {
                break;
              }
              message.dependRootId = exports2.CommonMessageData_LiveMessageID.decode(reader, reader.uint32());
              continue;
            }
            case 20: {
              if (tag !== 162) {
                break;
              }
              message.dependId = exports2.CommonMessageData_LiveMessageID.decode(reader, reader.uint32());
              continue;
            }
            case 21: {
              if (tag !== 168) {
                break;
              }
              message.anchorPriorityScore = reader.int64().toString();
              continue;
            }
            case 22: {
              if (tag !== 176) {
                break;
              }
              message.roomMessageHeatLevel = reader.int64().toString();
              continue;
            }
            case 23: {
              if (tag !== 184) {
                break;
              }
              message.foldTypeForWeb = reader.int64().toString();
              continue;
            }
            case 24: {
              if (tag !== 192) {
                break;
              }
              message.anchorFoldTypeForWeb = reader.int64().toString();
              continue;
            }
            case 25: {
              if (tag !== 200) {
                break;
              }
              message.clientSendTime = reader.int64().toString();
              continue;
            }
            case 26: {
              if (tag !== 208) {
                break;
              }
              message.dispatchStrategy = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseCommonMessageData_LiveMessageSEI() {
      return { uniqueId: void 0, timestamp: "0" };
    }
    exports2.CommonMessageData_LiveMessageSEI = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.uniqueId !== void 0) {
          exports2.CommonMessageData_LiveMessageID.encode(message.uniqueId, writer.uint32(10).fork()).join();
        }
        if (message.timestamp !== "0") {
          writer.uint32(16).int64(message.timestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommonMessageData_LiveMessageSEI();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.uniqueId = exports2.CommonMessageData_LiveMessageID.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.timestamp = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseCommonMessageData_LiveMessageID() {
      return { primaryId: "", messageScene: "" };
    }
    exports2.CommonMessageData_LiveMessageID = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.primaryId !== "") {
          writer.uint32(10).string(message.primaryId);
        }
        if (message.messageScene !== "") {
          writer.uint32(18).string(message.messageScene);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCommonMessageData_LiveMessageID();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.primaryId = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.messageScene = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseText() {
      return { displayType: "", defaultPattern: "", defaultFormat: void 0, piecesList: [] };
    }
    exports2.Text = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.displayType !== "") {
          writer.uint32(10).string(message.displayType);
        }
        if (message.defaultPattern !== "") {
          writer.uint32(18).string(message.defaultPattern);
        }
        if (message.defaultFormat !== void 0) {
          exports2.Text_TextFormat.encode(message.defaultFormat, writer.uint32(26).fork()).join();
        }
        for (const v of message.piecesList) {
          exports2.Text_TextPiece.encode(v, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseText();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.displayType = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.defaultPattern = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.defaultFormat = exports2.Text_TextFormat.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.piecesList.push(exports2.Text_TextPiece.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseText_TextPiece() {
      return {
        type: 0,
        format: void 0,
        stringValue: "",
        userValue: void 0,
        giftValue: void 0,
        patternRefValue: void 0
      };
    }
    exports2.Text_TextPiece = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.format !== void 0) {
          exports2.Text_TextFormat.encode(message.format, writer.uint32(18).fork()).join();
        }
        if (message.stringValue !== "") {
          writer.uint32(90).string(message.stringValue);
        }
        if (message.userValue !== void 0) {
          exports2.Text_TextPieceUser.encode(message.userValue, writer.uint32(170).fork()).join();
        }
        if (message.giftValue !== void 0) {
          exports2.Text_TextPieceGift.encode(message.giftValue, writer.uint32(178).fork()).join();
        }
        if (message.patternRefValue !== void 0) {
          exports2.Text_TextPiecePatternRef.encode(message.patternRefValue, writer.uint32(194).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseText_TextPiece();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.format = exports2.Text_TextFormat.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.stringValue = reader.string();
              continue;
            }
            case 21: {
              if (tag !== 170) {
                break;
              }
              message.userValue = exports2.Text_TextPieceUser.decode(reader, reader.uint32());
              continue;
            }
            case 22: {
              if (tag !== 178) {
                break;
              }
              message.giftValue = exports2.Text_TextPieceGift.decode(reader, reader.uint32());
              continue;
            }
            case 24: {
              if (tag !== 194) {
                break;
              }
              message.patternRefValue = exports2.Text_TextPiecePatternRef.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseText_TextFormat() {
      return {
        color: "",
        bold: false,
        italic: false,
        weight: 0,
        italicAngle: 0,
        fontSize: 0,
        useHeighLightColor: false,
        useRemoteClor: false
      };
    }
    exports2.Text_TextFormat = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.color !== "") {
          writer.uint32(10).string(message.color);
        }
        if (message.bold !== false) {
          writer.uint32(16).bool(message.bold);
        }
        if (message.italic !== false) {
          writer.uint32(24).bool(message.italic);
        }
        if (message.weight !== 0) {
          writer.uint32(32).int32(message.weight);
        }
        if (message.italicAngle !== 0) {
          writer.uint32(40).int32(message.italicAngle);
        }
        if (message.fontSize !== 0) {
          writer.uint32(48).int32(message.fontSize);
        }
        if (message.useHeighLightColor !== false) {
          writer.uint32(56).bool(message.useHeighLightColor);
        }
        if (message.useRemoteClor !== false) {
          writer.uint32(64).bool(message.useRemoteClor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseText_TextFormat();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.color = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.bold = reader.bool();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.italic = reader.bool();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.weight = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.italicAngle = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.fontSize = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.useHeighLightColor = reader.bool();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.useRemoteClor = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseText_TextPieceGift() {
      return { giftId: 0, nameRef: void 0, showType: 0, colorId: "0" };
    }
    exports2.Text_TextPieceGift = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.giftId !== 0) {
          writer.uint32(8).int32(message.giftId);
        }
        if (message.nameRef !== void 0) {
          exports2.Text_PatternRef.encode(message.nameRef, writer.uint32(18).fork()).join();
        }
        if (message.showType !== 0) {
          writer.uint32(24).int32(message.showType);
        }
        if (message.colorId !== "0") {
          writer.uint32(32).int64(message.colorId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseText_TextPieceGift();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.giftId = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.nameRef = exports2.Text_PatternRef.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.showType = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.colorId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseText_TextPiecePatternRef() {
      return { key: "", defaultPattern: "" };
    }
    exports2.Text_TextPiecePatternRef = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.defaultPattern !== "") {
          writer.uint32(18).string(message.defaultPattern);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseText_TextPiecePatternRef();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.defaultPattern = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseText_TextPieceUser() {
      return { user: void 0, withColon: false };
    }
    exports2.Text_TextPieceUser = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(10).fork()).join();
        }
        if (message.withColon !== false) {
          writer.uint32(16).bool(message.withColon);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseText_TextPieceUser();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.withColon = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseText_PatternRef() {
      return { key: "", defaultPattern: "" };
    }
    exports2.Text_PatternRef = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.defaultPattern !== "") {
          writer.uint32(18).string(message.defaultPattern);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseText_PatternRef();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.defaultPattern = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseImage() {
      return {
        url: [],
        mUri: "",
        height: 0,
        width: 0,
        avgColor: "",
        imageType: 0,
        schema: "",
        content: void 0,
        isAnimated: false
      };
    }
    exports2.Image = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.url) {
          writer.uint32(10).string(v);
        }
        if (message.mUri !== "") {
          writer.uint32(18).string(message.mUri);
        }
        if (message.height !== 0) {
          writer.uint32(24).int32(message.height);
        }
        if (message.width !== 0) {
          writer.uint32(32).int32(message.width);
        }
        if (message.avgColor !== "") {
          writer.uint32(42).string(message.avgColor);
        }
        if (message.imageType !== 0) {
          writer.uint32(48).int32(message.imageType);
        }
        if (message.schema !== "") {
          writer.uint32(58).string(message.schema);
        }
        if (message.content !== void 0) {
          exports2.Image_Content.encode(message.content, writer.uint32(66).fork()).join();
        }
        if (message.isAnimated !== false) {
          writer.uint32(72).bool(message.isAnimated);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseImage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.url.push(reader.string());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.mUri = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.height = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.width = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.avgColor = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.imageType = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.schema = reader.string();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.content = exports2.Image_Content.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.isAnimated = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseImage_Content() {
      return { name: "", fontColor: "", level: "0" };
    }
    exports2.Image_Content = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.fontColor !== "") {
          writer.uint32(18).string(message.fontColor);
        }
        if (message.level !== "0") {
          writer.uint32(24).int64(message.level);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseImage_Content();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.name = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.fontColor = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.level = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBadgeStruct() {
      return {
        badgeDisplayType: 0,
        badgePriorityType: 0,
        badgeScene: 0,
        position: 0,
        displayStatus: 0,
        greyedByClient: "0",
        exhibitionType: 0,
        schemaUrl: "",
        display: false,
        logExtra: void 0,
        image: void 0,
        text: void 0,
        str: void 0,
        combine: void 0,
        isCustomized: false
      };
    }
    exports2.BadgeStruct = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.badgeDisplayType !== 0) {
          writer.uint32(8).int32(message.badgeDisplayType);
        }
        if (message.badgePriorityType !== 0) {
          writer.uint32(16).int32(message.badgePriorityType);
        }
        if (message.badgeScene !== 0) {
          writer.uint32(24).int32(message.badgeScene);
        }
        if (message.position !== 0) {
          writer.uint32(32).int32(message.position);
        }
        if (message.displayStatus !== 0) {
          writer.uint32(40).int32(message.displayStatus);
        }
        if (message.greyedByClient !== "0") {
          writer.uint32(48).int64(message.greyedByClient);
        }
        if (message.exhibitionType !== 0) {
          writer.uint32(56).int32(message.exhibitionType);
        }
        if (message.schemaUrl !== "") {
          writer.uint32(82).string(message.schemaUrl);
        }
        if (message.display !== false) {
          writer.uint32(88).bool(message.display);
        }
        if (message.logExtra !== void 0) {
          exports2.PrivilegeLogExtra.encode(message.logExtra, writer.uint32(98).fork()).join();
        }
        if (message.image !== void 0) {
          exports2.BadgeStruct_ImageBadge.encode(message.image, writer.uint32(162).fork()).join();
        }
        if (message.text !== void 0) {
          exports2.BadgeStruct_TextBadge.encode(message.text, writer.uint32(170).fork()).join();
        }
        if (message.str !== void 0) {
          exports2.BadgeStruct_StringBadge.encode(message.str, writer.uint32(178).fork()).join();
        }
        if (message.combine !== void 0) {
          exports2.BadgeStruct_CombineBadge.encode(message.combine, writer.uint32(186).fork()).join();
        }
        if (message.isCustomized !== false) {
          writer.uint32(192).bool(message.isCustomized);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBadgeStruct();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.badgeDisplayType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.badgePriorityType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.badgeScene = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.position = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.displayStatus = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.greyedByClient = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.exhibitionType = reader.int32();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.schemaUrl = reader.string();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.display = reader.bool();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.logExtra = exports2.PrivilegeLogExtra.decode(reader, reader.uint32());
              continue;
            }
            case 20: {
              if (tag !== 162) {
                break;
              }
              message.image = exports2.BadgeStruct_ImageBadge.decode(reader, reader.uint32());
              continue;
            }
            case 21: {
              if (tag !== 170) {
                break;
              }
              message.text = exports2.BadgeStruct_TextBadge.decode(reader, reader.uint32());
              continue;
            }
            case 22: {
              if (tag !== 178) {
                break;
              }
              message.str = exports2.BadgeStruct_StringBadge.decode(reader, reader.uint32());
              continue;
            }
            case 23: {
              if (tag !== 186) {
                break;
              }
              message.combine = exports2.BadgeStruct_CombineBadge.decode(reader, reader.uint32());
              continue;
            }
            case 24: {
              if (tag !== 192) {
                break;
              }
              message.isCustomized = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBadgeStruct_CombineBadge() {
      return {
        badgeDisplayType: 0,
        icon: void 0,
        text: void 0,
        str: "",
        padding: void 0,
        fontStyle: void 0,
        profileCardPanel: void 0,
        background: void 0,
        backgroundDarkMode: void 0,
        iconAutoMirrored: false,
        bgAutoMirrored: false,
        publicScreenShowStyle: 0,
        personalCardShowStyle: 0,
        rankListOnlineAudienceShowStyle: 0,
        multiGuestShowStyle: 0,
        arrowConfig: void 0,
        paddingNewFont: void 0
      };
    }
    exports2.BadgeStruct_CombineBadge = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.badgeDisplayType !== 0) {
          writer.uint32(8).int32(message.badgeDisplayType);
        }
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(18).fork()).join();
        }
        if (message.text !== void 0) {
          exports2.BadgeStruct_TextBadge.encode(message.text, writer.uint32(26).fork()).join();
        }
        if (message.str !== "") {
          writer.uint32(34).string(message.str);
        }
        if (message.padding !== void 0) {
          exports2.BadgeStruct_PaddingInfo.encode(message.padding, writer.uint32(42).fork()).join();
        }
        if (message.fontStyle !== void 0) {
          exports2.FontStyle.encode(message.fontStyle, writer.uint32(50).fork()).join();
        }
        if (message.profileCardPanel !== void 0) {
          exports2.BadgeStruct_ProfileCardPanel.encode(message.profileCardPanel, writer.uint32(58).fork()).join();
        }
        if (message.background !== void 0) {
          exports2.BadgeStruct_CombineBadgeBackground.encode(message.background, writer.uint32(90).fork()).join();
        }
        if (message.backgroundDarkMode !== void 0) {
          exports2.BadgeStruct_CombineBadgeBackground.encode(message.backgroundDarkMode, writer.uint32(98).fork()).join();
        }
        if (message.iconAutoMirrored !== false) {
          writer.uint32(104).bool(message.iconAutoMirrored);
        }
        if (message.bgAutoMirrored !== false) {
          writer.uint32(112).bool(message.bgAutoMirrored);
        }
        if (message.publicScreenShowStyle !== 0) {
          writer.uint32(120).int32(message.publicScreenShowStyle);
        }
        if (message.personalCardShowStyle !== 0) {
          writer.uint32(128).int32(message.personalCardShowStyle);
        }
        if (message.rankListOnlineAudienceShowStyle !== 0) {
          writer.uint32(136).int32(message.rankListOnlineAudienceShowStyle);
        }
        if (message.multiGuestShowStyle !== 0) {
          writer.uint32(144).int32(message.multiGuestShowStyle);
        }
        if (message.arrowConfig !== void 0) {
          exports2.BadgeStruct_ArrowConfig.encode(message.arrowConfig, writer.uint32(154).fork()).join();
        }
        if (message.paddingNewFont !== void 0) {
          exports2.BadgeStruct_PaddingInfo.encode(message.paddingNewFont, writer.uint32(162).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBadgeStruct_CombineBadge();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.badgeDisplayType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.text = exports2.BadgeStruct_TextBadge.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.str = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.padding = exports2.BadgeStruct_PaddingInfo.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.fontStyle = exports2.FontStyle.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.profileCardPanel = exports2.BadgeStruct_ProfileCardPanel.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.background = exports2.BadgeStruct_CombineBadgeBackground.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.backgroundDarkMode = exports2.BadgeStruct_CombineBadgeBackground.decode(reader, reader.uint32());
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.iconAutoMirrored = reader.bool();
              continue;
            }
            case 14: {
              if (tag !== 112) {
                break;
              }
              message.bgAutoMirrored = reader.bool();
              continue;
            }
            case 15: {
              if (tag !== 120) {
                break;
              }
              message.publicScreenShowStyle = reader.int32();
              continue;
            }
            case 16: {
              if (tag !== 128) {
                break;
              }
              message.personalCardShowStyle = reader.int32();
              continue;
            }
            case 17: {
              if (tag !== 136) {
                break;
              }
              message.rankListOnlineAudienceShowStyle = reader.int32();
              continue;
            }
            case 18: {
              if (tag !== 144) {
                break;
              }
              message.multiGuestShowStyle = reader.int32();
              continue;
            }
            case 19: {
              if (tag !== 154) {
                break;
              }
              message.arrowConfig = exports2.BadgeStruct_ArrowConfig.decode(reader, reader.uint32());
              continue;
            }
            case 20: {
              if (tag !== 162) {
                break;
              }
              message.paddingNewFont = exports2.BadgeStruct_PaddingInfo.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBadgeStruct_ArrowConfig() {
      return { icon: void 0 };
    }
    exports2.BadgeStruct_ArrowConfig = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBadgeStruct_ArrowConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBadgeStruct_ProfileContent() {
      return { useContent: false, iconList: [], numberConfig: void 0 };
    }
    exports2.BadgeStruct_ProfileContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.useContent !== false) {
          writer.uint32(8).bool(message.useContent);
        }
        for (const v of message.iconList) {
          exports2.BadgeStruct_IconConfig.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.numberConfig !== void 0) {
          exports2.BadgeStruct_NumberConfig.encode(message.numberConfig, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBadgeStruct_ProfileContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.useContent = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.iconList.push(exports2.BadgeStruct_IconConfig.decode(reader, reader.uint32()));
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.numberConfig = exports2.BadgeStruct_NumberConfig.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBadgeStruct_ProjectionConfig() {
      return { useProjection: false, icon: void 0 };
    }
    exports2.BadgeStruct_ProjectionConfig = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.useProjection !== false) {
          writer.uint32(8).bool(message.useProjection);
        }
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBadgeStruct_ProjectionConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.useProjection = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBadgeStruct_NumberConfig() {
      return { number: "0", fontStyle: void 0, background: void 0 };
    }
    exports2.BadgeStruct_NumberConfig = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.number !== "0") {
          writer.uint32(8).int64(message.number);
        }
        if (message.fontStyle !== void 0) {
          exports2.FontStyle.encode(message.fontStyle, writer.uint32(18).fork()).join();
        }
        if (message.background !== void 0) {
          exports2.BadgeStruct_CombineBadgeBackground.encode(message.background, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBadgeStruct_NumberConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.number = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.fontStyle = exports2.FontStyle.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.background = exports2.BadgeStruct_CombineBadgeBackground.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBadgeStruct_ProfileCardPanel() {
      return { useNewProfileCardStyle: false, projectionConfig: void 0, profileContent: void 0 };
    }
    exports2.BadgeStruct_ProfileCardPanel = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.useNewProfileCardStyle !== false) {
          writer.uint32(8).bool(message.useNewProfileCardStyle);
        }
        if (message.projectionConfig !== void 0) {
          exports2.BadgeStruct_ProjectionConfig.encode(message.projectionConfig, writer.uint32(26).fork()).join();
        }
        if (message.profileContent !== void 0) {
          exports2.BadgeStruct_ProfileContent.encode(message.profileContent, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBadgeStruct_ProfileCardPanel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.useNewProfileCardStyle = reader.bool();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.projectionConfig = exports2.BadgeStruct_ProjectionConfig.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.profileContent = exports2.BadgeStruct_ProfileContent.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBadgeStruct_CombineBadgeBackground() {
      return { image: void 0, backgroundColorCode: "", borderColorCode: "" };
    }
    exports2.BadgeStruct_CombineBadgeBackground = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.image !== void 0) {
          exports2.Image.encode(message.image, writer.uint32(10).fork()).join();
        }
        if (message.backgroundColorCode !== "") {
          writer.uint32(18).string(message.backgroundColorCode);
        }
        if (message.borderColorCode !== "") {
          writer.uint32(26).string(message.borderColorCode);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBadgeStruct_CombineBadgeBackground();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.image = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.backgroundColorCode = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.borderColorCode = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBadgeStruct_ImageBadge() {
      return { badgeDisplayType: 0, image: void 0 };
    }
    exports2.BadgeStruct_ImageBadge = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.badgeDisplayType !== 0) {
          writer.uint32(8).int32(message.badgeDisplayType);
        }
        if (message.image !== void 0) {
          exports2.Image.encode(message.image, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBadgeStruct_ImageBadge();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.badgeDisplayType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.image = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBadgeStruct_TextBadge() {
      return { badgeDisplayType: 0, key: "", defaultPattern: "", pieces: [] };
    }
    exports2.BadgeStruct_TextBadge = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.badgeDisplayType !== 0) {
          writer.uint32(8).int32(message.badgeDisplayType);
        }
        if (message.key !== "") {
          writer.uint32(18).string(message.key);
        }
        if (message.defaultPattern !== "") {
          writer.uint32(26).string(message.defaultPattern);
        }
        for (const v of message.pieces) {
          writer.uint32(34).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBadgeStruct_TextBadge();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.badgeDisplayType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.defaultPattern = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.pieces.push(reader.string());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBadgeStruct_IconConfig() {
      return { icon: void 0, background: void 0 };
    }
    exports2.BadgeStruct_IconConfig = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(10).fork()).join();
        }
        if (message.background !== void 0) {
          exports2.BadgeStruct_CombineBadgeBackground.encode(message.background, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBadgeStruct_IconConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.background = exports2.BadgeStruct_CombineBadgeBackground.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBadgeStruct_StringBadge() {
      return { badgeDisplayType: 0, str: "" };
    }
    exports2.BadgeStruct_StringBadge = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.badgeDisplayType !== 0) {
          writer.uint32(8).int32(message.badgeDisplayType);
        }
        if (message.str !== "") {
          writer.uint32(18).string(message.str);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBadgeStruct_StringBadge();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.badgeDisplayType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.str = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBadgeStruct_PaddingInfo() {
      return {
        useSpecific: false,
        middlePadding: 0,
        badgeWidth: 0,
        leftPadding: 0,
        rightPadding: 0,
        iconTopPadding: 0,
        iconBottomPadding: 0,
        horizontalPaddingRule: 0,
        verticalPaddingRule: 0
      };
    }
    exports2.BadgeStruct_PaddingInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.useSpecific !== false) {
          writer.uint32(8).bool(message.useSpecific);
        }
        if (message.middlePadding !== 0) {
          writer.uint32(16).int32(message.middlePadding);
        }
        if (message.badgeWidth !== 0) {
          writer.uint32(24).int32(message.badgeWidth);
        }
        if (message.leftPadding !== 0) {
          writer.uint32(32).int32(message.leftPadding);
        }
        if (message.rightPadding !== 0) {
          writer.uint32(40).int32(message.rightPadding);
        }
        if (message.iconTopPadding !== 0) {
          writer.uint32(48).int32(message.iconTopPadding);
        }
        if (message.iconBottomPadding !== 0) {
          writer.uint32(56).int32(message.iconBottomPadding);
        }
        if (message.horizontalPaddingRule !== 0) {
          writer.uint32(64).int32(message.horizontalPaddingRule);
        }
        if (message.verticalPaddingRule !== 0) {
          writer.uint32(72).int32(message.verticalPaddingRule);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBadgeStruct_PaddingInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.useSpecific = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.middlePadding = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.badgeWidth = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.leftPadding = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.rightPadding = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.iconTopPadding = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.iconBottomPadding = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.horizontalPaddingRule = reader.int32();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.verticalPaddingRule = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGift() {
      return {
        giftImage: void 0,
        describe: "",
        duration: 0,
        id: "0",
        forLinkMic: false,
        combo: false,
        giftType: 0,
        diamondCount: 0,
        isDisplayedOnPanel: false,
        primaryEffectId: "0",
        giftLabelIcon: void 0,
        giftName: "",
        icon: void 0,
        goldEffect: "",
        previewImage: void 0,
        giftPanelBanner: void 0,
        isBroadcastGift: false,
        isEffectBefview: false,
        isRandomGift: false,
        isBoxGift: false,
        canPutInGiftBox: false,
        giftBoxInfo: void 0
      };
    }
    exports2.Gift = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.giftImage !== void 0) {
          exports2.Image.encode(message.giftImage, writer.uint32(10).fork()).join();
        }
        if (message.describe !== "") {
          writer.uint32(18).string(message.describe);
        }
        if (message.duration !== 0) {
          writer.uint32(32).int32(message.duration);
        }
        if (message.id !== "0") {
          writer.uint32(40).int64(message.id);
        }
        if (message.forLinkMic !== false) {
          writer.uint32(56).bool(message.forLinkMic);
        }
        if (message.combo !== false) {
          writer.uint32(80).bool(message.combo);
        }
        if (message.giftType !== 0) {
          writer.uint32(88).int32(message.giftType);
        }
        if (message.diamondCount !== 0) {
          writer.uint32(96).int32(message.diamondCount);
        }
        if (message.isDisplayedOnPanel !== false) {
          writer.uint32(104).bool(message.isDisplayedOnPanel);
        }
        if (message.primaryEffectId !== "0") {
          writer.uint32(112).int64(message.primaryEffectId);
        }
        if (message.giftLabelIcon !== void 0) {
          exports2.Image.encode(message.giftLabelIcon, writer.uint32(122).fork()).join();
        }
        if (message.giftName !== "") {
          writer.uint32(130).string(message.giftName);
        }
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(170).fork()).join();
        }
        if (message.goldEffect !== "") {
          writer.uint32(194).string(message.goldEffect);
        }
        if (message.previewImage !== void 0) {
          exports2.Image.encode(message.previewImage, writer.uint32(378).fork()).join();
        }
        if (message.giftPanelBanner !== void 0) {
          exports2.Gift_GiftPanelBanner.encode(message.giftPanelBanner, writer.uint32(386).fork()).join();
        }
        if (message.isBroadcastGift !== false) {
          writer.uint32(392).bool(message.isBroadcastGift);
        }
        if (message.isEffectBefview !== false) {
          writer.uint32(400).bool(message.isEffectBefview);
        }
        if (message.isRandomGift !== false) {
          writer.uint32(408).bool(message.isRandomGift);
        }
        if (message.isBoxGift !== false) {
          writer.uint32(416).bool(message.isBoxGift);
        }
        if (message.canPutInGiftBox !== false) {
          writer.uint32(424).bool(message.canPutInGiftBox);
        }
        if (message.giftBoxInfo !== void 0) {
          exports2.Gift_GiftBoxInfo.encode(message.giftBoxInfo, writer.uint32(434).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGift();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.giftImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.describe = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.duration = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.forLinkMic = reader.bool();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.combo = reader.bool();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.giftType = reader.int32();
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.diamondCount = reader.int32();
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.isDisplayedOnPanel = reader.bool();
              continue;
            }
            case 14: {
              if (tag !== 112) {
                break;
              }
              message.primaryEffectId = reader.int64().toString();
              continue;
            }
            case 15: {
              if (tag !== 122) {
                break;
              }
              message.giftLabelIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 16: {
              if (tag !== 130) {
                break;
              }
              message.giftName = reader.string();
              continue;
            }
            case 21: {
              if (tag !== 170) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 24: {
              if (tag !== 194) {
                break;
              }
              message.goldEffect = reader.string();
              continue;
            }
            case 47: {
              if (tag !== 378) {
                break;
              }
              message.previewImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 48: {
              if (tag !== 386) {
                break;
              }
              message.giftPanelBanner = exports2.Gift_GiftPanelBanner.decode(reader, reader.uint32());
              continue;
            }
            case 49: {
              if (tag !== 392) {
                break;
              }
              message.isBroadcastGift = reader.bool();
              continue;
            }
            case 50: {
              if (tag !== 400) {
                break;
              }
              message.isEffectBefview = reader.bool();
              continue;
            }
            case 51: {
              if (tag !== 408) {
                break;
              }
              message.isRandomGift = reader.bool();
              continue;
            }
            case 52: {
              if (tag !== 416) {
                break;
              }
              message.isBoxGift = reader.bool();
              continue;
            }
            case 53: {
              if (tag !== 424) {
                break;
              }
              message.canPutInGiftBox = reader.bool();
              continue;
            }
            case 54: {
              if (tag !== 434) {
                break;
              }
              message.giftBoxInfo = exports2.Gift_GiftBoxInfo.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGift_GiftPanelBanner() {
      return {
        displayText: void 0,
        leftIcon: void 0,
        schemaUrl: "",
        bgColors: [],
        bannerLynxUrl: "",
        bannerPriority: 0,
        bannerLynxExtra: "",
        bgImage: void 0
      };
    }
    exports2.Gift_GiftPanelBanner = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.displayText !== void 0) {
          exports2.Text.encode(message.displayText, writer.uint32(10).fork()).join();
        }
        if (message.leftIcon !== void 0) {
          exports2.Image.encode(message.leftIcon, writer.uint32(18).fork()).join();
        }
        if (message.schemaUrl !== "") {
          writer.uint32(26).string(message.schemaUrl);
        }
        for (const v of message.bgColors) {
          writer.uint32(42).string(v);
        }
        if (message.bannerLynxUrl !== "") {
          writer.uint32(50).string(message.bannerLynxUrl);
        }
        if (message.bannerPriority !== 0) {
          writer.uint32(56).int32(message.bannerPriority);
        }
        if (message.bannerLynxExtra !== "") {
          writer.uint32(66).string(message.bannerLynxExtra);
        }
        if (message.bgImage !== void 0) {
          exports2.Image.encode(message.bgImage, writer.uint32(74).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGift_GiftPanelBanner();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.displayText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.leftIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.schemaUrl = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.bgColors.push(reader.string());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.bannerLynxUrl = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.bannerPriority = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.bannerLynxExtra = reader.string();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.bgImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGift_BatchGiftInfo() {
      return { canBatchSend: false, availableCounts: [] };
    }
    exports2.Gift_BatchGiftInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.canBatchSend !== false) {
          writer.uint32(8).bool(message.canBatchSend);
        }
        writer.uint32(18).fork();
        for (const v of message.availableCounts) {
          writer.int64(v);
        }
        writer.join();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGift_BatchGiftInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.canBatchSend = reader.bool();
              continue;
            }
            case 2: {
              if (tag === 16) {
                message.availableCounts.push(reader.int64().toString());
                continue;
              }
              if (tag === 18) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.availableCounts.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGift_CrossScreenEffectInfo() {
      return { singleActionEffectIds: {}, actionEffectIds: {}, reactionEffectIds: {} };
    }
    exports2.Gift_CrossScreenEffectInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        Object.entries(message.singleActionEffectIds).forEach(([key, value]) => {
          exports2.Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry.encode({ key, value }, writer.uint32(10).fork()).join();
        });
        Object.entries(message.actionEffectIds).forEach(([key, value]) => {
          exports2.Gift_CrossScreenEffectInfo_ActionEffectIdsEntry.encode({ key, value }, writer.uint32(18).fork()).join();
        });
        Object.entries(message.reactionEffectIds).forEach(([key, value]) => {
          exports2.Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry.encode({ key, value }, writer.uint32(26).fork()).join();
        });
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGift_CrossScreenEffectInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              const entry1 = exports2.Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry.decode(reader, reader.uint32());
              if (entry1.value !== void 0) {
                message.singleActionEffectIds[entry1.key] = entry1.value;
              }
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              const entry2 = exports2.Gift_CrossScreenEffectInfo_ActionEffectIdsEntry.decode(reader, reader.uint32());
              if (entry2.value !== void 0) {
                message.actionEffectIds[entry2.key] = entry2.value;
              }
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              const entry3 = exports2.Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry.decode(reader, reader.uint32());
              if (entry3.value !== void 0) {
                message.reactionEffectIds[entry3.key] = entry3.value;
              }
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGift_CrossScreenEffectInfo_SingleActionEffectIdsEntry() {
      return { key: "0", value: 0 };
    }
    exports2.Gift_CrossScreenEffectInfo_SingleActionEffectIdsEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "0") {
          writer.uint32(8).int64(message.key);
        }
        if (message.value !== 0) {
          writer.uint32(16).int32(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGift_CrossScreenEffectInfo_SingleActionEffectIdsEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.value = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGift_CrossScreenEffectInfo_ActionEffectIdsEntry() {
      return { key: "0", value: 0 };
    }
    exports2.Gift_CrossScreenEffectInfo_ActionEffectIdsEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "0") {
          writer.uint32(8).int64(message.key);
        }
        if (message.value !== 0) {
          writer.uint32(16).int32(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGift_CrossScreenEffectInfo_ActionEffectIdsEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.value = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGift_CrossScreenEffectInfo_ReactionEffectIdsEntry() {
      return { key: "0", value: 0 };
    }
    exports2.Gift_CrossScreenEffectInfo_ReactionEffectIdsEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "0") {
          writer.uint32(8).int64(message.key);
        }
        if (message.value !== 0) {
          writer.uint32(16).int32(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGift_CrossScreenEffectInfo_ReactionEffectIdsEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.value = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGift_GiftSponsorInfo() {
      return { sponsorId: "0", sponsorCount: "0", currentCount: "0", leftCountToSponsor: "0", canSponsor: false };
    }
    exports2.Gift_GiftSponsorInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.sponsorId !== "0") {
          writer.uint32(8).int64(message.sponsorId);
        }
        if (message.sponsorCount !== "0") {
          writer.uint32(16).int64(message.sponsorCount);
        }
        if (message.currentCount !== "0") {
          writer.uint32(24).int64(message.currentCount);
        }
        if (message.leftCountToSponsor !== "0") {
          writer.uint32(32).int64(message.leftCountToSponsor);
        }
        if (message.canSponsor !== false) {
          writer.uint32(40).bool(message.canSponsor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGift_GiftSponsorInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.sponsorId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.sponsorCount = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.currentCount = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.leftCountToSponsor = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.canSponsor = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGift_UGGiftStructInfo() {
      return { isUgGift: false, ugPointsCost: "0" };
    }
    exports2.Gift_UGGiftStructInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.isUgGift !== false) {
          writer.uint32(8).bool(message.isUgGift);
        }
        if (message.ugPointsCost !== "0") {
          writer.uint32(16).int64(message.ugPointsCost);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGift_UGGiftStructInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.isUgGift = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.ugPointsCost = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGift_GiftSkin() {
      return { giftSkinId: "0", giftSkinName: "", staticImage: void 0, animatedImage: void 0 };
    }
    exports2.Gift_GiftSkin = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.giftSkinId !== "0") {
          writer.uint32(8).int64(message.giftSkinId);
        }
        if (message.giftSkinName !== "") {
          writer.uint32(18).string(message.giftSkinName);
        }
        if (message.staticImage !== void 0) {
          exports2.Image.encode(message.staticImage, writer.uint32(26).fork()).join();
        }
        if (message.animatedImage !== void 0) {
          exports2.Image.encode(message.animatedImage, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGift_GiftSkin();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.giftSkinId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.giftSkinName = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.staticImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.animatedImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGift_GiftText() {
      return { giftTextId: "0", giftTextName: "" };
    }
    exports2.Gift_GiftText = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.giftTextId !== "0") {
          writer.uint32(8).int64(message.giftTextId);
        }
        if (message.giftTextName !== "") {
          writer.uint32(18).string(message.giftTextName);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGift_GiftText();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.giftTextId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.giftTextName = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGift_GiftSkinToGiftTextsInfo() {
      return { giftSkinId: "0", giftTextIds: [] };
    }
    exports2.Gift_GiftSkinToGiftTextsInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.giftSkinId !== "0") {
          writer.uint32(8).int64(message.giftSkinId);
        }
        writer.uint32(18).fork();
        for (const v of message.giftTextIds) {
          writer.int64(v);
        }
        writer.join();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGift_GiftSkinToGiftTextsInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.giftSkinId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag === 16) {
                message.giftTextIds.push(reader.int64().toString());
                continue;
              }
              if (tag === 18) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.giftTextIds.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGift_GiftBoxInfo() {
      return { capacity: "0", isPrimaryBox: false, schemeUrl: "" };
    }
    exports2.Gift_GiftBoxInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.capacity !== "0") {
          writer.uint32(8).int64(message.capacity);
        }
        if (message.isPrimaryBox !== false) {
          writer.uint32(16).bool(message.isPrimaryBox);
        }
        if (message.schemeUrl !== "") {
          writer.uint32(26).string(message.schemeUrl);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGift_GiftBoxInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.capacity = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.isPrimaryBox = reader.bool();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.schemeUrl = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser() {
      return {
        userId: "0",
        nickname: "",
        bioDescription: "",
        profilePicture: void 0,
        profilePictureMedium: void 0,
        profilePictureLarge: void 0,
        verified: false,
        status: 0,
        createTime: "0",
        modifyTime: "0",
        secret: 0,
        shareQrcodeUri: "",
        badgeImageList: [],
        followInfo: void 0,
        userHonor: void 0,
        fansClub: void 0,
        border: void 0,
        specialId: "",
        avatarBorder: void 0,
        medal: void 0,
        userBadges: [],
        newUserBadges: [],
        topVipNo: 0,
        userAttr: void 0,
        ownRoom: void 0,
        payScore: "0",
        fanTicketCount: "0",
        anchorInfo: void 0,
        linkMicStats: 0,
        uniqueId: "",
        enableShowCommerceSale: false,
        withFusionShopEntry: false,
        payScores: "0",
        anchorLevel: void 0,
        verifiedContent: "",
        authorInfo: void 0,
        topFans: [],
        secUid: "",
        userRole: 0,
        rewardInfo: void 0,
        personalCard: void 0,
        authenticationInfo: void 0,
        mediaBadgeImageList: [],
        commerceWebcastConfigIds: [],
        borders: [],
        comboBadgeInfo: void 0,
        subscribeInfo: void 0,
        badges: [],
        mintTypeLabel: [],
        fansClubInfo: void 0,
        allowFindByContacts: false,
        allowOthersDownloadVideo: false,
        allowOthersDownloadWhenSharingVideo: false,
        allowShareShowProfile: false,
        allowShowInGossip: false,
        allowShowMyAction: false,
        allowStrangeComment: false,
        allowUnfollowerComment: false,
        allowUseLinkmic: false,
        avatarJpg: void 0,
        backgroundImgUrl: "",
        blockStatus: 0,
        commentRestrict: 0,
        constellation: "",
        disableIchat: 0,
        enableIchatImg: "0",
        exp: 0,
        foldStrangerChat: false,
        followStatus: "0",
        ichatRestrictType: 0,
        idStr: "",
        isFollower: false,
        isFollowing: false,
        needProfileGuide: false,
        pushCommentStatus: false,
        pushDigg: false,
        pushFollow: false,
        pushFriendAction: false,
        pushIchat: false,
        pushStatus: false,
        pushVideoPost: false,
        pushVideoRecommend: false,
        verifiedReason: "",
        enableCarManagementPermission: false,
        upcomingEventList: [],
        scmLabel: "",
        ecommerceEntrance: void 0,
        isBlock: false,
        isSubscribe: false,
        isAnchorMarked: false
      };
    }
    exports2.User = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.nickname !== "") {
          writer.uint32(26).string(message.nickname);
        }
        if (message.bioDescription !== "") {
          writer.uint32(42).string(message.bioDescription);
        }
        if (message.profilePicture !== void 0) {
          exports2.Image.encode(message.profilePicture, writer.uint32(74).fork()).join();
        }
        if (message.profilePictureMedium !== void 0) {
          exports2.Image.encode(message.profilePictureMedium, writer.uint32(82).fork()).join();
        }
        if (message.profilePictureLarge !== void 0) {
          exports2.Image.encode(message.profilePictureLarge, writer.uint32(90).fork()).join();
        }
        if (message.verified !== false) {
          writer.uint32(96).bool(message.verified);
        }
        if (message.status !== 0) {
          writer.uint32(120).int32(message.status);
        }
        if (message.createTime !== "0") {
          writer.uint32(128).int64(message.createTime);
        }
        if (message.modifyTime !== "0") {
          writer.uint32(136).int64(message.modifyTime);
        }
        if (message.secret !== 0) {
          writer.uint32(144).int32(message.secret);
        }
        if (message.shareQrcodeUri !== "") {
          writer.uint32(154).string(message.shareQrcodeUri);
        }
        for (const v of message.badgeImageList) {
          exports2.Image.encode(v, writer.uint32(170).fork()).join();
        }
        if (message.followInfo !== void 0) {
          exports2.User_FollowInfo.encode(message.followInfo, writer.uint32(178).fork()).join();
        }
        if (message.userHonor !== void 0) {
          exports2.UserHonor.encode(message.userHonor, writer.uint32(186).fork()).join();
        }
        if (message.fansClub !== void 0) {
          exports2.FansClubMember.encode(message.fansClub, writer.uint32(194).fork()).join();
        }
        if (message.border !== void 0) {
          exports2.BorderInfo.encode(message.border, writer.uint32(202).fork()).join();
        }
        if (message.specialId !== "") {
          writer.uint32(210).string(message.specialId);
        }
        if (message.avatarBorder !== void 0) {
          exports2.Image.encode(message.avatarBorder, writer.uint32(218).fork()).join();
        }
        if (message.medal !== void 0) {
          exports2.Image.encode(message.medal, writer.uint32(226).fork()).join();
        }
        for (const v of message.userBadges) {
          exports2.Image.encode(v, writer.uint32(234).fork()).join();
        }
        for (const v of message.newUserBadges) {
          exports2.Image.encode(v, writer.uint32(242).fork()).join();
        }
        if (message.topVipNo !== 0) {
          writer.uint32(248).int32(message.topVipNo);
        }
        if (message.userAttr !== void 0) {
          exports2.User_UserAttr.encode(message.userAttr, writer.uint32(258).fork()).join();
        }
        if (message.ownRoom !== void 0) {
          exports2.User_OwnRoom.encode(message.ownRoom, writer.uint32(266).fork()).join();
        }
        if (message.payScore !== "0") {
          writer.uint32(272).int64(message.payScore);
        }
        if (message.fanTicketCount !== "0") {
          writer.uint32(280).int64(message.fanTicketCount);
        }
        if (message.anchorInfo !== void 0) {
          exports2.User_AnchorLevel.encode(message.anchorInfo, writer.uint32(290).fork()).join();
        }
        if (message.linkMicStats !== 0) {
          writer.uint32(296).int32(message.linkMicStats);
        }
        if (message.uniqueId !== "") {
          writer.uint32(306).string(message.uniqueId);
        }
        if (message.enableShowCommerceSale !== false) {
          writer.uint32(312).bool(message.enableShowCommerceSale);
        }
        if (message.withFusionShopEntry !== false) {
          writer.uint32(320).bool(message.withFusionShopEntry);
        }
        if (message.payScores !== "0") {
          writer.uint32(328).int64(message.payScores);
        }
        if (message.anchorLevel !== void 0) {
          exports2.User_AnchorLevel.encode(message.anchorLevel, writer.uint32(338).fork()).join();
        }
        if (message.verifiedContent !== "") {
          writer.uint32(346).string(message.verifiedContent);
        }
        if (message.authorInfo !== void 0) {
          exports2.Author.encode(message.authorInfo, writer.uint32(354).fork()).join();
        }
        for (const v of message.topFans) {
          exports2.User.encode(v, writer.uint32(362).fork()).join();
        }
        if (message.secUid !== "") {
          writer.uint32(370).string(message.secUid);
        }
        if (message.userRole !== 0) {
          writer.uint32(376).int32(message.userRole);
        }
        if (message.rewardInfo !== void 0) {
          exports2.User_ActivityInfo.encode(message.rewardInfo, writer.uint32(394).fork()).join();
        }
        if (message.personalCard !== void 0) {
          exports2.Image.encode(message.personalCard, writer.uint32(418).fork()).join();
        }
        if (message.authenticationInfo !== void 0) {
          exports2.User_AuthenticationInfo.encode(message.authenticationInfo, writer.uint32(426).fork()).join();
        }
        for (const v of message.mediaBadgeImageList) {
          exports2.Image.encode(v, writer.uint32(458).fork()).join();
        }
        writer.uint32(482).fork();
        for (const v of message.commerceWebcastConfigIds) {
          writer.int64(v);
        }
        writer.join();
        for (const v of message.borders) {
          exports2.BorderInfo.encode(v, writer.uint32(490).fork()).join();
        }
        if (message.comboBadgeInfo !== void 0) {
          exports2.User_ComboBadgeInfo.encode(message.comboBadgeInfo, writer.uint32(498).fork()).join();
        }
        if (message.subscribeInfo !== void 0) {
          exports2.User_SubscribeInfo.encode(message.subscribeInfo, writer.uint32(506).fork()).join();
        }
        for (const v of message.badges) {
          exports2.BadgeStruct.encode(v, writer.uint32(514).fork()).join();
        }
        writer.uint32(522).fork();
        for (const v of message.mintTypeLabel) {
          writer.int64(v);
        }
        writer.join();
        if (message.fansClubInfo !== void 0) {
          exports2.User_FansClubInfo.encode(message.fansClubInfo, writer.uint32(530).fork()).join();
        }
        if (message.allowFindByContacts !== false) {
          writer.uint32(8016).bool(message.allowFindByContacts);
        }
        if (message.allowOthersDownloadVideo !== false) {
          writer.uint32(8024).bool(message.allowOthersDownloadVideo);
        }
        if (message.allowOthersDownloadWhenSharingVideo !== false) {
          writer.uint32(8032).bool(message.allowOthersDownloadWhenSharingVideo);
        }
        if (message.allowShareShowProfile !== false) {
          writer.uint32(8040).bool(message.allowShareShowProfile);
        }
        if (message.allowShowInGossip !== false) {
          writer.uint32(8048).bool(message.allowShowInGossip);
        }
        if (message.allowShowMyAction !== false) {
          writer.uint32(8056).bool(message.allowShowMyAction);
        }
        if (message.allowStrangeComment !== false) {
          writer.uint32(8064).bool(message.allowStrangeComment);
        }
        if (message.allowUnfollowerComment !== false) {
          writer.uint32(8072).bool(message.allowUnfollowerComment);
        }
        if (message.allowUseLinkmic !== false) {
          writer.uint32(8080).bool(message.allowUseLinkmic);
        }
        if (message.avatarJpg !== void 0) {
          exports2.Image.encode(message.avatarJpg, writer.uint32(8098).fork()).join();
        }
        if (message.backgroundImgUrl !== "") {
          writer.uint32(8106).string(message.backgroundImgUrl);
        }
        if (message.blockStatus !== 0) {
          writer.uint32(8128).int32(message.blockStatus);
        }
        if (message.commentRestrict !== 0) {
          writer.uint32(8136).int32(message.commentRestrict);
        }
        if (message.constellation !== "") {
          writer.uint32(8146).string(message.constellation);
        }
        if (message.disableIchat !== 0) {
          writer.uint32(8152).int32(message.disableIchat);
        }
        if (message.enableIchatImg !== "0") {
          writer.uint32(8160).int64(message.enableIchatImg);
        }
        if (message.exp !== 0) {
          writer.uint32(8168).int32(message.exp);
        }
        if (message.foldStrangerChat !== false) {
          writer.uint32(8184).bool(message.foldStrangerChat);
        }
        if (message.followStatus !== "0") {
          writer.uint32(8192).int64(message.followStatus);
        }
        if (message.ichatRestrictType !== 0) {
          writer.uint32(8216).int32(message.ichatRestrictType);
        }
        if (message.idStr !== "") {
          writer.uint32(8226).string(message.idStr);
        }
        if (message.isFollower !== false) {
          writer.uint32(8232).bool(message.isFollower);
        }
        if (message.isFollowing !== false) {
          writer.uint32(8240).bool(message.isFollowing);
        }
        if (message.needProfileGuide !== false) {
          writer.uint32(8248).bool(message.needProfileGuide);
        }
        if (message.pushCommentStatus !== false) {
          writer.uint32(8264).bool(message.pushCommentStatus);
        }
        if (message.pushDigg !== false) {
          writer.uint32(8272).bool(message.pushDigg);
        }
        if (message.pushFollow !== false) {
          writer.uint32(8280).bool(message.pushFollow);
        }
        if (message.pushFriendAction !== false) {
          writer.uint32(8288).bool(message.pushFriendAction);
        }
        if (message.pushIchat !== false) {
          writer.uint32(8296).bool(message.pushIchat);
        }
        if (message.pushStatus !== false) {
          writer.uint32(8304).bool(message.pushStatus);
        }
        if (message.pushVideoPost !== false) {
          writer.uint32(8312).bool(message.pushVideoPost);
        }
        if (message.pushVideoRecommend !== false) {
          writer.uint32(8320).bool(message.pushVideoRecommend);
        }
        if (message.verifiedReason !== "") {
          writer.uint32(8346).string(message.verifiedReason);
        }
        if (message.enableCarManagementPermission !== false) {
          writer.uint32(8352).bool(message.enableCarManagementPermission);
        }
        for (const v of message.upcomingEventList) {
          exports2.User_LiveEventInfo.encode(v, writer.uint32(8362).fork()).join();
        }
        if (message.scmLabel !== "") {
          writer.uint32(8370).string(message.scmLabel);
        }
        if (message.ecommerceEntrance !== void 0) {
          exports2.User_EcommerceEntrance.encode(message.ecommerceEntrance, writer.uint32(8378).fork()).join();
        }
        if (message.isBlock !== false) {
          writer.uint32(8384).bool(message.isBlock);
        }
        if (message.isSubscribe !== false) {
          writer.uint32(8720).bool(message.isSubscribe);
        }
        if (message.isAnchorMarked !== false) {
          writer.uint32(8728).bool(message.isAnchorMarked);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.nickname = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.bioDescription = reader.string();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.profilePicture = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.profilePictureMedium = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.profilePictureLarge = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.verified = reader.bool();
              continue;
            }
            case 15: {
              if (tag !== 120) {
                break;
              }
              message.status = reader.int32();
              continue;
            }
            case 16: {
              if (tag !== 128) {
                break;
              }
              message.createTime = reader.int64().toString();
              continue;
            }
            case 17: {
              if (tag !== 136) {
                break;
              }
              message.modifyTime = reader.int64().toString();
              continue;
            }
            case 18: {
              if (tag !== 144) {
                break;
              }
              message.secret = reader.int32();
              continue;
            }
            case 19: {
              if (tag !== 154) {
                break;
              }
              message.shareQrcodeUri = reader.string();
              continue;
            }
            case 21: {
              if (tag !== 170) {
                break;
              }
              message.badgeImageList.push(exports2.Image.decode(reader, reader.uint32()));
              continue;
            }
            case 22: {
              if (tag !== 178) {
                break;
              }
              message.followInfo = exports2.User_FollowInfo.decode(reader, reader.uint32());
              continue;
            }
            case 23: {
              if (tag !== 186) {
                break;
              }
              message.userHonor = exports2.UserHonor.decode(reader, reader.uint32());
              continue;
            }
            case 24: {
              if (tag !== 194) {
                break;
              }
              message.fansClub = exports2.FansClubMember.decode(reader, reader.uint32());
              continue;
            }
            case 25: {
              if (tag !== 202) {
                break;
              }
              message.border = exports2.BorderInfo.decode(reader, reader.uint32());
              continue;
            }
            case 26: {
              if (tag !== 210) {
                break;
              }
              message.specialId = reader.string();
              continue;
            }
            case 27: {
              if (tag !== 218) {
                break;
              }
              message.avatarBorder = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 28: {
              if (tag !== 226) {
                break;
              }
              message.medal = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 29: {
              if (tag !== 234) {
                break;
              }
              message.userBadges.push(exports2.Image.decode(reader, reader.uint32()));
              continue;
            }
            case 30: {
              if (tag !== 242) {
                break;
              }
              message.newUserBadges.push(exports2.Image.decode(reader, reader.uint32()));
              continue;
            }
            case 31: {
              if (tag !== 248) {
                break;
              }
              message.topVipNo = reader.int32();
              continue;
            }
            case 32: {
              if (tag !== 258) {
                break;
              }
              message.userAttr = exports2.User_UserAttr.decode(reader, reader.uint32());
              continue;
            }
            case 33: {
              if (tag !== 266) {
                break;
              }
              message.ownRoom = exports2.User_OwnRoom.decode(reader, reader.uint32());
              continue;
            }
            case 34: {
              if (tag !== 272) {
                break;
              }
              message.payScore = reader.int64().toString();
              continue;
            }
            case 35: {
              if (tag !== 280) {
                break;
              }
              message.fanTicketCount = reader.int64().toString();
              continue;
            }
            case 36: {
              if (tag !== 290) {
                break;
              }
              message.anchorInfo = exports2.User_AnchorLevel.decode(reader, reader.uint32());
              continue;
            }
            case 37: {
              if (tag !== 296) {
                break;
              }
              message.linkMicStats = reader.int32();
              continue;
            }
            case 38: {
              if (tag !== 306) {
                break;
              }
              message.uniqueId = reader.string();
              continue;
            }
            case 39: {
              if (tag !== 312) {
                break;
              }
              message.enableShowCommerceSale = reader.bool();
              continue;
            }
            case 40: {
              if (tag !== 320) {
                break;
              }
              message.withFusionShopEntry = reader.bool();
              continue;
            }
            case 41: {
              if (tag !== 328) {
                break;
              }
              message.payScores = reader.int64().toString();
              continue;
            }
            case 42: {
              if (tag !== 338) {
                break;
              }
              message.anchorLevel = exports2.User_AnchorLevel.decode(reader, reader.uint32());
              continue;
            }
            case 43: {
              if (tag !== 346) {
                break;
              }
              message.verifiedContent = reader.string();
              continue;
            }
            case 44: {
              if (tag !== 354) {
                break;
              }
              message.authorInfo = exports2.Author.decode(reader, reader.uint32());
              continue;
            }
            case 45: {
              if (tag !== 362) {
                break;
              }
              message.topFans.push(exports2.User.decode(reader, reader.uint32()));
              continue;
            }
            case 46: {
              if (tag !== 370) {
                break;
              }
              message.secUid = reader.string();
              continue;
            }
            case 47: {
              if (tag !== 376) {
                break;
              }
              message.userRole = reader.int32();
              continue;
            }
            case 49: {
              if (tag !== 394) {
                break;
              }
              message.rewardInfo = exports2.User_ActivityInfo.decode(reader, reader.uint32());
              continue;
            }
            case 52: {
              if (tag !== 418) {
                break;
              }
              message.personalCard = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 53: {
              if (tag !== 426) {
                break;
              }
              message.authenticationInfo = exports2.User_AuthenticationInfo.decode(reader, reader.uint32());
              continue;
            }
            case 57: {
              if (tag !== 458) {
                break;
              }
              message.mediaBadgeImageList.push(exports2.Image.decode(reader, reader.uint32()));
              continue;
            }
            case 60: {
              if (tag === 480) {
                message.commerceWebcastConfigIds.push(reader.int64().toString());
                continue;
              }
              if (tag === 482) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.commerceWebcastConfigIds.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
            case 61: {
              if (tag !== 490) {
                break;
              }
              message.borders.push(exports2.BorderInfo.decode(reader, reader.uint32()));
              continue;
            }
            case 62: {
              if (tag !== 498) {
                break;
              }
              message.comboBadgeInfo = exports2.User_ComboBadgeInfo.decode(reader, reader.uint32());
              continue;
            }
            case 63: {
              if (tag !== 506) {
                break;
              }
              message.subscribeInfo = exports2.User_SubscribeInfo.decode(reader, reader.uint32());
              continue;
            }
            case 64: {
              if (tag !== 514) {
                break;
              }
              message.badges.push(exports2.BadgeStruct.decode(reader, reader.uint32()));
              continue;
            }
            case 65: {
              if (tag === 520) {
                message.mintTypeLabel.push(reader.int64().toString());
                continue;
              }
              if (tag === 522) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.mintTypeLabel.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
            case 66: {
              if (tag !== 530) {
                break;
              }
              message.fansClubInfo = exports2.User_FansClubInfo.decode(reader, reader.uint32());
              continue;
            }
            case 1002: {
              if (tag !== 8016) {
                break;
              }
              message.allowFindByContacts = reader.bool();
              continue;
            }
            case 1003: {
              if (tag !== 8024) {
                break;
              }
              message.allowOthersDownloadVideo = reader.bool();
              continue;
            }
            case 1004: {
              if (tag !== 8032) {
                break;
              }
              message.allowOthersDownloadWhenSharingVideo = reader.bool();
              continue;
            }
            case 1005: {
              if (tag !== 8040) {
                break;
              }
              message.allowShareShowProfile = reader.bool();
              continue;
            }
            case 1006: {
              if (tag !== 8048) {
                break;
              }
              message.allowShowInGossip = reader.bool();
              continue;
            }
            case 1007: {
              if (tag !== 8056) {
                break;
              }
              message.allowShowMyAction = reader.bool();
              continue;
            }
            case 1008: {
              if (tag !== 8064) {
                break;
              }
              message.allowStrangeComment = reader.bool();
              continue;
            }
            case 1009: {
              if (tag !== 8072) {
                break;
              }
              message.allowUnfollowerComment = reader.bool();
              continue;
            }
            case 1010: {
              if (tag !== 8080) {
                break;
              }
              message.allowUseLinkmic = reader.bool();
              continue;
            }
            case 1012: {
              if (tag !== 8098) {
                break;
              }
              message.avatarJpg = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 1013: {
              if (tag !== 8106) {
                break;
              }
              message.backgroundImgUrl = reader.string();
              continue;
            }
            case 1016: {
              if (tag !== 8128) {
                break;
              }
              message.blockStatus = reader.int32();
              continue;
            }
            case 1017: {
              if (tag !== 8136) {
                break;
              }
              message.commentRestrict = reader.int32();
              continue;
            }
            case 1018: {
              if (tag !== 8146) {
                break;
              }
              message.constellation = reader.string();
              continue;
            }
            case 1019: {
              if (tag !== 8152) {
                break;
              }
              message.disableIchat = reader.int32();
              continue;
            }
            case 1020: {
              if (tag !== 8160) {
                break;
              }
              message.enableIchatImg = reader.int64().toString();
              continue;
            }
            case 1021: {
              if (tag !== 8168) {
                break;
              }
              message.exp = reader.int32();
              continue;
            }
            case 1023: {
              if (tag !== 8184) {
                break;
              }
              message.foldStrangerChat = reader.bool();
              continue;
            }
            case 1024: {
              if (tag !== 8192) {
                break;
              }
              message.followStatus = reader.int64().toString();
              continue;
            }
            case 1027: {
              if (tag !== 8216) {
                break;
              }
              message.ichatRestrictType = reader.int32();
              continue;
            }
            case 1028: {
              if (tag !== 8226) {
                break;
              }
              message.idStr = reader.string();
              continue;
            }
            case 1029: {
              if (tag !== 8232) {
                break;
              }
              message.isFollower = reader.bool();
              continue;
            }
            case 1030: {
              if (tag !== 8240) {
                break;
              }
              message.isFollowing = reader.bool();
              continue;
            }
            case 1031: {
              if (tag !== 8248) {
                break;
              }
              message.needProfileGuide = reader.bool();
              continue;
            }
            case 1033: {
              if (tag !== 8264) {
                break;
              }
              message.pushCommentStatus = reader.bool();
              continue;
            }
            case 1034: {
              if (tag !== 8272) {
                break;
              }
              message.pushDigg = reader.bool();
              continue;
            }
            case 1035: {
              if (tag !== 8280) {
                break;
              }
              message.pushFollow = reader.bool();
              continue;
            }
            case 1036: {
              if (tag !== 8288) {
                break;
              }
              message.pushFriendAction = reader.bool();
              continue;
            }
            case 1037: {
              if (tag !== 8296) {
                break;
              }
              message.pushIchat = reader.bool();
              continue;
            }
            case 1038: {
              if (tag !== 8304) {
                break;
              }
              message.pushStatus = reader.bool();
              continue;
            }
            case 1039: {
              if (tag !== 8312) {
                break;
              }
              message.pushVideoPost = reader.bool();
              continue;
            }
            case 1040: {
              if (tag !== 8320) {
                break;
              }
              message.pushVideoRecommend = reader.bool();
              continue;
            }
            case 1043: {
              if (tag !== 8346) {
                break;
              }
              message.verifiedReason = reader.string();
              continue;
            }
            case 1044: {
              if (tag !== 8352) {
                break;
              }
              message.enableCarManagementPermission = reader.bool();
              continue;
            }
            case 1045: {
              if (tag !== 8362) {
                break;
              }
              message.upcomingEventList.push(exports2.User_LiveEventInfo.decode(reader, reader.uint32()));
              continue;
            }
            case 1046: {
              if (tag !== 8370) {
                break;
              }
              message.scmLabel = reader.string();
              continue;
            }
            case 1047: {
              if (tag !== 8378) {
                break;
              }
              message.ecommerceEntrance = exports2.User_EcommerceEntrance.decode(reader, reader.uint32());
              continue;
            }
            case 1048: {
              if (tag !== 8384) {
                break;
              }
              message.isBlock = reader.bool();
              continue;
            }
            case 1090: {
              if (tag !== 8720) {
                break;
              }
              message.isSubscribe = reader.bool();
              continue;
            }
            case 1091: {
              if (tag !== 8728) {
                break;
              }
              message.isAnchorMarked = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_LiveEventInfo() {
      return {
        eventId: "0",
        startTime: "0",
        duration: "0",
        title: "",
        description: "",
        hasSubscribed: false,
        isPaidEvent: false,
        ticketAmount: "0",
        payMethod: "0"
      };
    }
    exports2.User_LiveEventInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.eventId !== "0") {
          writer.uint32(8).int64(message.eventId);
        }
        if (message.startTime !== "0") {
          writer.uint32(16).int64(message.startTime);
        }
        if (message.duration !== "0") {
          writer.uint32(24).int64(message.duration);
        }
        if (message.title !== "") {
          writer.uint32(34).string(message.title);
        }
        if (message.description !== "") {
          writer.uint32(42).string(message.description);
        }
        if (message.hasSubscribed !== false) {
          writer.uint32(48).bool(message.hasSubscribed);
        }
        if (message.isPaidEvent !== false) {
          writer.uint32(56).bool(message.isPaidEvent);
        }
        if (message.ticketAmount !== "0") {
          writer.uint32(64).int64(message.ticketAmount);
        }
        if (message.payMethod !== "0") {
          writer.uint32(72).int64(message.payMethod);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_LiveEventInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.eventId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.startTime = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.duration = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.title = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.description = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.hasSubscribed = reader.bool();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.isPaidEvent = reader.bool();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.ticketAmount = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.payMethod = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_LiveEventInfo_WalletPackage() {
      return { iapId: "", usdPriceShow: "" };
    }
    exports2.User_LiveEventInfo_WalletPackage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.iapId !== "") {
          writer.uint32(10).string(message.iapId);
        }
        if (message.usdPriceShow !== "") {
          writer.uint32(18).string(message.usdPriceShow);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_LiveEventInfo_WalletPackage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.iapId = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.usdPriceShow = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_ActivityInfo() {
      return { badge: void 0, storytag: void 0 };
    }
    exports2.User_ActivityInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.badge !== void 0) {
          exports2.Image.encode(message.badge, writer.uint32(10).fork()).join();
        }
        if (message.storytag !== void 0) {
          exports2.Image.encode(message.storytag, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_ActivityInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.badge = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.storytag = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_AnchorLevel() {
      return {
        level: "0",
        experience: "0",
        lowestExperienceThisLevel: "0",
        highestExperienceThisLevel: "0",
        taskStartExperience: "0",
        taskStartTime: "0",
        taskDecreaseExperience: "0",
        taskTargetExperience: "0",
        taskEndTime: "0",
        profileDialogBg: void 0,
        profileDialogBgBack: void 0,
        stageLevel: void 0,
        smallIcon: void 0
      };
    }
    exports2.User_AnchorLevel = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.level !== "0") {
          writer.uint32(8).int64(message.level);
        }
        if (message.experience !== "0") {
          writer.uint32(16).int64(message.experience);
        }
        if (message.lowestExperienceThisLevel !== "0") {
          writer.uint32(24).int64(message.lowestExperienceThisLevel);
        }
        if (message.highestExperienceThisLevel !== "0") {
          writer.uint32(32).int64(message.highestExperienceThisLevel);
        }
        if (message.taskStartExperience !== "0") {
          writer.uint32(40).int64(message.taskStartExperience);
        }
        if (message.taskStartTime !== "0") {
          writer.uint32(48).int64(message.taskStartTime);
        }
        if (message.taskDecreaseExperience !== "0") {
          writer.uint32(56).int64(message.taskDecreaseExperience);
        }
        if (message.taskTargetExperience !== "0") {
          writer.uint32(64).int64(message.taskTargetExperience);
        }
        if (message.taskEndTime !== "0") {
          writer.uint32(72).int64(message.taskEndTime);
        }
        if (message.profileDialogBg !== void 0) {
          exports2.Image.encode(message.profileDialogBg, writer.uint32(82).fork()).join();
        }
        if (message.profileDialogBgBack !== void 0) {
          exports2.Image.encode(message.profileDialogBgBack, writer.uint32(90).fork()).join();
        }
        if (message.stageLevel !== void 0) {
          exports2.Image.encode(message.stageLevel, writer.uint32(98).fork()).join();
        }
        if (message.smallIcon !== void 0) {
          exports2.Image.encode(message.smallIcon, writer.uint32(106).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_AnchorLevel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.level = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.experience = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.lowestExperienceThisLevel = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.highestExperienceThisLevel = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.taskStartExperience = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.taskStartTime = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.taskDecreaseExperience = reader.int64().toString();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.taskTargetExperience = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.taskEndTime = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.profileDialogBg = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.profileDialogBgBack = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.stageLevel = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.smallIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_AuthenticationInfo() {
      return { customVerify: "", enterpriseVerifyReason: "", authenticationBadge: void 0 };
    }
    exports2.User_AuthenticationInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.customVerify !== "") {
          writer.uint32(10).string(message.customVerify);
        }
        if (message.enterpriseVerifyReason !== "") {
          writer.uint32(18).string(message.enterpriseVerifyReason);
        }
        if (message.authenticationBadge !== void 0) {
          exports2.Image.encode(message.authenticationBadge, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_AuthenticationInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.customVerify = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.enterpriseVerifyReason = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.authenticationBadge = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_AuthorStats() {
      return {
        videoTotalCount: "0",
        videoTotalPlayCount: "0",
        videoTotalShareCount: "0",
        videoTotalSeriesCount: "0",
        varietyShowPlayCount: "0",
        videoTotalFavoriteCount: "0"
      };
    }
    exports2.User_AuthorStats = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.videoTotalCount !== "0") {
          writer.uint32(8).int64(message.videoTotalCount);
        }
        if (message.videoTotalPlayCount !== "0") {
          writer.uint32(16).int64(message.videoTotalPlayCount);
        }
        if (message.videoTotalShareCount !== "0") {
          writer.uint32(24).int64(message.videoTotalShareCount);
        }
        if (message.videoTotalSeriesCount !== "0") {
          writer.uint32(32).int64(message.videoTotalSeriesCount);
        }
        if (message.varietyShowPlayCount !== "0") {
          writer.uint32(40).int64(message.varietyShowPlayCount);
        }
        if (message.videoTotalFavoriteCount !== "0") {
          writer.uint32(48).int64(message.videoTotalFavoriteCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_AuthorStats();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.videoTotalCount = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.videoTotalPlayCount = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.videoTotalShareCount = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.videoTotalSeriesCount = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.varietyShowPlayCount = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.videoTotalFavoriteCount = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_Border() {
      return {
        icon: void 0,
        level: "0",
        source: "",
        profileDecorationRibbon: void 0,
        avatarBackgroundColor: "",
        avatarBackgroundBorderColor: ""
      };
    }
    exports2.User_Border = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(10).fork()).join();
        }
        if (message.level !== "0") {
          writer.uint32(16).int64(message.level);
        }
        if (message.source !== "") {
          writer.uint32(26).string(message.source);
        }
        if (message.profileDecorationRibbon !== void 0) {
          exports2.Image.encode(message.profileDecorationRibbon, writer.uint32(34).fork()).join();
        }
        if (message.avatarBackgroundColor !== "") {
          writer.uint32(58).string(message.avatarBackgroundColor);
        }
        if (message.avatarBackgroundBorderColor !== "") {
          writer.uint32(66).string(message.avatarBackgroundBorderColor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_Border();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.level = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.source = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.profileDecorationRibbon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.avatarBackgroundColor = reader.string();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.avatarBackgroundBorderColor = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_ComboBadgeInfo() {
      return { icon: void 0, comboCount: "0" };
    }
    exports2.User_ComboBadgeInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(10).fork()).join();
        }
        if (message.comboCount !== "0") {
          writer.uint32(16).int64(message.comboCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_ComboBadgeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.comboCount = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_EcommerceEntrance() {
      return { entranceType: 0, creatorType: 0, schema: "", shopEntranceInfo: void 0, showcaseEntranceInfo: void 0 };
    }
    exports2.User_EcommerceEntrance = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.entranceType !== 0) {
          writer.uint32(8).int32(message.entranceType);
        }
        if (message.creatorType !== 0) {
          writer.uint32(16).int32(message.creatorType);
        }
        if (message.schema !== "") {
          writer.uint32(26).string(message.schema);
        }
        if (message.shopEntranceInfo !== void 0) {
          exports2.User_EcommerceEntrance_ShopEntranceInfo.encode(message.shopEntranceInfo, writer.uint32(34).fork()).join();
        }
        if (message.showcaseEntranceInfo !== void 0) {
          exports2.User_EcommerceEntrance_ShowcaseEntranceInfo.encode(message.showcaseEntranceInfo, writer.uint32(42).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_EcommerceEntrance();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.entranceType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.creatorType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.schema = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.shopEntranceInfo = exports2.User_EcommerceEntrance_ShopEntranceInfo.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.showcaseEntranceInfo = exports2.User_EcommerceEntrance_ShowcaseEntranceInfo.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_EcommerceEntrance_ShopEntranceInfo() {
      return {
        shopId: "",
        shopName: "",
        shopRating: "",
        storeLabel: void 0,
        formatSoldCount: "",
        soldCount: "0",
        expRatePercentile: 0,
        expRateTopDisplay: "",
        rateDisplayStyle: 0,
        showRateNotApplicable: false
      };
    }
    exports2.User_EcommerceEntrance_ShopEntranceInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.shopId !== "") {
          writer.uint32(10).string(message.shopId);
        }
        if (message.shopName !== "") {
          writer.uint32(18).string(message.shopName);
        }
        if (message.shopRating !== "") {
          writer.uint32(26).string(message.shopRating);
        }
        if (message.storeLabel !== void 0) {
          exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel.encode(message.storeLabel, writer.uint32(34).fork()).join();
        }
        if (message.formatSoldCount !== "") {
          writer.uint32(42).string(message.formatSoldCount);
        }
        if (message.soldCount !== "0") {
          writer.uint32(48).int64(message.soldCount);
        }
        if (message.expRatePercentile !== 0) {
          writer.uint32(56).int32(message.expRatePercentile);
        }
        if (message.expRateTopDisplay !== "") {
          writer.uint32(66).string(message.expRateTopDisplay);
        }
        if (message.rateDisplayStyle !== 0) {
          writer.uint32(72).int32(message.rateDisplayStyle);
        }
        if (message.showRateNotApplicable !== false) {
          writer.uint32(80).bool(message.showRateNotApplicable);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.shopId = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.shopName = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.shopRating = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.storeLabel = exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.formatSoldCount = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.soldCount = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.expRatePercentile = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.expRateTopDisplay = reader.string();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.rateDisplayStyle = reader.int32();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.showRateNotApplicable = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel() {
      return { officialLabel: void 0, isBytemall: false };
    }
    exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.officialLabel !== void 0) {
          exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel.encode(message.officialLabel, writer.uint32(10).fork()).join();
        }
        if (message.isBytemall !== false) {
          writer.uint32(16).bool(message.isBytemall);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.officialLabel = exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.isBytemall = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel() {
      return { labelImageLight: void 0, labelImageDark: void 0, labelType: "0", labelTypeStr: "" };
    }
    exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.labelImageLight !== void 0) {
          exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage.encode(message.labelImageLight, writer.uint32(10).fork()).join();
        }
        if (message.labelImageDark !== void 0) {
          exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage.encode(message.labelImageDark, writer.uint32(18).fork()).join();
        }
        if (message.labelType !== "0") {
          writer.uint32(24).int64(message.labelType);
        }
        if (message.labelTypeStr !== "") {
          writer.uint32(34).string(message.labelTypeStr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.labelImageLight = exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.labelImageDark = exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.labelType = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.labelTypeStr = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage() {
      return { height: 0, width: 0, minetype: "", thumbUri: "", thumbUriList: [], uri: "", urlList: [], color: "" };
    }
    exports2.User_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.height !== 0) {
          writer.uint32(8).int32(message.height);
        }
        if (message.width !== 0) {
          writer.uint32(16).int32(message.width);
        }
        if (message.minetype !== "") {
          writer.uint32(26).string(message.minetype);
        }
        if (message.thumbUri !== "") {
          writer.uint32(34).string(message.thumbUri);
        }
        for (const v of message.thumbUriList) {
          writer.uint32(42).string(v);
        }
        if (message.uri !== "") {
          writer.uint32(50).string(message.uri);
        }
        for (const v of message.urlList) {
          writer.uint32(58).string(v);
        }
        if (message.color !== "") {
          writer.uint32(66).string(message.color);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_EcommerceEntrance_ShopEntranceInfo_StoreLabel_StoreOfficialLabel_ShopLabelImage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.height = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.width = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.minetype = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.thumbUri = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.thumbUriList.push(reader.string());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.uri = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.urlList.push(reader.string());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.color = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_EcommerceEntrance_ShowcaseEntranceInfo() {
      return { formatSoldCount: "", soldCount: "0" };
    }
    exports2.User_EcommerceEntrance_ShowcaseEntranceInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.formatSoldCount !== "") {
          writer.uint32(10).string(message.formatSoldCount);
        }
        if (message.soldCount !== "0") {
          writer.uint32(16).int64(message.soldCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_EcommerceEntrance_ShowcaseEntranceInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.formatSoldCount = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.soldCount = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_FansClub() {
      return { data: void 0 };
    }
    exports2.User_FansClub = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.data !== void 0) {
          exports2.User_FansClub_FansClubData.encode(message.data, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_FansClub();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.data = exports2.User_FansClub_FansClubData.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_FansClub_FansClubData() {
      return { clubName: "", level: 0, userFansClubStatus: 0, availableGiftIdsList: [], anchorId: "0" };
    }
    exports2.User_FansClub_FansClubData = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.clubName !== "") {
          writer.uint32(10).string(message.clubName);
        }
        if (message.level !== 0) {
          writer.uint32(16).int32(message.level);
        }
        if (message.userFansClubStatus !== 0) {
          writer.uint32(24).int32(message.userFansClubStatus);
        }
        writer.uint32(42).fork();
        for (const v of message.availableGiftIdsList) {
          writer.int64(v);
        }
        writer.join();
        if (message.anchorId !== "0") {
          writer.uint32(48).int64(message.anchorId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_FansClub_FansClubData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.clubName = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.level = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.userFansClubStatus = reader.int32();
              continue;
            }
            case 5: {
              if (tag === 40) {
                message.availableGiftIdsList.push(reader.int64().toString());
                continue;
              }
              if (tag === 42) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.availableGiftIdsList.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.anchorId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_FansClubInfo() {
      return { isSleeping: false, fansLevel: "0", fansScore: "0", badge: void 0, fansCount: "0", fansClubName: "" };
    }
    exports2.User_FansClubInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.isSleeping !== false) {
          writer.uint32(8).bool(message.isSleeping);
        }
        if (message.fansLevel !== "0") {
          writer.uint32(16).int64(message.fansLevel);
        }
        if (message.fansScore !== "0") {
          writer.uint32(24).int64(message.fansScore);
        }
        if (message.badge !== void 0) {
          exports2.Image.encode(message.badge, writer.uint32(34).fork()).join();
        }
        if (message.fansCount !== "0") {
          writer.uint32(40).int64(message.fansCount);
        }
        if (message.fansClubName !== "") {
          writer.uint32(50).string(message.fansClubName);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_FansClubInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.isSleeping = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.fansLevel = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.fansScore = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.badge = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.fansCount = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.fansClubName = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_FollowInfo() {
      return { followingCount: "0", followerCount: "0", followStatus: "0", pushStatus: "0" };
    }
    exports2.User_FollowInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.followingCount !== "0") {
          writer.uint32(8).int64(message.followingCount);
        }
        if (message.followerCount !== "0") {
          writer.uint32(16).int64(message.followerCount);
        }
        if (message.followStatus !== "0") {
          writer.uint32(24).int64(message.followStatus);
        }
        if (message.pushStatus !== "0") {
          writer.uint32(32).int64(message.pushStatus);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_FollowInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.followingCount = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.followerCount = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.followStatus = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.pushStatus = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_OwnRoom() {
      return { roomIdsList: [], roomIdsStrList: [] };
    }
    exports2.User_OwnRoom = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.roomIdsList) {
          writer.int64(v);
        }
        writer.join();
        for (const v of message.roomIdsStrList) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_OwnRoom();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag === 8) {
                message.roomIdsList.push(reader.int64().toString());
                continue;
              }
              if (tag === 10) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.roomIdsList.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.roomIdsStrList.push(reader.string());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_PayGrade() {
      return {
        diamondIcon: void 0,
        name: "",
        icon: void 0,
        nextName: "",
        level: "0",
        nextIcon: void 0,
        gradeDescribe: "",
        gradeIconList: [],
        screenChatType: "0",
        imIcon: void 0,
        imIconWithLevel: void 0,
        liveIcon: void 0,
        newImIconWithLevel: void 0,
        newLiveIcon: void 0,
        upgradeNeedConsume: "0",
        nextPrivileges: "",
        background: void 0,
        backgroundBack: void 0,
        score: "0",
        gradeBanner: "",
        profileDialogBg: void 0,
        profileDialogBgBack: void 0
      };
    }
    exports2.User_PayGrade = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.diamondIcon !== void 0) {
          exports2.Image.encode(message.diamondIcon, writer.uint32(18).fork()).join();
        }
        if (message.name !== "") {
          writer.uint32(26).string(message.name);
        }
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(34).fork()).join();
        }
        if (message.nextName !== "") {
          writer.uint32(42).string(message.nextName);
        }
        if (message.level !== "0") {
          writer.uint32(48).int64(message.level);
        }
        if (message.nextIcon !== void 0) {
          exports2.Image.encode(message.nextIcon, writer.uint32(58).fork()).join();
        }
        if (message.gradeDescribe !== "") {
          writer.uint32(106).string(message.gradeDescribe);
        }
        for (const v of message.gradeIconList) {
          exports2.GradeIcon.encode(v, writer.uint32(114).fork()).join();
        }
        if (message.screenChatType !== "0") {
          writer.uint32(120).int64(message.screenChatType);
        }
        if (message.imIcon !== void 0) {
          exports2.Image.encode(message.imIcon, writer.uint32(130).fork()).join();
        }
        if (message.imIconWithLevel !== void 0) {
          exports2.Image.encode(message.imIconWithLevel, writer.uint32(138).fork()).join();
        }
        if (message.liveIcon !== void 0) {
          exports2.Image.encode(message.liveIcon, writer.uint32(146).fork()).join();
        }
        if (message.newImIconWithLevel !== void 0) {
          exports2.Image.encode(message.newImIconWithLevel, writer.uint32(154).fork()).join();
        }
        if (message.newLiveIcon !== void 0) {
          exports2.Image.encode(message.newLiveIcon, writer.uint32(162).fork()).join();
        }
        if (message.upgradeNeedConsume !== "0") {
          writer.uint32(168).int64(message.upgradeNeedConsume);
        }
        if (message.nextPrivileges !== "") {
          writer.uint32(178).string(message.nextPrivileges);
        }
        if (message.background !== void 0) {
          exports2.Image.encode(message.background, writer.uint32(186).fork()).join();
        }
        if (message.backgroundBack !== void 0) {
          exports2.Image.encode(message.backgroundBack, writer.uint32(194).fork()).join();
        }
        if (message.score !== "0") {
          writer.uint32(200).int64(message.score);
        }
        if (message.gradeBanner !== "") {
          writer.uint32(8010).string(message.gradeBanner);
        }
        if (message.profileDialogBg !== void 0) {
          exports2.Image.encode(message.profileDialogBg, writer.uint32(8018).fork()).join();
        }
        if (message.profileDialogBgBack !== void 0) {
          exports2.Image.encode(message.profileDialogBgBack, writer.uint32(8026).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_PayGrade();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.diamondIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.name = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.nextName = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.level = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.nextIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.gradeDescribe = reader.string();
              continue;
            }
            case 14: {
              if (tag !== 114) {
                break;
              }
              message.gradeIconList.push(exports2.GradeIcon.decode(reader, reader.uint32()));
              continue;
            }
            case 15: {
              if (tag !== 120) {
                break;
              }
              message.screenChatType = reader.int64().toString();
              continue;
            }
            case 16: {
              if (tag !== 130) {
                break;
              }
              message.imIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 17: {
              if (tag !== 138) {
                break;
              }
              message.imIconWithLevel = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 18: {
              if (tag !== 146) {
                break;
              }
              message.liveIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 19: {
              if (tag !== 154) {
                break;
              }
              message.newImIconWithLevel = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 20: {
              if (tag !== 162) {
                break;
              }
              message.newLiveIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 21: {
              if (tag !== 168) {
                break;
              }
              message.upgradeNeedConsume = reader.int64().toString();
              continue;
            }
            case 22: {
              if (tag !== 178) {
                break;
              }
              message.nextPrivileges = reader.string();
              continue;
            }
            case 23: {
              if (tag !== 186) {
                break;
              }
              message.background = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 24: {
              if (tag !== 194) {
                break;
              }
              message.backgroundBack = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 25: {
              if (tag !== 200) {
                break;
              }
              message.score = reader.int64().toString();
              continue;
            }
            case 1001: {
              if (tag !== 8010) {
                break;
              }
              message.gradeBanner = reader.string();
              continue;
            }
            case 1002: {
              if (tag !== 8018) {
                break;
              }
              message.profileDialogBg = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 1003: {
              if (tag !== 8026) {
                break;
              }
              message.profileDialogBgBack = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_SubscribeBadge() {
      return { originImg: void 0, previewImg: void 0 };
    }
    exports2.User_SubscribeBadge = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.originImg !== void 0) {
          exports2.Image.encode(message.originImg, writer.uint32(26).fork()).join();
        }
        if (message.previewImg !== void 0) {
          exports2.Image.encode(message.previewImg, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_SubscribeBadge();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.originImg = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.previewImg = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_SubscribeInfo() {
      return {
        qualification: false,
        isSubscribe: false,
        badge: void 0,
        enableSubscription: false,
        subscriberCount: "0",
        isInGracePeriod: false,
        isSubscribedToAnchor: false,
        userGiftSubAuth: false,
        anchorGiftSubAuth: false
      };
    }
    exports2.User_SubscribeInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.qualification !== false) {
          writer.uint32(8).bool(message.qualification);
        }
        if (message.isSubscribe !== false) {
          writer.uint32(16).bool(message.isSubscribe);
        }
        if (message.badge !== void 0) {
          exports2.User_SubscribeBadge.encode(message.badge, writer.uint32(26).fork()).join();
        }
        if (message.enableSubscription !== false) {
          writer.uint32(32).bool(message.enableSubscription);
        }
        if (message.subscriberCount !== "0") {
          writer.uint32(40).int64(message.subscriberCount);
        }
        if (message.isInGracePeriod !== false) {
          writer.uint32(48).bool(message.isInGracePeriod);
        }
        if (message.isSubscribedToAnchor !== false) {
          writer.uint32(56).bool(message.isSubscribedToAnchor);
        }
        if (message.userGiftSubAuth !== false) {
          writer.uint32(72).bool(message.userGiftSubAuth);
        }
        if (message.anchorGiftSubAuth !== false) {
          writer.uint32(80).bool(message.anchorGiftSubAuth);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_SubscribeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.qualification = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.isSubscribe = reader.bool();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.badge = exports2.User_SubscribeBadge.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.enableSubscription = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.subscriberCount = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.isInGracePeriod = reader.bool();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.isSubscribedToAnchor = reader.bool();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.userGiftSubAuth = reader.bool();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.anchorGiftSubAuth = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_UserAttr() {
      return { isMuted: false, isAdmin: false, isSuperAdmin: false, muteDuration: "0" };
    }
    exports2.User_UserAttr = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.isMuted !== false) {
          writer.uint32(8).bool(message.isMuted);
        }
        if (message.isAdmin !== false) {
          writer.uint32(16).bool(message.isAdmin);
        }
        if (message.isSuperAdmin !== false) {
          writer.uint32(24).bool(message.isSuperAdmin);
        }
        if (message.muteDuration !== "0") {
          writer.uint32(32).int64(message.muteDuration);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_UserAttr();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.isMuted = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.isAdmin = reader.bool();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.isSuperAdmin = reader.bool();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.muteDuration = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUser_UserStats() {
      return {
        id: "0",
        idStr: "",
        followingCount: "0",
        followerCount: "0",
        recordCount: "0",
        totalDuration: "0",
        dailyFanTicketCount: "0",
        dailyIncome: "0",
        itemCount: "0",
        favoriteItemCount: "0",
        diamondConsumedCount: "0",
        tuwenItemCount: "0"
      };
    }
    exports2.User_UserStats = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== "0") {
          writer.uint32(8).int64(message.id);
        }
        if (message.idStr !== "") {
          writer.uint32(18).string(message.idStr);
        }
        if (message.followingCount !== "0") {
          writer.uint32(24).int64(message.followingCount);
        }
        if (message.followerCount !== "0") {
          writer.uint32(32).int64(message.followerCount);
        }
        if (message.recordCount !== "0") {
          writer.uint32(40).int64(message.recordCount);
        }
        if (message.totalDuration !== "0") {
          writer.uint32(48).int64(message.totalDuration);
        }
        if (message.dailyFanTicketCount !== "0") {
          writer.uint32(56).int64(message.dailyFanTicketCount);
        }
        if (message.dailyIncome !== "0") {
          writer.uint32(64).int64(message.dailyIncome);
        }
        if (message.itemCount !== "0") {
          writer.uint32(72).int64(message.itemCount);
        }
        if (message.favoriteItemCount !== "0") {
          writer.uint32(80).int64(message.favoriteItemCount);
        }
        if (message.diamondConsumedCount !== "0") {
          writer.uint32(96).int64(message.diamondConsumedCount);
        }
        if (message.tuwenItemCount !== "0") {
          writer.uint32(104).int64(message.tuwenItemCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUser_UserStats();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.idStr = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.followingCount = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.followerCount = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.recordCount = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.totalDuration = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.dailyFanTicketCount = reader.int64().toString();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.dailyIncome = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.itemCount = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.favoriteItemCount = reader.int64().toString();
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.diamondConsumedCount = reader.int64().toString();
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.tuwenItemCount = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseEmote() {
      return {
        emoteId: "",
        image: void 0,
        auditStatus: 0,
        uuid: "",
        emoteType: 0,
        contentSource: 0,
        emotePrivateType: 0,
        packageId: "",
        auditInfo: void 0,
        rewardCondition: 0,
        emoteUploadInfo: void 0,
        createTime: "0",
        emoteScene: 0
      };
    }
    exports2.Emote = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.emoteId !== "") {
          writer.uint32(10).string(message.emoteId);
        }
        if (message.image !== void 0) {
          exports2.Image.encode(message.image, writer.uint32(18).fork()).join();
        }
        if (message.auditStatus !== 0) {
          writer.uint32(24).int32(message.auditStatus);
        }
        if (message.uuid !== "") {
          writer.uint32(34).string(message.uuid);
        }
        if (message.emoteType !== 0) {
          writer.uint32(40).int32(message.emoteType);
        }
        if (message.contentSource !== 0) {
          writer.uint32(48).int32(message.contentSource);
        }
        if (message.emotePrivateType !== 0) {
          writer.uint32(56).int32(message.emotePrivateType);
        }
        if (message.packageId !== "") {
          writer.uint32(66).string(message.packageId);
        }
        if (message.auditInfo !== void 0) {
          exports2.Emote_AuditInfo.encode(message.auditInfo, writer.uint32(74).fork()).join();
        }
        if (message.rewardCondition !== 0) {
          writer.uint32(80).int32(message.rewardCondition);
        }
        if (message.emoteUploadInfo !== void 0) {
          exports2.Emote_EmoteUploadInfo.encode(message.emoteUploadInfo, writer.uint32(90).fork()).join();
        }
        if (message.createTime !== "0") {
          writer.uint32(96).int64(message.createTime);
        }
        if (message.emoteScene !== 0) {
          writer.uint32(104).int32(message.emoteScene);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEmote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.emoteId = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.image = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.auditStatus = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.uuid = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.emoteType = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.contentSource = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.emotePrivateType = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.packageId = reader.string();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.auditInfo = exports2.Emote_AuditInfo.decode(reader, reader.uint32());
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.rewardCondition = reader.int32();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.emoteUploadInfo = exports2.Emote_EmoteUploadInfo.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.createTime = reader.int64().toString();
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.emoteScene = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseEmote_AuditInfo() {
      return { violationId: "0", taskType: 0 };
    }
    exports2.Emote_AuditInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.violationId !== "0") {
          writer.uint32(8).int64(message.violationId);
        }
        if (message.taskType !== 0) {
          writer.uint32(16).int32(message.taskType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEmote_AuditInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.violationId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.taskType = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseEmote_EmoteUploadInfo() {
      return { userId: "0", emoteUploadSource: 0, userInfo: void 0, userIdStr: "" };
    }
    exports2.Emote_EmoteUploadInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.emoteUploadSource !== 0) {
          writer.uint32(16).int32(message.emoteUploadSource);
        }
        if (message.userInfo !== void 0) {
          exports2.User.encode(message.userInfo, writer.uint32(26).fork()).join();
        }
        if (message.userIdStr !== "") {
          writer.uint32(34).string(message.userIdStr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEmote_EmoteUploadInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.emoteUploadSource = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.userInfo = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.userIdStr = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePunishEventInfo() {
      return {
        punishType: "",
        punishReason: "",
        punishId: "",
        violationUid: "0",
        punishTypeId: 0,
        duration: "0",
        punishPerceptionCode: "",
        violationUidStr: "",
        showReason: ""
      };
    }
    exports2.PunishEventInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.punishType !== "") {
          writer.uint32(10).string(message.punishType);
        }
        if (message.punishReason !== "") {
          writer.uint32(18).string(message.punishReason);
        }
        if (message.punishId !== "") {
          writer.uint32(26).string(message.punishId);
        }
        if (message.violationUid !== "0") {
          writer.uint32(32).int64(message.violationUid);
        }
        if (message.punishTypeId !== 0) {
          writer.uint32(40).int32(message.punishTypeId);
        }
        if (message.duration !== "0") {
          writer.uint32(48).int64(message.duration);
        }
        if (message.punishPerceptionCode !== "") {
          writer.uint32(58).string(message.punishPerceptionCode);
        }
        if (message.violationUidStr !== "") {
          writer.uint32(74).string(message.violationUidStr);
        }
        if (message.showReason !== "") {
          writer.uint32(82).string(message.showReason);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePunishEventInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.punishType = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.punishReason = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.punishId = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.violationUid = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.punishTypeId = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.duration = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.punishPerceptionCode = reader.string();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.violationUidStr = reader.string();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.showReason = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseMsgFilter() {
      return { isGifter: false, isSubscribedToAnchor: false };
    }
    exports2.MsgFilter = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.isGifter !== false) {
          writer.uint32(8).bool(message.isGifter);
        }
        if (message.isSubscribedToAnchor !== false) {
          writer.uint32(16).bool(message.isSubscribedToAnchor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMsgFilter();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.isGifter = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.isSubscribedToAnchor = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUserIdentity() {
      return {
        isGiftGiverOfAnchor: false,
        isSubscriberOfAnchor: false,
        isMutualFollowingWithAnchor: false,
        isFollowerOfAnchor: false,
        isModeratorOfAnchor: false,
        isAnchor: false
      };
    }
    exports2.UserIdentity = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.isGiftGiverOfAnchor !== false) {
          writer.uint32(8).bool(message.isGiftGiverOfAnchor);
        }
        if (message.isSubscriberOfAnchor !== false) {
          writer.uint32(16).bool(message.isSubscriberOfAnchor);
        }
        if (message.isMutualFollowingWithAnchor !== false) {
          writer.uint32(24).bool(message.isMutualFollowingWithAnchor);
        }
        if (message.isFollowerOfAnchor !== false) {
          writer.uint32(32).bool(message.isFollowerOfAnchor);
        }
        if (message.isModeratorOfAnchor !== false) {
          writer.uint32(40).bool(message.isModeratorOfAnchor);
        }
        if (message.isAnchor !== false) {
          writer.uint32(48).bool(message.isAnchor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUserIdentity();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.isGiftGiverOfAnchor = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.isSubscriberOfAnchor = reader.bool();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.isMutualFollowingWithAnchor = reader.bool();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.isFollowerOfAnchor = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.isModeratorOfAnchor = reader.bool();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.isAnchor = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLiveStreamGoal() {
      return {
        id: "0",
        type: 0,
        status: 0,
        subGoals: [],
        description: "",
        auditStatus: 0,
        cycleType: 0,
        startTime: "0",
        expireTime: "0",
        realFinishTime: "0",
        contributors: [],
        contributorsLength: 0,
        idStr: "",
        auditDescription: "",
        stats: void 0,
        goalExtraInfo: "",
        mode: 0,
        auditInfo: void 0,
        challengeType: "",
        isUneditable: false
      };
    }
    exports2.LiveStreamGoal = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== "0") {
          writer.uint32(8).int64(message.id);
        }
        if (message.type !== 0) {
          writer.uint32(16).int32(message.type);
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        for (const v of message.subGoals) {
          exports2.LiveStreamGoal_LiveStreamSubGoal.encode(v, writer.uint32(34).fork()).join();
        }
        if (message.description !== "") {
          writer.uint32(42).string(message.description);
        }
        if (message.auditStatus !== 0) {
          writer.uint32(48).int32(message.auditStatus);
        }
        if (message.cycleType !== 0) {
          writer.uint32(56).int32(message.cycleType);
        }
        if (message.startTime !== "0") {
          writer.uint32(64).int64(message.startTime);
        }
        if (message.expireTime !== "0") {
          writer.uint32(72).int64(message.expireTime);
        }
        if (message.realFinishTime !== "0") {
          writer.uint32(80).int64(message.realFinishTime);
        }
        for (const v of message.contributors) {
          exports2.LiveStreamGoal_LiveStreamGoalContributor.encode(v, writer.uint32(90).fork()).join();
        }
        if (message.contributorsLength !== 0) {
          writer.uint32(96).int32(message.contributorsLength);
        }
        if (message.idStr !== "") {
          writer.uint32(106).string(message.idStr);
        }
        if (message.auditDescription !== "") {
          writer.uint32(114).string(message.auditDescription);
        }
        if (message.stats !== void 0) {
          exports2.LiveStreamGoal_GoalStats.encode(message.stats, writer.uint32(122).fork()).join();
        }
        if (message.goalExtraInfo !== "") {
          writer.uint32(130).string(message.goalExtraInfo);
        }
        if (message.mode !== 0) {
          writer.uint32(136).int32(message.mode);
        }
        if (message.auditInfo !== void 0) {
          exports2.LiveStreamGoal_AuditInfo.encode(message.auditInfo, writer.uint32(146).fork()).join();
        }
        if (message.challengeType !== "") {
          writer.uint32(162).string(message.challengeType);
        }
        if (message.isUneditable !== false) {
          writer.uint32(168).bool(message.isUneditable);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLiveStreamGoal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.status = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.subGoals.push(exports2.LiveStreamGoal_LiveStreamSubGoal.decode(reader, reader.uint32()));
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.description = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.auditStatus = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.cycleType = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.startTime = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.expireTime = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.realFinishTime = reader.int64().toString();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.contributors.push(exports2.LiveStreamGoal_LiveStreamGoalContributor.decode(reader, reader.uint32()));
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.contributorsLength = reader.int32();
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.idStr = reader.string();
              continue;
            }
            case 14: {
              if (tag !== 114) {
                break;
              }
              message.auditDescription = reader.string();
              continue;
            }
            case 15: {
              if (tag !== 122) {
                break;
              }
              message.stats = exports2.LiveStreamGoal_GoalStats.decode(reader, reader.uint32());
              continue;
            }
            case 16: {
              if (tag !== 130) {
                break;
              }
              message.goalExtraInfo = reader.string();
              continue;
            }
            case 17: {
              if (tag !== 136) {
                break;
              }
              message.mode = reader.int32();
              continue;
            }
            case 18: {
              if (tag !== 146) {
                break;
              }
              message.auditInfo = exports2.LiveStreamGoal_AuditInfo.decode(reader, reader.uint32());
              continue;
            }
            case 20: {
              if (tag !== 162) {
                break;
              }
              message.challengeType = reader.string();
              continue;
            }
            case 21: {
              if (tag !== 168) {
                break;
              }
              message.isUneditable = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLiveStreamGoal_AuditInfo() {
      return { violationId: "0", taskType: 0 };
    }
    exports2.LiveStreamGoal_AuditInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.violationId !== "0") {
          writer.uint32(8).int64(message.violationId);
        }
        if (message.taskType !== 0) {
          writer.uint32(16).int32(message.taskType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLiveStreamGoal_AuditInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.violationId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.taskType = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLiveStreamGoal_LiveStreamSubGoal() {
      return {
        type: 0,
        id: "0",
        progress: "0",
        target: "0",
        gift: void 0,
        idStr: "",
        pinInfo: void 0,
        source: 0,
        recommendedText: "",
        recommendedHeader: ""
      };
    }
    exports2.LiveStreamGoal_LiveStreamSubGoal = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.id !== "0") {
          writer.uint32(16).int64(message.id);
        }
        if (message.progress !== "0") {
          writer.uint32(24).int64(message.progress);
        }
        if (message.target !== "0") {
          writer.uint32(32).int64(message.target);
        }
        if (message.gift !== void 0) {
          exports2.LiveStreamGoal_LiveStreamSubGoalGift.encode(message.gift, writer.uint32(42).fork()).join();
        }
        if (message.idStr !== "") {
          writer.uint32(50).string(message.idStr);
        }
        if (message.pinInfo !== void 0) {
          exports2.LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo.encode(message.pinInfo, writer.uint32(58).fork()).join();
        }
        if (message.source !== 0) {
          writer.uint32(64).int32(message.source);
        }
        if (message.recommendedText !== "") {
          writer.uint32(74).string(message.recommendedText);
        }
        if (message.recommendedHeader !== "") {
          writer.uint32(82).string(message.recommendedHeader);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLiveStreamGoal_LiveStreamSubGoal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.progress = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.target = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.gift = exports2.LiveStreamGoal_LiveStreamSubGoalGift.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.idStr = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.pinInfo = exports2.LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.source = reader.int32();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.recommendedText = reader.string();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.recommendedHeader = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo() {
      return { pinStartTime: "0", pinEndTime: "0", pinReadyTime: "0" };
    }
    exports2.LiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.pinStartTime !== "0") {
          writer.uint32(8).int64(message.pinStartTime);
        }
        if (message.pinEndTime !== "0") {
          writer.uint32(16).int64(message.pinEndTime);
        }
        if (message.pinReadyTime !== "0") {
          writer.uint32(24).int64(message.pinReadyTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLiveStreamGoal_LiveStreamSubGoal_SubGoalPinInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.pinStartTime = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.pinEndTime = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.pinReadyTime = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLiveStreamGoal_LiveStreamSubGoalGift() {
      return { name: "", icon: void 0, diamondCount: "0", type: 0 };
    }
    exports2.LiveStreamGoal_LiveStreamSubGoalGift = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(18).fork()).join();
        }
        if (message.diamondCount !== "0") {
          writer.uint32(24).int64(message.diamondCount);
        }
        if (message.type !== 0) {
          writer.uint32(32).int32(message.type);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLiveStreamGoal_LiveStreamSubGoalGift();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.name = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.diamondCount = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLiveStreamGoal_LiveStreamGoalContributor() {
      return {
        userId: "0",
        avatar: void 0,
        displayId: "",
        score: "0",
        userIdStr: "",
        inRoom: false,
        isFriend: false,
        followByOwner: false,
        isFistContribute: false,
        subGoalContributions: []
      };
    }
    exports2.LiveStreamGoal_LiveStreamGoalContributor = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.avatar !== void 0) {
          exports2.Image.encode(message.avatar, writer.uint32(18).fork()).join();
        }
        if (message.displayId !== "") {
          writer.uint32(26).string(message.displayId);
        }
        if (message.score !== "0") {
          writer.uint32(32).int64(message.score);
        }
        if (message.userIdStr !== "") {
          writer.uint32(42).string(message.userIdStr);
        }
        if (message.inRoom !== false) {
          writer.uint32(48).bool(message.inRoom);
        }
        if (message.isFriend !== false) {
          writer.uint32(56).bool(message.isFriend);
        }
        if (message.followByOwner !== false) {
          writer.uint32(72).bool(message.followByOwner);
        }
        if (message.isFistContribute !== false) {
          writer.uint32(80).bool(message.isFistContribute);
        }
        for (const v of message.subGoalContributions) {
          exports2.LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution.encode(v, writer.uint32(90).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLiveStreamGoal_LiveStreamGoalContributor();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.avatar = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.displayId = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.score = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.userIdStr = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.inRoom = reader.bool();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.isFriend = reader.bool();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.followByOwner = reader.bool();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.isFistContribute = reader.bool();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.subGoalContributions.push(exports2.LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution() {
      return { id: "", contributionCount: "0" };
    }
    exports2.LiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== "") {
          writer.uint32(10).string(message.id);
        }
        if (message.contributionCount !== "0") {
          writer.uint32(16).int64(message.contributionCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLiveStreamGoal_LiveStreamGoalContributor_SubGoalContribution();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.id = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.contributionCount = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLiveStreamGoal_GoalStats() {
      return { totalCoins: "0", totalContributor: "0", comparison: void 0, totalNewFans: "0" };
    }
    exports2.LiveStreamGoal_GoalStats = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.totalCoins !== "0") {
          writer.uint32(8).int64(message.totalCoins);
        }
        if (message.totalContributor !== "0") {
          writer.uint32(16).int64(message.totalContributor);
        }
        if (message.comparison !== void 0) {
          exports2.LiveStreamGoal_GoalStats_GoalComparison.encode(message.comparison, writer.uint32(26).fork()).join();
        }
        if (message.totalNewFans !== "0") {
          writer.uint32(32).int64(message.totalNewFans);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLiveStreamGoal_GoalStats();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.totalCoins = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.totalContributor = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.comparison = exports2.LiveStreamGoal_GoalStats_GoalComparison.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.totalNewFans = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLiveStreamGoal_GoalStats_GoalComparison() {
      return { coinsIncr: "0", contributorIncr: "0" };
    }
    exports2.LiveStreamGoal_GoalStats_GoalComparison = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.coinsIncr !== "0") {
          writer.uint32(8).int64(message.coinsIncr);
        }
        if (message.contributorIncr !== "0") {
          writer.uint32(16).int64(message.contributorIncr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLiveStreamGoal_GoalStats_GoalComparison();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.coinsIncr = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.contributorIncr = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLiveStreamGoalIndicator() {
      return { key: "", op: 0 };
    }
    exports2.LiveStreamGoalIndicator = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.op !== 0) {
          writer.uint32(16).int32(message.op);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLiveStreamGoalIndicator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.op = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseRanking() {
      return { type: "", label: "", color: void 0, details: [] };
    }
    exports2.Ranking = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        if (message.label !== "") {
          writer.uint32(18).string(message.label);
        }
        if (message.color !== void 0) {
          exports2.TikTokColor.encode(message.color, writer.uint32(26).fork()).join();
        }
        for (const v of message.details) {
          exports2.ValueLabel.encode(v, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRanking();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.type = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.label = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.color = exports2.TikTokColor.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.details.push(exports2.ValueLabel.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseTikTokColor() {
      return { color: "", id: "0", data1: 0 };
    }
    exports2.TikTokColor = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.color !== "") {
          writer.uint32(10).string(message.color);
        }
        if (message.id !== "0") {
          writer.uint32(32).uint64(message.id);
        }
        if (message.data1 !== 0) {
          writer.uint32(48).uint32(message.data1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTikTokColor();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.color = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.id = reader.uint64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.data1 = reader.uint32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseValueLabel() {
      return { data: 0, label: "", label2: "", label3: "" };
    }
    exports2.ValueLabel = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.data !== 0) {
          writer.uint32(8).uint32(message.data);
        }
        if (message.label !== "") {
          writer.uint32(18).string(message.label);
        }
        if (message.label2 !== "") {
          writer.uint32(26).string(message.label2);
        }
        if (message.label3 !== "") {
          writer.uint32(90).string(message.label3);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseValueLabel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.data = reader.uint32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.label = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.label2 = reader.string();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.label3 = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseTimeStampContainer() {
      return { timestamp1: "0", timestamp2: "0", timestamp3: "0" };
    }
    exports2.TimeStampContainer = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.timestamp1 !== "0") {
          writer.uint32(8).uint64(message.timestamp1);
        }
        if (message.timestamp2 !== "0") {
          writer.uint32(16).uint64(message.timestamp2);
        }
        if (message.timestamp3 !== "0") {
          writer.uint32(24).uint64(message.timestamp3);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTimeStampContainer();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.timestamp1 = reader.uint64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.timestamp2 = reader.uint64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.timestamp3 = reader.uint64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePollStartContent() {
      return { StartTime: "0", EndTime: "0", OptionList: [], Title: "", Operator: void 0 };
    }
    exports2.PollStartContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.StartTime !== "0") {
          writer.uint32(8).int64(message.StartTime);
        }
        if (message.EndTime !== "0") {
          writer.uint32(16).int64(message.EndTime);
        }
        for (const v of message.OptionList) {
          exports2.PollOptionInfo.encode(v, writer.uint32(26).fork()).join();
        }
        if (message.Title !== "") {
          writer.uint32(34).string(message.Title);
        }
        if (message.Operator !== void 0) {
          exports2.User.encode(message.Operator, writer.uint32(42).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePollStartContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.StartTime = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.EndTime = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.OptionList.push(exports2.PollOptionInfo.decode(reader, reader.uint32()));
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.Title = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.Operator = exports2.User.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePollEndContent() {
      return { EndType: 0, OptionList: [], Operator: void 0 };
    }
    exports2.PollEndContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.EndType !== 0) {
          writer.uint32(8).int32(message.EndType);
        }
        for (const v of message.OptionList) {
          exports2.PollOptionInfo.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.Operator !== void 0) {
          exports2.User.encode(message.Operator, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePollEndContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.EndType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.OptionList.push(exports2.PollOptionInfo.decode(reader, reader.uint32()));
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.Operator = exports2.User.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePollOptionInfo() {
      return { Votes: 0, DisplayContent: "", OptionIdx: 0, VoteUserList: [] };
    }
    exports2.PollOptionInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.Votes !== 0) {
          writer.uint32(8).int32(message.Votes);
        }
        if (message.DisplayContent !== "") {
          writer.uint32(18).string(message.DisplayContent);
        }
        if (message.OptionIdx !== 0) {
          writer.uint32(24).int32(message.OptionIdx);
        }
        for (const v of message.VoteUserList) {
          exports2.VoteUser.encode(v, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePollOptionInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.Votes = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.DisplayContent = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.OptionIdx = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.VoteUserList.push(exports2.VoteUser.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseVoteUser() {
      return { UserId: "0", NickName: "", AvatarThumb: void 0 };
    }
    exports2.VoteUser = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.UserId !== "0") {
          writer.uint32(8).int64(message.UserId);
        }
        if (message.NickName !== "") {
          writer.uint32(18).string(message.NickName);
        }
        if (message.AvatarThumb !== void 0) {
          exports2.Image.encode(message.AvatarThumb, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseVoteUser();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.UserId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.NickName = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.AvatarThumb = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePollUpdateVotesContent() {
      return { OptionList: [] };
    }
    exports2.PollUpdateVotesContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.OptionList) {
          exports2.PollOptionInfo.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePollUpdateVotesContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.OptionList.push(exports2.PollOptionInfo.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUserFanTicket() {
      return { UserId: "0", FanTicket: "0", MatchTotalScore: "0", MatchRank: 0 };
    }
    exports2.UserFanTicket = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.UserId !== "0") {
          writer.uint32(8).int64(message.UserId);
        }
        if (message.FanTicket !== "0") {
          writer.uint32(16).int64(message.FanTicket);
        }
        if (message.MatchTotalScore !== "0") {
          writer.uint32(24).int64(message.MatchTotalScore);
        }
        if (message.MatchRank !== 0) {
          writer.uint32(32).int32(message.MatchRank);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUserFanTicket();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.UserId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.FanTicket = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.MatchTotalScore = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.MatchRank = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseFanTicketRoomNoticeContent() {
      return {
        UserFanTicketList: [],
        TotalLinkMicFanTicket: "0",
        MatchId: "0",
        EventTime: "0",
        FanTicketIconUrl: "",
        playId: "0",
        playScene: 0
      };
    }
    exports2.FanTicketRoomNoticeContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.UserFanTicketList) {
          exports2.UserFanTicket.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.TotalLinkMicFanTicket !== "0") {
          writer.uint32(16).int64(message.TotalLinkMicFanTicket);
        }
        if (message.MatchId !== "0") {
          writer.uint32(24).int64(message.MatchId);
        }
        if (message.EventTime !== "0") {
          writer.uint32(32).int64(message.EventTime);
        }
        if (message.FanTicketIconUrl !== "") {
          writer.uint32(42).string(message.FanTicketIconUrl);
        }
        if (message.playId !== "0") {
          writer.uint32(48).int64(message.playId);
        }
        if (message.playScene !== 0) {
          writer.uint32(56).int32(message.playScene);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFanTicketRoomNoticeContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.UserFanTicketList.push(exports2.UserFanTicket.decode(reader, reader.uint32()));
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.TotalLinkMicFanTicket = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.MatchId = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.EventTime = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.FanTicketIconUrl = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.playId = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.playScene = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerAcceptNoticeContent() {
      return { fromUserId: "0", fromRoomId: "0", toUserId: "0" };
    }
    exports2.LinkerAcceptNoticeContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.fromUserId !== "0") {
          writer.uint32(8).int64(message.fromUserId);
        }
        if (message.fromRoomId !== "0") {
          writer.uint32(16).int64(message.fromRoomId);
        }
        if (message.toUserId !== "0") {
          writer.uint32(24).int64(message.toUserId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerAcceptNoticeContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.fromUserId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.fromRoomId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.toUserId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerCancelContent() {
      return { fromUserId: "0", toUserId: "0", cancelType: "0", actionId: "0" };
    }
    exports2.LinkerCancelContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.fromUserId !== "0") {
          writer.uint32(8).int64(message.fromUserId);
        }
        if (message.toUserId !== "0") {
          writer.uint32(16).int64(message.toUserId);
        }
        if (message.cancelType !== "0") {
          writer.uint32(24).int64(message.cancelType);
        }
        if (message.actionId !== "0") {
          writer.uint32(32).int64(message.actionId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerCancelContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.fromUserId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.toUserId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.cancelType = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.actionId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseListUser() {
      return {
        user: void 0,
        linkmicId: "0",
        linkmicIdStr: "",
        linkStatus: 0,
        linkType: 0,
        userPosition: 0,
        silenceStatus: 0,
        modifyTime: "0",
        linkerId: "0",
        roleType: 0
      };
    }
    exports2.ListUser = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(10).fork()).join();
        }
        if (message.linkmicId !== "0") {
          writer.uint32(16).int64(message.linkmicId);
        }
        if (message.linkmicIdStr !== "") {
          writer.uint32(26).string(message.linkmicIdStr);
        }
        if (message.linkStatus !== 0) {
          writer.uint32(32).int32(message.linkStatus);
        }
        if (message.linkType !== 0) {
          writer.uint32(40).int32(message.linkType);
        }
        if (message.userPosition !== 0) {
          writer.uint32(48).int32(message.userPosition);
        }
        if (message.silenceStatus !== 0) {
          writer.uint32(56).int32(message.silenceStatus);
        }
        if (message.modifyTime !== "0") {
          writer.uint32(64).int64(message.modifyTime);
        }
        if (message.linkerId !== "0") {
          writer.uint32(72).int64(message.linkerId);
        }
        if (message.roleType !== 0) {
          writer.uint32(80).int32(message.roleType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListUser();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.linkmicId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.linkmicIdStr = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.linkStatus = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.linkType = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.userPosition = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.silenceStatus = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.modifyTime = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.linkerId = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.roleType = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerCloseContent() {
      return {};
    }
    exports2.LinkerCloseContent = {
      encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerCloseContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerCreateContent() {
      return { ownerId: "0", ownerRoomId: "0", linkType: "0" };
    }
    exports2.LinkerCreateContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.ownerId !== "0") {
          writer.uint32(8).int64(message.ownerId);
        }
        if (message.ownerRoomId !== "0") {
          writer.uint32(16).int64(message.ownerRoomId);
        }
        if (message.linkType !== "0") {
          writer.uint32(24).int64(message.linkType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerCreateContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.ownerId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.ownerRoomId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.linkType = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerEnterContent() {
      return { linkedUsersList: [], anchorMultiLiveEnum: 0, anchorSettingInfo: void 0 };
    }
    exports2.LinkerEnterContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.linkedUsersList) {
          exports2.ListUser.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.anchorMultiLiveEnum !== 0) {
          writer.uint32(16).int32(message.anchorMultiLiveEnum);
        }
        if (message.anchorSettingInfo !== void 0) {
          exports2.MultiLiveAnchorPanelSettings.encode(message.anchorSettingInfo, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerEnterContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.linkedUsersList.push(exports2.ListUser.decode(reader, reader.uint32()));
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.anchorMultiLiveEnum = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.anchorSettingInfo = exports2.MultiLiveAnchorPanelSettings.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent() {
      return {
        fromUserId: "0",
        fromRoomId: "0",
        toRtcExtInfo: "",
        rtcJoinChannel: false,
        vendor: "0",
        secFromUserId: "",
        toLinkmicIdStr: "",
        fromUser: void 0,
        requiredMicIdx: "0",
        rtcExtInfoMap: {},
        multiLiveLayoutEnable: 0,
        multiLiveSetting: void 0,
        fromLinkmicIdStr: "",
        fromTopHostInfo: void 0,
        actionId: "0",
        linkedUsers: [],
        dialogInfo: void 0,
        punishEventInfo: void 0,
        fromRoomAgeRestricted: 0,
        abTestSetting: [],
        linkerInviteMsgExtra: void 0
      };
    }
    exports2.LinkerInviteContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.fromUserId !== "0") {
          writer.uint32(8).int64(message.fromUserId);
        }
        if (message.fromRoomId !== "0") {
          writer.uint32(16).int64(message.fromRoomId);
        }
        if (message.toRtcExtInfo !== "") {
          writer.uint32(26).string(message.toRtcExtInfo);
        }
        if (message.rtcJoinChannel !== false) {
          writer.uint32(32).bool(message.rtcJoinChannel);
        }
        if (message.vendor !== "0") {
          writer.uint32(40).int64(message.vendor);
        }
        if (message.secFromUserId !== "") {
          writer.uint32(50).string(message.secFromUserId);
        }
        if (message.toLinkmicIdStr !== "") {
          writer.uint32(58).string(message.toLinkmicIdStr);
        }
        if (message.fromUser !== void 0) {
          exports2.User.encode(message.fromUser, writer.uint32(66).fork()).join();
        }
        if (message.requiredMicIdx !== "0") {
          writer.uint32(72).int64(message.requiredMicIdx);
        }
        Object.entries(message.rtcExtInfoMap).forEach(([key, value]) => {
          exports2.LinkerInviteContent_RtcExtInfoMapEntry.encode({ key, value }, writer.uint32(82).fork()).join();
        });
        if (message.multiLiveLayoutEnable !== 0) {
          writer.uint32(88).int32(message.multiLiveLayoutEnable);
        }
        if (message.multiLiveSetting !== void 0) {
          exports2.MultiLiveAnchorPanelSettings.encode(message.multiLiveSetting, writer.uint32(98).fork()).join();
        }
        if (message.fromLinkmicIdStr !== "") {
          writer.uint32(106).string(message.fromLinkmicIdStr);
        }
        if (message.fromTopHostInfo !== void 0) {
          exports2.LinkerInviteContent_InviteTopHostInfo.encode(message.fromTopHostInfo, writer.uint32(130).fork()).join();
        }
        if (message.actionId !== "0") {
          writer.uint32(136).int64(message.actionId);
        }
        for (const v of message.linkedUsers) {
          exports2.LinkerInviteContent_LinkmicUserInfo.encode(v, writer.uint32(146).fork()).join();
        }
        if (message.dialogInfo !== void 0) {
          exports2.LinkerInviteContent_PerceptionDialogInfo.encode(message.dialogInfo, writer.uint32(154).fork()).join();
        }
        if (message.punishEventInfo !== void 0) {
          exports2.PunishEventInfo.encode(message.punishEventInfo, writer.uint32(162).fork()).join();
        }
        if (message.fromRoomAgeRestricted !== 0) {
          writer.uint32(168).int32(message.fromRoomAgeRestricted);
        }
        for (const v of message.abTestSetting) {
          exports2.LinkerInviteContent_CohostABTestSetting.encode(v, writer.uint32(186).fork()).join();
        }
        if (message.linkerInviteMsgExtra !== void 0) {
          exports2.LinkerInviteContent_LinkerInviteMessageExtra.encode(message.linkerInviteMsgExtra, writer.uint32(810).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.fromUserId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.fromRoomId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.toRtcExtInfo = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.rtcJoinChannel = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.vendor = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.secFromUserId = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.toLinkmicIdStr = reader.string();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.fromUser = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.requiredMicIdx = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              const entry10 = exports2.LinkerInviteContent_RtcExtInfoMapEntry.decode(reader, reader.uint32());
              if (entry10.value !== void 0) {
                message.rtcExtInfoMap[entry10.key] = entry10.value;
              }
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.multiLiveLayoutEnable = reader.int32();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.multiLiveSetting = exports2.MultiLiveAnchorPanelSettings.decode(reader, reader.uint32());
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.fromLinkmicIdStr = reader.string();
              continue;
            }
            case 16: {
              if (tag !== 130) {
                break;
              }
              message.fromTopHostInfo = exports2.LinkerInviteContent_InviteTopHostInfo.decode(reader, reader.uint32());
              continue;
            }
            case 17: {
              if (tag !== 136) {
                break;
              }
              message.actionId = reader.int64().toString();
              continue;
            }
            case 18: {
              if (tag !== 146) {
                break;
              }
              message.linkedUsers.push(exports2.LinkerInviteContent_LinkmicUserInfo.decode(reader, reader.uint32()));
              continue;
            }
            case 19: {
              if (tag !== 154) {
                break;
              }
              message.dialogInfo = exports2.LinkerInviteContent_PerceptionDialogInfo.decode(reader, reader.uint32());
              continue;
            }
            case 20: {
              if (tag !== 162) {
                break;
              }
              message.punishEventInfo = exports2.PunishEventInfo.decode(reader, reader.uint32());
              continue;
            }
            case 21: {
              if (tag !== 168) {
                break;
              }
              message.fromRoomAgeRestricted = reader.int32();
              continue;
            }
            case 23: {
              if (tag !== 186) {
                break;
              }
              message.abTestSetting.push(exports2.LinkerInviteContent_CohostABTestSetting.decode(reader, reader.uint32()));
              continue;
            }
            case 101: {
              if (tag !== 810) {
                break;
              }
              message.linkerInviteMsgExtra = exports2.LinkerInviteContent_LinkerInviteMessageExtra.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_RtcExtInfoMapEntry() {
      return { key: "0", value: "" };
    }
    exports2.LinkerInviteContent_RtcExtInfoMapEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "0") {
          writer.uint32(8).int64(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_RtcExtInfoMapEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_InviteTopHostInfo() {
      return { rankType: "", topIndex: "0" };
    }
    exports2.LinkerInviteContent_InviteTopHostInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.rankType !== "") {
          writer.uint32(10).string(message.rankType);
        }
        if (message.topIndex !== "0") {
          writer.uint32(16).int64(message.topIndex);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_InviteTopHostInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.rankType = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.topIndex = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_LinkmicUserInfo() {
      return { userId: "0", linkmicIdStr: "", roomId: "0", linkedTime: "0" };
    }
    exports2.LinkerInviteContent_LinkmicUserInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.linkmicIdStr !== "") {
          writer.uint32(18).string(message.linkmicIdStr);
        }
        if (message.roomId !== "0") {
          writer.uint32(24).int64(message.roomId);
        }
        if (message.linkedTime !== "0") {
          writer.uint32(32).int64(message.linkedTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_LinkmicUserInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.linkmicIdStr = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.roomId = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.linkedTime = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_PerceptionDialogInfo() {
      return {
        iconType: 0,
        title: void 0,
        subTitle: void 0,
        adviceActionText: void 0,
        defaultActionText: void 0,
        violationDetailUrl: "",
        scene: 0,
        targetUserId: "0",
        targetRoomId: "0",
        countDownTime: "0",
        showFeedback: false,
        feedbackOptions: [],
        policyTip: "0",
        appealPopup: 0
      };
    }
    exports2.LinkerInviteContent_PerceptionDialogInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.iconType !== 0) {
          writer.uint32(8).int32(message.iconType);
        }
        if (message.title !== void 0) {
          exports2.Text.encode(message.title, writer.uint32(18).fork()).join();
        }
        if (message.subTitle !== void 0) {
          exports2.Text.encode(message.subTitle, writer.uint32(26).fork()).join();
        }
        if (message.adviceActionText !== void 0) {
          exports2.Text.encode(message.adviceActionText, writer.uint32(34).fork()).join();
        }
        if (message.defaultActionText !== void 0) {
          exports2.Text.encode(message.defaultActionText, writer.uint32(42).fork()).join();
        }
        if (message.violationDetailUrl !== "") {
          writer.uint32(50).string(message.violationDetailUrl);
        }
        if (message.scene !== 0) {
          writer.uint32(56).int32(message.scene);
        }
        if (message.targetUserId !== "0") {
          writer.uint32(64).int64(message.targetUserId);
        }
        if (message.targetRoomId !== "0") {
          writer.uint32(72).int64(message.targetRoomId);
        }
        if (message.countDownTime !== "0") {
          writer.uint32(80).int64(message.countDownTime);
        }
        if (message.showFeedback !== false) {
          writer.uint32(88).bool(message.showFeedback);
        }
        for (const v of message.feedbackOptions) {
          exports2.LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption.encode(v, writer.uint32(98).fork()).join();
        }
        if (message.policyTip !== "0") {
          writer.uint32(104).int64(message.policyTip);
        }
        if (message.appealPopup !== 0) {
          writer.uint32(112).int32(message.appealPopup);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_PerceptionDialogInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.iconType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.title = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.subTitle = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.adviceActionText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.defaultActionText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.violationDetailUrl = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.scene = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.targetUserId = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.targetRoomId = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.countDownTime = reader.int64().toString();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.showFeedback = reader.bool();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.feedbackOptions.push(exports2.LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption.decode(reader, reader.uint32()));
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.policyTip = reader.int64().toString();
              continue;
            }
            case 14: {
              if (tag !== 112) {
                break;
              }
              message.appealPopup = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption() {
      return { id: "0", contentKey: "" };
    }
    exports2.LinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== "0") {
          writer.uint32(8).int64(message.id);
        }
        if (message.contentKey !== "") {
          writer.uint32(18).string(message.contentKey);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_PerceptionDialogInfo_PerceptionFeedbackOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.contentKey = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_CohostABTestSetting() {
      return { key: "0", value: void 0 };
    }
    exports2.LinkerInviteContent_CohostABTestSetting = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "0") {
          writer.uint32(8).int64(message.key);
        }
        if (message.value !== void 0) {
          exports2.LinkerInviteContent_CohostABTestSetting_CohostABTestList.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_CohostABTestSetting();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = exports2.LinkerInviteContent_CohostABTestSetting_CohostABTestList.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList() {
      return { abTestList: [] };
    }
    exports2.LinkerInviteContent_CohostABTestSetting_CohostABTestList = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.abTestList) {
          exports2.LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.abTestList.push(exports2.LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest() {
      return { abTestType: 0, group: "0" };
    }
    exports2.LinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.abTestType !== 0) {
          writer.uint32(8).int32(message.abTestType);
        }
        if (message.group !== "0") {
          writer.uint32(16).int64(message.group);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_CohostABTestSetting_CohostABTestList_CohostABTest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.abTestType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.group = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_LinkerInviteMessageExtra() {
      return {
        matchType: 0,
        inviteType: 0,
        subType: 0,
        theme: "",
        duration: 0,
        layout: 0,
        tips: "",
        inviterRivalExtra: void 0,
        otherRivalExtra: [],
        topicInfo: void 0,
        algoRequestId: ""
      };
    }
    exports2.LinkerInviteContent_LinkerInviteMessageExtra = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.matchType !== 0) {
          writer.uint32(8).int32(message.matchType);
        }
        if (message.inviteType !== 0) {
          writer.uint32(16).int32(message.inviteType);
        }
        if (message.subType !== 0) {
          writer.uint32(24).int32(message.subType);
        }
        if (message.theme !== "") {
          writer.uint32(34).string(message.theme);
        }
        if (message.duration !== 0) {
          writer.uint32(40).int32(message.duration);
        }
        if (message.layout !== 0) {
          writer.uint32(48).int32(message.layout);
        }
        if (message.tips !== "") {
          writer.uint32(58).string(message.tips);
        }
        if (message.inviterRivalExtra !== void 0) {
          exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra.encode(message.inviterRivalExtra, writer.uint32(66).fork()).join();
        }
        for (const v of message.otherRivalExtra) {
          exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra.encode(v, writer.uint32(74).fork()).join();
        }
        if (message.topicInfo !== void 0) {
          exports2.CohostTopic.encode(message.topicInfo, writer.uint32(82).fork()).join();
        }
        if (message.algoRequestId !== "") {
          writer.uint32(90).string(message.algoRequestId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.matchType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.inviteType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.subType = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.theme = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.duration = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.layout = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.tips = reader.string();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.inviterRivalExtra = exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.otherRivalExtra.push(exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra.decode(reader, reader.uint32()));
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.topicInfo = exports2.CohostTopic.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.algoRequestId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra() {
      return {
        textType: 0,
        text: "",
        label: "",
        userCount: 0,
        avatarThumb: void 0,
        displayId: "",
        authenticationInfo: void 0,
        nickname: "",
        followStatus: "0",
        mHashtag: void 0,
        userId: "0",
        isBestTeammate: false,
        optPairInfo: void 0,
        followerCount: "0"
      };
    }
    exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.textType !== 0) {
          writer.uint32(8).int32(message.textType);
        }
        if (message.text !== "") {
          writer.uint32(18).string(message.text);
        }
        if (message.label !== "") {
          writer.uint32(26).string(message.label);
        }
        if (message.userCount !== 0) {
          writer.uint32(32).int32(message.userCount);
        }
        if (message.avatarThumb !== void 0) {
          exports2.Image.encode(message.avatarThumb, writer.uint32(42).fork()).join();
        }
        if (message.displayId !== "") {
          writer.uint32(50).string(message.displayId);
        }
        if (message.authenticationInfo !== void 0) {
          exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo.encode(message.authenticationInfo, writer.uint32(58).fork()).join();
        }
        if (message.nickname !== "") {
          writer.uint32(66).string(message.nickname);
        }
        if (message.followStatus !== "0") {
          writer.uint32(72).int64(message.followStatus);
        }
        if (message.mHashtag !== void 0) {
          exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag.encode(message.mHashtag, writer.uint32(82).fork()).join();
        }
        if (message.userId !== "0") {
          writer.uint32(96).int64(message.userId);
        }
        if (message.isBestTeammate !== false) {
          writer.uint32(104).bool(message.isBestTeammate);
        }
        if (message.optPairInfo !== void 0) {
          exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo.encode(message.optPairInfo, writer.uint32(114).fork()).join();
        }
        if (message.followerCount !== "0") {
          writer.uint32(120).int64(message.followerCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.textType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.text = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.label = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.userCount = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.avatarThumb = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.displayId = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.authenticationInfo = exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.nickname = reader.string();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.followStatus = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.mHashtag = exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.isBestTeammate = reader.bool();
              continue;
            }
            case 14: {
              if (tag !== 114) {
                break;
              }
              message.optPairInfo = exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo.decode(reader, reader.uint32());
              continue;
            }
            case 15: {
              if (tag !== 120) {
                break;
              }
              message.followerCount = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo() {
      return { customVerify: "", enterpriseVerifyReason: "", authenticationBadge: void 0 };
    }
    exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.customVerify !== "") {
          writer.uint32(10).string(message.customVerify);
        }
        if (message.enterpriseVerifyReason !== "") {
          writer.uint32(18).string(message.enterpriseVerifyReason);
        }
        if (message.authenticationBadge !== void 0) {
          exports2.Image.encode(message.authenticationBadge, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_AuthenticationInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.customVerify = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.enterpriseVerifyReason = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.authenticationBadge = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag() {
      return { id: "0", title: "", image: void 0, namespace: 0 };
    }
    exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== "0") {
          writer.uint32(8).int64(message.id);
        }
        if (message.title !== "") {
          writer.uint32(18).string(message.title);
        }
        if (message.image !== void 0) {
          exports2.Image.encode(message.image, writer.uint32(26).fork()).join();
        }
        if (message.namespace !== 0) {
          writer.uint32(32).int32(message.namespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_Hashtag();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.title = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.image = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.namespace = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo() {
      return { mappingId: "0", displayUserList: [], buttonNoticeType: 0, expectedTimeSec: "0", optPairType: "0" };
    }
    exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.mappingId !== "0") {
          writer.uint32(8).int64(message.mappingId);
        }
        for (const v of message.displayUserList) {
          exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.buttonNoticeType !== 0) {
          writer.uint32(24).int32(message.buttonNoticeType);
        }
        if (message.expectedTimeSec !== "0") {
          writer.uint32(32).int64(message.expectedTimeSec);
        }
        if (message.optPairType !== "0") {
          writer.uint32(40).int64(message.optPairType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.mappingId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.displayUserList.push(exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser.decode(reader, reader.uint32()));
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.buttonNoticeType = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.expectedTimeSec = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.optPairType = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser() {
      return { user: void 0, roomId: "0" };
    }
    exports2.LinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(10).fork()).join();
        }
        if (message.roomId !== "0") {
          writer.uint32(16).int64(message.roomId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerInviteContent_LinkerInviteMessageExtra_InviterRivalExtra_OptPairInfo_OptPairUser();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.roomId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseCohostTopic() {
      return { id: "0", titleKey: "", titleText: "", liked: false, totalHeat: "0", totalRivals: "0", rivalsAvatar: [] };
    }
    exports2.CohostTopic = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== "0") {
          writer.uint32(8).int64(message.id);
        }
        if (message.titleKey !== "") {
          writer.uint32(18).string(message.titleKey);
        }
        if (message.titleText !== "") {
          writer.uint32(26).string(message.titleText);
        }
        if (message.liked !== false) {
          writer.uint32(168).bool(message.liked);
        }
        if (message.totalHeat !== "0") {
          writer.uint32(176).int64(message.totalHeat);
        }
        if (message.totalRivals !== "0") {
          writer.uint32(184).int64(message.totalRivals);
        }
        for (const v of message.rivalsAvatar) {
          exports2.Image.encode(v, writer.uint32(194).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCohostTopic();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.titleKey = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.titleText = reader.string();
              continue;
            }
            case 21: {
              if (tag !== 168) {
                break;
              }
              message.liked = reader.bool();
              continue;
            }
            case 22: {
              if (tag !== 176) {
                break;
              }
              message.totalHeat = reader.int64().toString();
              continue;
            }
            case 23: {
              if (tag !== 184) {
                break;
              }
              message.totalRivals = reader.int64().toString();
              continue;
            }
            case 24: {
              if (tag !== 194) {
                break;
              }
              message.rivalsAvatar.push(exports2.Image.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerKickOutContent() {
      return { fromUserId: "0", kickoutReason: 0 };
    }
    exports2.LinkerKickOutContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.fromUserId !== "0") {
          writer.uint32(8).int64(message.fromUserId);
        }
        if (message.kickoutReason !== 0) {
          writer.uint32(16).int32(message.kickoutReason);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerKickOutContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.fromUserId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.kickoutReason = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerLeaveContent() {
      return { userId: "0", linkmicIdStr: "", sendLeaveUid: "0", leaveReason: "0" };
    }
    exports2.LinkerLeaveContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.linkmicIdStr !== "") {
          writer.uint32(18).string(message.linkmicIdStr);
        }
        if (message.sendLeaveUid !== "0") {
          writer.uint32(24).int64(message.sendLeaveUid);
        }
        if (message.leaveReason !== "0") {
          writer.uint32(32).int64(message.leaveReason);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerLeaveContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.linkmicIdStr = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.sendLeaveUid = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.leaveReason = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerLinkedListChangeContent() {
      return {};
    }
    exports2.LinkerLinkedListChangeContent = {
      encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerLinkedListChangeContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseCohostListChangeContent() {
      return {};
    }
    exports2.CohostListChangeContent = {
      encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCohostListChangeContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerListChangeContent() {
      return { linkedUsers: [], appliedUsers: [], connectingUsers: [] };
    }
    exports2.LinkerListChangeContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.linkedUsers) {
          exports2.ListUser.encode(v, writer.uint32(10).fork()).join();
        }
        for (const v of message.appliedUsers) {
          exports2.ListUser.encode(v, writer.uint32(18).fork()).join();
        }
        for (const v of message.connectingUsers) {
          exports2.ListUser.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerListChangeContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.linkedUsers.push(exports2.ListUser.decode(reader, reader.uint32()));
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.appliedUsers.push(exports2.ListUser.decode(reader, reader.uint32()));
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.connectingUsers.push(exports2.ListUser.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerMediaChangeContent() {
      return { op: 0, toUserId: "0", anchorId: "0", roomId: "0", changeScene: 0, operatorInfo: void 0 };
    }
    exports2.LinkerMediaChangeContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.op !== 0) {
          writer.uint32(8).int32(message.op);
        }
        if (message.toUserId !== "0") {
          writer.uint32(16).int64(message.toUserId);
        }
        if (message.anchorId !== "0") {
          writer.uint32(24).int64(message.anchorId);
        }
        if (message.roomId !== "0") {
          writer.uint32(32).int64(message.roomId);
        }
        if (message.changeScene !== 0) {
          writer.uint32(40).int32(message.changeScene);
        }
        if (message.operatorInfo !== void 0) {
          exports2.LinkerMediaChangeContent_LinkerMediaChangeOperator.encode(message.operatorInfo, writer.uint32(58).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerMediaChangeContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.op = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.toUserId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.anchorId = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.roomId = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.changeScene = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.operatorInfo = exports2.LinkerMediaChangeContent_LinkerMediaChangeOperator.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerMediaChangeContent_LinkerMediaChangeOperator() {
      return { userId: "0", operatorType: 0, nickName: "", displayId: "" };
    }
    exports2.LinkerMediaChangeContent_LinkerMediaChangeOperator = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.operatorType !== 0) {
          writer.uint32(16).int32(message.operatorType);
        }
        if (message.nickName !== "") {
          writer.uint32(26).string(message.nickName);
        }
        if (message.displayId !== "") {
          writer.uint32(34).string(message.displayId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerMediaChangeContent_LinkerMediaChangeOperator();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.operatorType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.nickName = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.displayId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerMicIdxUpdateContent() {
      return {};
    }
    exports2.LinkerMicIdxUpdateContent = {
      encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerMicIdxUpdateContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerMuteContent() {
      return { userId: "0", status: 0 };
    }
    exports2.LinkerMuteContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.status !== 0) {
          writer.uint32(16).int32(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerMuteContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.status = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerRandomMatchContent() {
      return { user: void 0, roomId: "0", inviteType: "0", matchId: "", innerChannelId: "0" };
    }
    exports2.LinkerRandomMatchContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(10).fork()).join();
        }
        if (message.roomId !== "0") {
          writer.uint32(16).int64(message.roomId);
        }
        if (message.inviteType !== "0") {
          writer.uint32(24).int64(message.inviteType);
        }
        if (message.matchId !== "") {
          writer.uint32(34).string(message.matchId);
        }
        if (message.innerChannelId !== "0") {
          writer.uint32(40).int64(message.innerChannelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerRandomMatchContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.roomId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.inviteType = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.matchId = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.innerChannelId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerReplyContent() {
      return {
        fromUserId: "0",
        fromRoomId: "0",
        fromUserLinkmicInfo: void 0,
        toUserId: "0",
        toUserLinkmicInfo: void 0,
        linkType: "0",
        replyStatus: "0",
        linkerSetting: void 0,
        fromUser: void 0,
        toUser: void 0
      };
    }
    exports2.LinkerReplyContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.fromUserId !== "0") {
          writer.uint32(8).int64(message.fromUserId);
        }
        if (message.fromRoomId !== "0") {
          writer.uint32(16).int64(message.fromRoomId);
        }
        if (message.fromUserLinkmicInfo !== void 0) {
          exports2.LinkerReplyContent_LinkmicInfo.encode(message.fromUserLinkmicInfo, writer.uint32(26).fork()).join();
        }
        if (message.toUserId !== "0") {
          writer.uint32(32).int64(message.toUserId);
        }
        if (message.toUserLinkmicInfo !== void 0) {
          exports2.LinkerReplyContent_LinkmicInfo.encode(message.toUserLinkmicInfo, writer.uint32(42).fork()).join();
        }
        if (message.linkType !== "0") {
          writer.uint32(48).int64(message.linkType);
        }
        if (message.replyStatus !== "0") {
          writer.uint32(56).int64(message.replyStatus);
        }
        if (message.linkerSetting !== void 0) {
          exports2.LinkerSetting.encode(message.linkerSetting, writer.uint32(66).fork()).join();
        }
        if (message.fromUser !== void 0) {
          exports2.User.encode(message.fromUser, writer.uint32(74).fork()).join();
        }
        if (message.toUser !== void 0) {
          exports2.User.encode(message.toUser, writer.uint32(82).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerReplyContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.fromUserId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.fromRoomId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.fromUserLinkmicInfo = exports2.LinkerReplyContent_LinkmicInfo.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.toUserId = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.toUserLinkmicInfo = exports2.LinkerReplyContent_LinkmicInfo.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.linkType = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.replyStatus = reader.int64().toString();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.linkerSetting = exports2.LinkerSetting.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.fromUser = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.toUser = exports2.User.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerReplyContent_LinkmicInfo() {
      return {
        accessKey: "",
        linkMicId: "0",
        joinable: false,
        confluenceType: 0,
        rtcExtInfo: "",
        rtcAppId: "",
        rtcAppSign: "",
        linkmicIdStr: "",
        vendor: "0"
      };
    }
    exports2.LinkerReplyContent_LinkmicInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.accessKey !== "") {
          writer.uint32(10).string(message.accessKey);
        }
        if (message.linkMicId !== "0") {
          writer.uint32(16).int64(message.linkMicId);
        }
        if (message.joinable !== false) {
          writer.uint32(24).bool(message.joinable);
        }
        if (message.confluenceType !== 0) {
          writer.uint32(32).int32(message.confluenceType);
        }
        if (message.rtcExtInfo !== "") {
          writer.uint32(42).string(message.rtcExtInfo);
        }
        if (message.rtcAppId !== "") {
          writer.uint32(50).string(message.rtcAppId);
        }
        if (message.rtcAppSign !== "") {
          writer.uint32(58).string(message.rtcAppSign);
        }
        if (message.linkmicIdStr !== "") {
          writer.uint32(66).string(message.linkmicIdStr);
        }
        if (message.vendor !== "0") {
          writer.uint32(72).int64(message.vendor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerReplyContent_LinkmicInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.accessKey = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.linkMicId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.joinable = reader.bool();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.confluenceType = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.rtcExtInfo = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.rtcAppId = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.rtcAppSign = reader.string();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.linkmicIdStr = reader.string();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.vendor = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerSetting() {
      return { MaxMemberLimit: "0", LinkType: "0", Scene: 0, OwnerUserId: "0", OwnerRoomId: "0", Vendor: "0" };
    }
    exports2.LinkerSetting = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.MaxMemberLimit !== "0") {
          writer.uint32(8).int64(message.MaxMemberLimit);
        }
        if (message.LinkType !== "0") {
          writer.uint32(16).int64(message.LinkType);
        }
        if (message.Scene !== 0) {
          writer.uint32(24).int32(message.Scene);
        }
        if (message.OwnerUserId !== "0") {
          writer.uint32(32).int64(message.OwnerUserId);
        }
        if (message.OwnerRoomId !== "0") {
          writer.uint32(40).int64(message.OwnerRoomId);
        }
        if (message.Vendor !== "0") {
          writer.uint32(48).int64(message.Vendor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerSetting();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.MaxMemberLimit = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.LinkType = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.Scene = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.OwnerUserId = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.OwnerRoomId = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.Vendor = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerSysKickOutContent() {
      return { userId: "0", linkmicIdStr: "" };
    }
    exports2.LinkerSysKickOutContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.linkmicIdStr !== "") {
          writer.uint32(18).string(message.linkmicIdStr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerSysKickOutContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.linkmicIdStr = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkmicUserToastContent() {
      return { userId: "0", roomId: "0", displayText: void 0, leavedUserId: "0" };
    }
    exports2.LinkmicUserToastContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.roomId !== "0") {
          writer.uint32(16).int64(message.roomId);
        }
        if (message.displayText !== void 0) {
          exports2.Text.encode(message.displayText, writer.uint32(26).fork()).join();
        }
        if (message.leavedUserId !== "0") {
          writer.uint32(32).int64(message.leavedUserId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkmicUserToastContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.roomId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.displayText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.leavedUserId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerUpdateUserContent() {
      return { fromUserId: "0", toUserId: "0", updateInfo: {} };
    }
    exports2.LinkerUpdateUserContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.fromUserId !== "0") {
          writer.uint32(8).int64(message.fromUserId);
        }
        if (message.toUserId !== "0") {
          writer.uint32(16).int64(message.toUserId);
        }
        Object.entries(message.updateInfo).forEach(([key, value]) => {
          exports2.LinkerUpdateUserContent_UpdateInfoEntry.encode({ key, value }, writer.uint32(26).fork()).join();
        });
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerUpdateUserContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.fromUserId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.toUserId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              const entry3 = exports2.LinkerUpdateUserContent_UpdateInfoEntry.decode(reader, reader.uint32());
              if (entry3.value !== void 0) {
                message.updateInfo[entry3.key] = entry3.value;
              }
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerUpdateUserContent_UpdateInfoEntry() {
      return { key: "", value: "" };
    }
    exports2.LinkerUpdateUserContent_UpdateInfoEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerUpdateUserContent_UpdateInfoEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerUpdateUserSettingContent() {
      return { multiLiveAnchorPanelSettings: void 0 };
    }
    exports2.LinkerUpdateUserSettingContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.multiLiveAnchorPanelSettings !== void 0) {
          exports2.MultiLiveAnchorPanelSettings.encode(message.multiLiveAnchorPanelSettings, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerUpdateUserSettingContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.multiLiveAnchorPanelSettings = exports2.MultiLiveAnchorPanelSettings.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkerWaitingListChangeContent() {
      return {};
    }
    exports2.LinkerWaitingListChangeContent = {
      encode(_, writer = new wire_1.BinaryWriter()) {
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkerWaitingListChangeContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseMultiLiveAnchorPanelSettings() {
      return {
        userId: "0",
        layout: "0",
        fixMicNum: "0",
        allowRequestFromUser: "0",
        allowRequestFromFollowerOnly: "0",
        applierSortSetting: 0,
        applierSortGiftScoreThreshold: "0",
        allowRequestFromFriends: 0,
        allowRequestFromFollowers: 0,
        allowRequestFromOthers: 0,
        enableShowMultiGuestLayout: 0
      };
    }
    exports2.MultiLiveAnchorPanelSettings = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.layout !== "0") {
          writer.uint32(16).int64(message.layout);
        }
        if (message.fixMicNum !== "0") {
          writer.uint32(24).int64(message.fixMicNum);
        }
        if (message.allowRequestFromUser !== "0") {
          writer.uint32(32).int64(message.allowRequestFromUser);
        }
        if (message.allowRequestFromFollowerOnly !== "0") {
          writer.uint32(40).int64(message.allowRequestFromFollowerOnly);
        }
        if (message.applierSortSetting !== 0) {
          writer.uint32(56).int32(message.applierSortSetting);
        }
        if (message.applierSortGiftScoreThreshold !== "0") {
          writer.uint32(64).int64(message.applierSortGiftScoreThreshold);
        }
        if (message.allowRequestFromFriends !== 0) {
          writer.uint32(72).int32(message.allowRequestFromFriends);
        }
        if (message.allowRequestFromFollowers !== 0) {
          writer.uint32(80).int32(message.allowRequestFromFollowers);
        }
        if (message.allowRequestFromOthers !== 0) {
          writer.uint32(88).int32(message.allowRequestFromOthers);
        }
        if (message.enableShowMultiGuestLayout !== 0) {
          writer.uint32(96).int32(message.enableShowMultiGuestLayout);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiLiveAnchorPanelSettings();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.layout = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.fixMicNum = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.allowRequestFromUser = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.allowRequestFromFollowerOnly = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.applierSortSetting = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.applierSortGiftScoreThreshold = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.allowRequestFromFriends = reader.int32();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.allowRequestFromFollowers = reader.int32();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.allowRequestFromOthers = reader.int32();
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.enableShowMultiGuestLayout = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePlayer() {
      return { roomId: "0", userId: "0" };
    }
    exports2.Player = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.roomId !== "0") {
          writer.uint32(8).int64(message.roomId);
        }
        if (message.userId !== "0") {
          writer.uint32(16).int64(message.userId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePlayer();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.roomId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseAllListUser() {
      return { linkedList: [], appliedList: [], invitedList: [], readyList: [] };
    }
    exports2.AllListUser = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.linkedList) {
          exports2.LinkLayerListUser.encode(v, writer.uint32(18).fork()).join();
        }
        for (const v of message.appliedList) {
          exports2.LinkLayerListUser.encode(v, writer.uint32(26).fork()).join();
        }
        for (const v of message.invitedList) {
          exports2.LinkLayerListUser.encode(v, writer.uint32(34).fork()).join();
        }
        for (const v of message.readyList) {
          exports2.LinkLayerListUser.encode(v, writer.uint32(42).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAllListUser();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.linkedList.push(exports2.LinkLayerListUser.decode(reader, reader.uint32()));
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.appliedList.push(exports2.LinkLayerListUser.decode(reader, reader.uint32()));
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.invitedList.push(exports2.LinkLayerListUser.decode(reader, reader.uint32()));
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.readyList.push(exports2.LinkLayerListUser.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkLayerListUser() {
      return { user: void 0, linkmicId: "0", pos: void 0, linkedTimeNano: "0", appVersion: "", magicNumber1: "0" };
    }
    exports2.LinkLayerListUser = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(10).fork()).join();
        }
        if (message.linkmicId !== "0") {
          writer.uint32(16).int64(message.linkmicId);
        }
        if (message.pos !== void 0) {
          exports2.Position.encode(message.pos, writer.uint32(26).fork()).join();
        }
        if (message.linkedTimeNano !== "0") {
          writer.uint32(32).int64(message.linkedTimeNano);
        }
        if (message.appVersion !== "") {
          writer.uint32(42).string(message.appVersion);
        }
        if (message.magicNumber1 !== "0") {
          writer.uint32(56).int64(message.magicNumber1);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkLayerListUser();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.linkmicId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.pos = exports2.Position.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.linkedTimeNano = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.appVersion = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.magicNumber1 = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePosition() {
      return { type: 0, link: void 0 };
    }
    exports2.Position = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.link !== void 0) {
          exports2.LinkPosition.encode(message.link, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePosition();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.link = exports2.LinkPosition.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLinkPosition() {
      return { position: 0, opt: 0 };
    }
    exports2.LinkPosition = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.position !== 0) {
          writer.uint32(8).int32(message.position);
        }
        if (message.opt !== 0) {
          writer.uint32(16).int32(message.opt);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLinkPosition();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.position = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.opt = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGroupPlayer() {
      return { channelId: "0", user: void 0 };
    }
    exports2.GroupPlayer = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.channelId !== "0") {
          writer.uint32(8).int64(message.channelId);
        }
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupPlayer();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.channelId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseDSLConfig() {
      return { sceneVersion: 0, layoutId: "" };
    }
    exports2.DSLConfig = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.sceneVersion !== 0) {
          writer.uint32(8).int32(message.sceneVersion);
        }
        if (message.layoutId !== "") {
          writer.uint32(18).string(message.layoutId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseDSLConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.sceneVersion = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.layoutId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGroupChannelAllUser() {
      return { groupChannelId: "0", userList: [], contentVersion: "0" };
    }
    exports2.GroupChannelAllUser = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.groupChannelId !== "0") {
          writer.uint32(8).int64(message.groupChannelId);
        }
        for (const v of message.userList) {
          exports2.GroupChannelUser.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.contentVersion !== "0") {
          writer.uint32(24).int64(message.contentVersion);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupChannelAllUser();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.groupChannelId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.userList.push(exports2.GroupChannelUser.decode(reader, reader.uint32()));
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.contentVersion = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGroupChannelUser() {
      return {
        channelId: "0",
        status: 0,
        type: 0,
        allUser: void 0,
        joinTime: "0",
        linkedTime: "0",
        ownerUser: void 0,
        groupLinkmicId: ""
      };
    }
    exports2.GroupChannelUser = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.channelId !== "0") {
          writer.uint32(8).int64(message.channelId);
        }
        if (message.status !== 0) {
          writer.uint32(16).int32(message.status);
        }
        if (message.type !== 0) {
          writer.uint32(24).int32(message.type);
        }
        if (message.allUser !== void 0) {
          exports2.AllListUser.encode(message.allUser, writer.uint32(34).fork()).join();
        }
        if (message.joinTime !== "0") {
          writer.uint32(40).int64(message.joinTime);
        }
        if (message.linkedTime !== "0") {
          writer.uint32(48).int64(message.linkedTime);
        }
        if (message.ownerUser !== void 0) {
          exports2.GroupPlayer.encode(message.ownerUser, writer.uint32(58).fork()).join();
        }
        if (message.groupLinkmicId !== "") {
          writer.uint32(66).string(message.groupLinkmicId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupChannelUser();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.channelId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.status = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.allUser = exports2.AllListUser.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.joinTime = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.linkedTime = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.ownerUser = exports2.GroupPlayer.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.groupLinkmicId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseRTCExtraInfo() {
      return {
        liveRtcEngineConfig: void 0,
        liveRtcVideoParamList: [],
        rtcBitrateMap: void 0,
        rtcFps: 0,
        rtcMixBase: void 0,
        byteRtcExtInfo: void 0,
        rtcInfoExtra: void 0,
        rtcBusinessId: "",
        rtcOther: void 0,
        interactClientType: 0
      };
    }
    exports2.RTCExtraInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.liveRtcEngineConfig !== void 0) {
          exports2.RTCExtraInfo_RTCEngineConfig.encode(message.liveRtcEngineConfig, writer.uint32(10).fork()).join();
        }
        for (const v of message.liveRtcVideoParamList) {
          exports2.RTCExtraInfo_RTCLiveVideoParam.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.rtcBitrateMap !== void 0) {
          exports2.RTCExtraInfo_RTCBitrateMap.encode(message.rtcBitrateMap, writer.uint32(26).fork()).join();
        }
        if (message.rtcFps !== 0) {
          writer.uint32(32).int32(message.rtcFps);
        }
        if (message.rtcMixBase !== void 0) {
          exports2.RTCExtraInfo_RTCMixBase.encode(message.rtcMixBase, writer.uint32(42).fork()).join();
        }
        if (message.byteRtcExtInfo !== void 0) {
          exports2.RTCExtraInfo_ByteRTCExtInfo.encode(message.byteRtcExtInfo, writer.uint32(50).fork()).join();
        }
        if (message.rtcInfoExtra !== void 0) {
          exports2.RTCExtraInfo_RTCInfoExtra.encode(message.rtcInfoExtra, writer.uint32(58).fork()).join();
        }
        if (message.rtcBusinessId !== "") {
          writer.uint32(66).string(message.rtcBusinessId);
        }
        if (message.rtcOther !== void 0) {
          exports2.RTCExtraInfo_RTCOther.encode(message.rtcOther, writer.uint32(74).fork()).join();
        }
        if (message.interactClientType !== 0) {
          writer.uint32(80).int32(message.interactClientType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRTCExtraInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.liveRtcEngineConfig = exports2.RTCExtraInfo_RTCEngineConfig.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.liveRtcVideoParamList.push(exports2.RTCExtraInfo_RTCLiveVideoParam.decode(reader, reader.uint32()));
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.rtcBitrateMap = exports2.RTCExtraInfo_RTCBitrateMap.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.rtcFps = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.rtcMixBase = exports2.RTCExtraInfo_RTCMixBase.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.byteRtcExtInfo = exports2.RTCExtraInfo_ByteRTCExtInfo.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.rtcInfoExtra = exports2.RTCExtraInfo_RTCInfoExtra.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.rtcBusinessId = reader.string();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.rtcOther = exports2.RTCExtraInfo_RTCOther.decode(reader, reader.uint32());
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.interactClientType = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseRTCExtraInfo_RTCMixBase() {
      return { bitrate: 0 };
    }
    exports2.RTCExtraInfo_RTCMixBase = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.bitrate !== 0) {
          writer.uint32(8).int32(message.bitrate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRTCExtraInfo_RTCMixBase();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.bitrate = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseRTCExtraInfo_ByteRTCExtInfo() {
      return { defaultSignaling: 0 };
    }
    exports2.RTCExtraInfo_ByteRTCExtInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.defaultSignaling !== 0) {
          writer.uint32(8).int32(message.defaultSignaling);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRTCExtraInfo_ByteRTCExtInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.defaultSignaling = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseRTCExtraInfo_RTCInfoExtra() {
      return { version: "" };
    }
    exports2.RTCExtraInfo_RTCInfoExtra = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRTCExtraInfo_RTCInfoExtra();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.version = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseRTCExtraInfo_RTCOther() {
      return { transCodingSecond: 0 };
    }
    exports2.RTCExtraInfo_RTCOther = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.transCodingSecond !== 0) {
          writer.uint32(8).int32(message.transCodingSecond);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRTCExtraInfo_RTCOther();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.transCodingSecond = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseRTCExtraInfo_RTCEngineConfig() {
      return { rtcAppId: "", rtcUserId: "", rtcToken: "", rtcChannelId: "0" };
    }
    exports2.RTCExtraInfo_RTCEngineConfig = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.rtcAppId !== "") {
          writer.uint32(10).string(message.rtcAppId);
        }
        if (message.rtcUserId !== "") {
          writer.uint32(18).string(message.rtcUserId);
        }
        if (message.rtcToken !== "") {
          writer.uint32(26).string(message.rtcToken);
        }
        if (message.rtcChannelId !== "0") {
          writer.uint32(32).int64(message.rtcChannelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRTCExtraInfo_RTCEngineConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.rtcAppId = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.rtcUserId = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.rtcToken = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.rtcChannelId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseRTCExtraInfo_RTCLiveVideoParam() {
      return { strategyId: 0, params: void 0 };
    }
    exports2.RTCExtraInfo_RTCLiveVideoParam = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.strategyId !== 0) {
          writer.uint32(8).int32(message.strategyId);
        }
        if (message.params !== void 0) {
          exports2.RTCExtraInfo_RTCVideoParam.encode(message.params, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRTCExtraInfo_RTCLiveVideoParam();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.strategyId = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.params = exports2.RTCExtraInfo_RTCVideoParam.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseRTCExtraInfo_RTCVideoParam() {
      return { width: 0, height: 0, fps: 0, bitrateKbps: 0 };
    }
    exports2.RTCExtraInfo_RTCVideoParam = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.width !== 0) {
          writer.uint32(8).int32(message.width);
        }
        if (message.height !== 0) {
          writer.uint32(16).int32(message.height);
        }
        if (message.fps !== 0) {
          writer.uint32(24).int32(message.fps);
        }
        if (message.bitrateKbps !== 0) {
          writer.uint32(32).int32(message.bitrateKbps);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRTCExtraInfo_RTCVideoParam();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.width = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.height = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.fps = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.bitrateKbps = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseRTCExtraInfo_RTCBitrateMap() {
      return { xx1: 0, xx2: 0, xx3: 0, xx4: 0 };
    }
    exports2.RTCExtraInfo_RTCBitrateMap = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.xx1 !== 0) {
          writer.uint32(8).int32(message.xx1);
        }
        if (message.xx2 !== 0) {
          writer.uint32(16).int32(message.xx2);
        }
        if (message.xx3 !== 0) {
          writer.uint32(24).int32(message.xx3);
        }
        if (message.xx4 !== 0) {
          writer.uint32(32).int32(message.xx4);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRTCExtraInfo_RTCBitrateMap();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.xx1 = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.xx2 = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.xx3 = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.xx4 = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseCreateChannelContent() {
      return { owner: void 0, ownerLinkMicId: "" };
    }
    exports2.CreateChannelContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.owner !== void 0) {
          exports2.Player.encode(message.owner, writer.uint32(10).fork()).join();
        }
        if (message.ownerLinkMicId !== "") {
          writer.uint32(18).string(message.ownerLinkMicId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCreateChannelContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.owner = exports2.Player.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.ownerLinkMicId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseListChangeContent() {
      return { listChangeType: 0, userList: void 0, linkedUserUiPositions: [], contentPos: [] };
    }
    exports2.ListChangeContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.listChangeType !== 0) {
          writer.uint32(8).int32(message.listChangeType);
        }
        if (message.userList !== void 0) {
          exports2.AllListUser.encode(message.userList, writer.uint32(18).fork()).join();
        }
        for (const v of message.linkedUserUiPositions) {
          writer.uint32(26).string(v);
        }
        for (const v of message.contentPos) {
          exports2.ContentPosition.encode(v, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseListChangeContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.listChangeType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.userList = exports2.AllListUser.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.linkedUserUiPositions.push(reader.string());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.contentPos.push(exports2.ContentPosition.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseContentPosition() {
      return { contentID: "", contentType: 0, pos: void 0, contentLinkmicID: "", startTimeNano: "0" };
    }
    exports2.ContentPosition = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.contentID !== "") {
          writer.uint32(10).string(message.contentID);
        }
        if (message.contentType !== 0) {
          writer.uint32(16).int32(message.contentType);
        }
        if (message.pos !== void 0) {
          exports2.MicPositionData.encode(message.pos, writer.uint32(26).fork()).join();
        }
        if (message.contentLinkmicID !== "") {
          writer.uint32(34).string(message.contentLinkmicID);
        }
        if (message.startTimeNano !== "0") {
          writer.uint32(40).int64(message.startTimeNano);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseContentPosition();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.contentID = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.contentType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.pos = exports2.MicPositionData.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.contentLinkmicID = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.startTimeNano = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseMicPositionData() {
      return { type: 0, linkPosition: void 0 };
    }
    exports2.MicPositionData = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.linkPosition !== void 0) {
          exports2.LinkPosition.encode(message.linkPosition, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMicPositionData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.linkPosition = exports2.LinkPosition.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseMultiLiveContent() {
      return {
        applyBizContent: void 0,
        inviteBizContent: void 0,
        replyBizContent: void 0,
        permitBizContent: void 0,
        joinDirectBizContent: void 0,
        kickOutBizContent: void 0
      };
    }
    exports2.MultiLiveContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.applyBizContent !== void 0) {
          exports2.MultiLiveContent_ApplyBizContent.encode(message.applyBizContent, writer.uint32(10).fork()).join();
        }
        if (message.inviteBizContent !== void 0) {
          exports2.MultiLiveContent_InviteBizContent.encode(message.inviteBizContent, writer.uint32(18).fork()).join();
        }
        if (message.replyBizContent !== void 0) {
          exports2.MultiLiveContent_ReplyBizContent.encode(message.replyBizContent, writer.uint32(26).fork()).join();
        }
        if (message.permitBizContent !== void 0) {
          exports2.MultiLiveContent_PermitBizContent.encode(message.permitBizContent, writer.uint32(34).fork()).join();
        }
        if (message.joinDirectBizContent !== void 0) {
          exports2.MultiLiveContent_JoinDirectBizContent.encode(message.joinDirectBizContent, writer.uint32(42).fork()).join();
        }
        if (message.kickOutBizContent !== void 0) {
          exports2.MultiLiveContent_KickOutBizContent.encode(message.kickOutBizContent, writer.uint32(50).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiLiveContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.applyBizContent = exports2.MultiLiveContent_ApplyBizContent.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.inviteBizContent = exports2.MultiLiveContent_InviteBizContent.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.replyBizContent = exports2.MultiLiveContent_ReplyBizContent.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.permitBizContent = exports2.MultiLiveContent_PermitBizContent.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.joinDirectBizContent = exports2.MultiLiveContent_JoinDirectBizContent.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.kickOutBizContent = exports2.MultiLiveContent_KickOutBizContent.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseMultiLiveContent_ApplyBizContent() {
      return { user: void 0 };
    }
    exports2.MultiLiveContent_ApplyBizContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiLiveContent_ApplyBizContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseMultiLiveContent_JoinDirectBizContent() {
      return { replyImMsgId: "0", outsideRoomInviteSource: 0 };
    }
    exports2.MultiLiveContent_JoinDirectBizContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.replyImMsgId !== "0") {
          writer.uint32(8).int64(message.replyImMsgId);
        }
        if (message.outsideRoomInviteSource !== 0) {
          writer.uint32(16).int32(message.outsideRoomInviteSource);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiLiveContent_JoinDirectBizContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.replyImMsgId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.outsideRoomInviteSource = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseMultiLiveContent_InviteBizContent() {
      return {
        anchorSettingInfo: void 0,
        inviteSource: 0,
        operatorUserInfo: void 0,
        operatorLinkAdminType: 0,
        inviteeUserInfo: void 0,
        shareRevenueSetting: 0
      };
    }
    exports2.MultiLiveContent_InviteBizContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.anchorSettingInfo !== void 0) {
          exports2.MultiLiveAnchorPanelSettings.encode(message.anchorSettingInfo, writer.uint32(10).fork()).join();
        }
        if (message.inviteSource !== 0) {
          writer.uint32(16).int32(message.inviteSource);
        }
        if (message.operatorUserInfo !== void 0) {
          exports2.User.encode(message.operatorUserInfo, writer.uint32(26).fork()).join();
        }
        if (message.operatorLinkAdminType !== 0) {
          writer.uint32(32).int32(message.operatorLinkAdminType);
        }
        if (message.inviteeUserInfo !== void 0) {
          exports2.User.encode(message.inviteeUserInfo, writer.uint32(42).fork()).join();
        }
        if (message.shareRevenueSetting !== 0) {
          writer.uint32(48).int32(message.shareRevenueSetting);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiLiveContent_InviteBizContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.anchorSettingInfo = exports2.MultiLiveAnchorPanelSettings.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.inviteSource = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.operatorUserInfo = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.operatorLinkAdminType = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.inviteeUserInfo = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.shareRevenueSetting = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseMultiLiveContent_ReplyBizContent() {
      return { linkType: 0, isTurnOffInvitation: 0, replyUserInfo: void 0 };
    }
    exports2.MultiLiveContent_ReplyBizContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.linkType !== 0) {
          writer.uint32(8).int32(message.linkType);
        }
        if (message.isTurnOffInvitation !== 0) {
          writer.uint32(16).int32(message.isTurnOffInvitation);
        }
        if (message.replyUserInfo !== void 0) {
          exports2.User.encode(message.replyUserInfo, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiLiveContent_ReplyBizContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.linkType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.isTurnOffInvitation = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.replyUserInfo = exports2.User.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseMultiLiveContent_PermitBizContent() {
      return {
        anchorSettingInfo: void 0,
        expireTimestamp: "0",
        operatorUserInfo: void 0,
        operatorLinkAdminType: 0,
        linkUserType: 0
      };
    }
    exports2.MultiLiveContent_PermitBizContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.anchorSettingInfo !== void 0) {
          exports2.MultiLiveAnchorPanelSettings.encode(message.anchorSettingInfo, writer.uint32(10).fork()).join();
        }
        if (message.expireTimestamp !== "0") {
          writer.uint32(16).int64(message.expireTimestamp);
        }
        if (message.operatorUserInfo !== void 0) {
          exports2.User.encode(message.operatorUserInfo, writer.uint32(26).fork()).join();
        }
        if (message.operatorLinkAdminType !== 0) {
          writer.uint32(32).int32(message.operatorLinkAdminType);
        }
        if (message.linkUserType !== 0) {
          writer.uint32(40).int32(message.linkUserType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiLiveContent_PermitBizContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.anchorSettingInfo = exports2.MultiLiveAnchorPanelSettings.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.expireTimestamp = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.operatorUserInfo = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.operatorLinkAdminType = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.linkUserType = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseMultiLiveContent_KickOutBizContent() {
      return { operatorUserInfo: void 0, operatorLinkAdminType: 0, kickPlayerUserInfo: void 0 };
    }
    exports2.MultiLiveContent_KickOutBizContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.operatorUserInfo !== void 0) {
          exports2.User.encode(message.operatorUserInfo, writer.uint32(10).fork()).join();
        }
        if (message.operatorLinkAdminType !== 0) {
          writer.uint32(16).int32(message.operatorLinkAdminType);
        }
        if (message.kickPlayerUserInfo !== void 0) {
          exports2.User.encode(message.kickPlayerUserInfo, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMultiLiveContent_KickOutBizContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.operatorUserInfo = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.operatorLinkAdminType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.kickPlayerUserInfo = exports2.User.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseInviteContent() {
      return {
        invitor: void 0,
        inviteeRtcExtInfo: void 0,
        invitorLinkMicId: "",
        inviteeLinkMicId: "",
        isOwner: false,
        pos: void 0,
        dsl: void 0,
        invitee: void 0,
        operator: void 0
      };
    }
    exports2.InviteContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.invitor !== void 0) {
          exports2.Player.encode(message.invitor, writer.uint32(10).fork()).join();
        }
        if (message.inviteeRtcExtInfo !== void 0) {
          exports2.RTCExtraInfo.encode(message.inviteeRtcExtInfo, writer.uint32(18).fork()).join();
        }
        if (message.invitorLinkMicId !== "") {
          writer.uint32(26).string(message.invitorLinkMicId);
        }
        if (message.inviteeLinkMicId !== "") {
          writer.uint32(34).string(message.inviteeLinkMicId);
        }
        if (message.isOwner !== false) {
          writer.uint32(40).bool(message.isOwner);
        }
        if (message.pos !== void 0) {
          exports2.Position.encode(message.pos, writer.uint32(50).fork()).join();
        }
        if (message.dsl !== void 0) {
          exports2.DSLConfig.encode(message.dsl, writer.uint32(58).fork()).join();
        }
        if (message.invitee !== void 0) {
          exports2.User.encode(message.invitee, writer.uint32(66).fork()).join();
        }
        if (message.operator !== void 0) {
          exports2.User.encode(message.operator, writer.uint32(74).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseInviteContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.invitor = exports2.Player.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.inviteeRtcExtInfo = exports2.RTCExtraInfo.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.invitorLinkMicId = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.inviteeLinkMicId = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.isOwner = reader.bool();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.pos = exports2.Position.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.dsl = exports2.DSLConfig.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.invitee = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.operator = exports2.User.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseApplyContent() {
      return { applier: void 0, applierLinkMicId: "" };
    }
    exports2.ApplyContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.applier !== void 0) {
          exports2.Player.encode(message.applier, writer.uint32(10).fork()).join();
        }
        if (message.applierLinkMicId !== "") {
          writer.uint32(18).string(message.applierLinkMicId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseApplyContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.applier = exports2.Player.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.applierLinkMicId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePermitApplyContent() {
      return {
        permiter: void 0,
        permiterLinkMicId: "",
        applierPos: void 0,
        replyStatus: 0,
        dsl: void 0,
        applier: void 0,
        operator: void 0,
        applierLinkMicId: ""
      };
    }
    exports2.PermitApplyContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.permiter !== void 0) {
          exports2.Player.encode(message.permiter, writer.uint32(10).fork()).join();
        }
        if (message.permiterLinkMicId !== "") {
          writer.uint32(18).string(message.permiterLinkMicId);
        }
        if (message.applierPos !== void 0) {
          exports2.Position.encode(message.applierPos, writer.uint32(26).fork()).join();
        }
        if (message.replyStatus !== 0) {
          writer.uint32(32).int32(message.replyStatus);
        }
        if (message.dsl !== void 0) {
          exports2.DSLConfig.encode(message.dsl, writer.uint32(42).fork()).join();
        }
        if (message.applier !== void 0) {
          exports2.User.encode(message.applier, writer.uint32(50).fork()).join();
        }
        if (message.operator !== void 0) {
          exports2.User.encode(message.operator, writer.uint32(58).fork()).join();
        }
        if (message.applierLinkMicId !== "") {
          writer.uint32(66).string(message.applierLinkMicId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePermitApplyContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.permiter = exports2.Player.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.permiterLinkMicId = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.applierPos = exports2.Position.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.replyStatus = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.dsl = exports2.DSLConfig.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.applier = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.operator = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.applierLinkMicId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseReplyInviteContent() {
      return {
        invitee: void 0,
        replyStatus: 0,
        inviteeLinkMicId: "",
        inviteePos: void 0,
        inviteOperatorUser: void 0,
        linkedUserUiPositions: [],
        uiPos: []
      };
    }
    exports2.ReplyInviteContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.invitee !== void 0) {
          exports2.Player.encode(message.invitee, writer.uint32(10).fork()).join();
        }
        if (message.replyStatus !== 0) {
          writer.uint32(16).int32(message.replyStatus);
        }
        if (message.inviteeLinkMicId !== "") {
          writer.uint32(26).string(message.inviteeLinkMicId);
        }
        if (message.inviteePos !== void 0) {
          exports2.Position.encode(message.inviteePos, writer.uint32(34).fork()).join();
        }
        if (message.inviteOperatorUser !== void 0) {
          exports2.Player.encode(message.inviteOperatorUser, writer.uint32(42).fork()).join();
        }
        for (const v of message.linkedUserUiPositions) {
          writer.uint32(50).string(v);
        }
        for (const v of message.uiPos) {
          exports2.PosIdentity.encode(v, writer.uint32(58).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseReplyInviteContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.invitee = exports2.Player.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.replyStatus = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.inviteeLinkMicId = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.inviteePos = exports2.Position.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.inviteOperatorUser = exports2.Player.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.linkedUserUiPositions.push(reader.string());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.uiPos.push(exports2.PosIdentity.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseKickOutContent() {
      return { offliner: void 0, kickoutReason: 0, linkedUserUiPositions: [], uiPos: [] };
    }
    exports2.KickOutContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.offliner !== void 0) {
          exports2.Player.encode(message.offliner, writer.uint32(10).fork()).join();
        }
        if (message.kickoutReason !== 0) {
          writer.uint32(16).int32(message.kickoutReason);
        }
        for (const v of message.linkedUserUiPositions) {
          writer.uint32(26).string(v);
        }
        for (const v of message.uiPos) {
          exports2.PosIdentity.encode(v, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseKickOutContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.offliner = exports2.Player.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.kickoutReason = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.linkedUserUiPositions.push(reader.string());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.uiPos.push(exports2.PosIdentity.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePosIdentity() {
      return { type: 0, value: "" };
    }
    exports2.PosIdentity = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePosIdentity();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseCancelApplyContent() {
      return { applier: void 0, applierLinkMicId: "" };
    }
    exports2.CancelApplyContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.applier !== void 0) {
          exports2.Player.encode(message.applier, writer.uint32(10).fork()).join();
        }
        if (message.applierLinkMicId !== "") {
          writer.uint32(18).string(message.applierLinkMicId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCancelApplyContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.applier = exports2.Player.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.applierLinkMicId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseCancelInviteContent() {
      return { invitor: void 0, invitorLinkMicId: "", inviteeLinkMicId: "", inviteSeqId: "0", invitee: void 0 };
    }
    exports2.CancelInviteContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.invitor !== void 0) {
          exports2.Player.encode(message.invitor, writer.uint32(10).fork()).join();
        }
        if (message.invitorLinkMicId !== "") {
          writer.uint32(18).string(message.invitorLinkMicId);
        }
        if (message.inviteeLinkMicId !== "") {
          writer.uint32(26).string(message.inviteeLinkMicId);
        }
        if (message.inviteSeqId !== "0") {
          writer.uint32(32).int64(message.inviteSeqId);
        }
        if (message.invitee !== void 0) {
          exports2.Player.encode(message.invitee, writer.uint32(42).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCancelInviteContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.invitor = exports2.Player.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.invitorLinkMicId = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.inviteeLinkMicId = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.inviteSeqId = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.invitee = exports2.Player.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLeaveContent() {
      return { leaver: void 0, leaveReason: "0", linkedUserUiPositions: [], uiPos: [] };
    }
    exports2.LeaveContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.leaver !== void 0) {
          exports2.Player.encode(message.leaver, writer.uint32(10).fork()).join();
        }
        if (message.leaveReason !== "0") {
          writer.uint32(16).int64(message.leaveReason);
        }
        for (const v of message.linkedUserUiPositions) {
          writer.uint32(26).string(v);
        }
        for (const v of message.uiPos) {
          exports2.PosIdentity.encode(v, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLeaveContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.leaver = exports2.Player.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.leaveReason = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.linkedUserUiPositions.push(reader.string());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.uiPos.push(exports2.PosIdentity.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseFinishChannelContent() {
      return { owner: void 0, finishReason: "0" };
    }
    exports2.FinishChannelContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.owner !== void 0) {
          exports2.Player.encode(message.owner, writer.uint32(10).fork()).join();
        }
        if (message.finishReason !== "0") {
          writer.uint32(16).int64(message.finishReason);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFinishChannelContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.owner = exports2.Player.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.finishReason = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseJoinDirectContent() {
      return { joiner: void 0, allUsers: void 0 };
    }
    exports2.JoinDirectContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.joiner !== void 0) {
          exports2.LinkLayerListUser.encode(message.joiner, writer.uint32(10).fork()).join();
        }
        if (message.allUsers !== void 0) {
          exports2.AllListUser.encode(message.allUsers, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseJoinDirectContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.joiner = exports2.LinkLayerListUser.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.allUsers = exports2.AllListUser.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLeaveJoinGroupContent() {
      return { operator: void 0, groupChannelId: "0", leaveSource: "", linkedUserUiPositions: [] };
    }
    exports2.LeaveJoinGroupContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.operator !== void 0) {
          exports2.GroupPlayer.encode(message.operator, writer.uint32(10).fork()).join();
        }
        if (message.groupChannelId !== "0") {
          writer.uint32(16).int64(message.groupChannelId);
        }
        if (message.leaveSource !== "") {
          writer.uint32(26).string(message.leaveSource);
        }
        for (const v of message.linkedUserUiPositions) {
          writer.uint32(34).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLeaveJoinGroupContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.operator = exports2.GroupPlayer.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.groupChannelId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.leaveSource = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.linkedUserUiPositions.push(reader.string());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePermitJoinGroupContent() {
      return {
        approver: void 0,
        agreeStatus: 0,
        type: 0,
        groupExtInfoList: [],
        groupUser: void 0,
        migrationDetails: void 0,
        linkedUserUiPositions: []
      };
    }
    exports2.PermitJoinGroupContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.approver !== void 0) {
          exports2.GroupPlayer.encode(message.approver, writer.uint32(10).fork()).join();
        }
        if (message.agreeStatus !== 0) {
          writer.uint32(16).int32(message.agreeStatus);
        }
        if (message.type !== 0) {
          writer.uint32(24).int32(message.type);
        }
        for (const v of message.groupExtInfoList) {
          exports2.RTCExtraInfo.encode(v, writer.uint32(34).fork()).join();
        }
        if (message.groupUser !== void 0) {
          exports2.GroupChannelAllUser.encode(message.groupUser, writer.uint32(42).fork()).join();
        }
        if (message.migrationDetails !== void 0) {
          exports2.MigrationDetails.encode(message.migrationDetails, writer.uint32(50).fork()).join();
        }
        for (const v of message.linkedUserUiPositions) {
          writer.uint32(58).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePermitJoinGroupContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.approver = exports2.GroupPlayer.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.agreeStatus = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.groupExtInfoList.push(exports2.RTCExtraInfo.decode(reader, reader.uint32()));
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.groupUser = exports2.GroupChannelAllUser.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.migrationDetails = exports2.MigrationDetails.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.linkedUserUiPositions.push(reader.string());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseMigrationDetails() {
      return { isMigrate: false, sourceGroupChannelId: "0", targetGroupChannelId: "0" };
    }
    exports2.MigrationDetails = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.isMigrate !== false) {
          writer.uint32(8).bool(message.isMigrate);
        }
        if (message.sourceGroupChannelId !== "0") {
          writer.uint32(16).int64(message.sourceGroupChannelId);
        }
        if (message.targetGroupChannelId !== "0") {
          writer.uint32(24).int64(message.targetGroupChannelId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMigrationDetails();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.isMigrate = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.sourceGroupChannelId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.targetGroupChannelId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseCancelJoinGroupContent() {
      return { leaverList: [], operator: void 0, type: 0, groupUser: void 0 };
    }
    exports2.CancelJoinGroupContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.leaverList) {
          exports2.GroupPlayer.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.operator !== void 0) {
          exports2.GroupPlayer.encode(message.operator, writer.uint32(18).fork()).join();
        }
        if (message.type !== 0) {
          writer.uint32(24).int32(message.type);
        }
        if (message.groupUser !== void 0) {
          exports2.GroupChannelAllUser.encode(message.groupUser, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseCancelJoinGroupContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.leaverList.push(exports2.GroupPlayer.decode(reader, reader.uint32()));
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.operator = exports2.GroupPlayer.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.groupUser = exports2.GroupChannelAllUser.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseP2PGroupChangeContent() {
      return { groupExtInfoList: [], groupUser: void 0, migrationDetails: void 0, contentPos: [] };
    }
    exports2.P2PGroupChangeContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.groupExtInfoList) {
          exports2.RTCExtraInfo.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.groupUser !== void 0) {
          exports2.GroupChannelAllUser.encode(message.groupUser, writer.uint32(18).fork()).join();
        }
        if (message.migrationDetails !== void 0) {
          exports2.MigrationDetails.encode(message.migrationDetails, writer.uint32(26).fork()).join();
        }
        for (const v of message.contentPos) {
          exports2.ContentPosition.encode(v, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseP2PGroupChangeContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.groupExtInfoList.push(exports2.RTCExtraInfo.decode(reader, reader.uint32()));
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.groupUser = exports2.GroupChannelAllUser.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.migrationDetails = exports2.MigrationDetails.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.contentPos.push(exports2.ContentPosition.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGroupChangeContent() {
      return { groupUser: void 0, linkedUserUiPositions: [] };
    }
    exports2.GroupChangeContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.groupUser !== void 0) {
          exports2.GroupChannelAllUser.encode(message.groupUser, writer.uint32(10).fork()).join();
        }
        for (const v of message.linkedUserUiPositions) {
          writer.uint32(18).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGroupChangeContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.groupUser = exports2.GroupChannelAllUser.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.linkedUserUiPositions.push(reader.string());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent() {
      return { overLength: "0", multiLiveContent: void 0, cohostContent: void 0 };
    }
    exports2.BusinessContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.overLength !== "0") {
          writer.uint32(8).int64(message.overLength);
        }
        if (message.multiLiveContent !== void 0) {
          exports2.MultiLiveContent.encode(message.multiLiveContent, writer.uint32(802).fork()).join();
        }
        if (message.cohostContent !== void 0) {
          exports2.BusinessContent_CohostContent.encode(message.cohostContent, writer.uint32(1602).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.overLength = reader.int64().toString();
              continue;
            }
            case 100: {
              if (tag !== 802) {
                break;
              }
              message.multiLiveContent = exports2.MultiLiveContent.decode(reader, reader.uint32());
              continue;
            }
            case 200: {
              if (tag !== 1602) {
                break;
              }
              message.cohostContent = exports2.BusinessContent_CohostContent.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_CohostContent() {
      return { joinGroupBizContent: void 0, permitJoinGroupBizContent: void 0, listChangeBizContent: void 0 };
    }
    exports2.BusinessContent_CohostContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.joinGroupBizContent !== void 0) {
          exports2.BusinessContent_JoinGroupBizContent.encode(message.joinGroupBizContent, writer.uint32(10).fork()).join();
        }
        if (message.permitJoinGroupBizContent !== void 0) {
          exports2.BusinessContent_PermitJoinGroupBizContent.encode(message.permitJoinGroupBizContent, writer.uint32(18).fork()).join();
        }
        if (message.listChangeBizContent !== void 0) {
          exports2.BusinessContent_ListChangeBizContent.encode(message.listChangeBizContent, writer.uint32(90).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_CohostContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.joinGroupBizContent = exports2.BusinessContent_JoinGroupBizContent.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.permitJoinGroupBizContent = exports2.BusinessContent_PermitJoinGroupBizContent.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.listChangeBizContent = exports2.BusinessContent_ListChangeBizContent.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_PermitJoinGroupBizContent() {
      return { replyStatus: 0, sourceType: 0 };
    }
    exports2.BusinessContent_PermitJoinGroupBizContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.replyStatus !== 0) {
          writer.uint32(8).int32(message.replyStatus);
        }
        if (message.sourceType !== 0) {
          writer.uint32(16).int32(message.sourceType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_PermitJoinGroupBizContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.replyStatus = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.sourceType = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_ListChangeBizContent() {
      return { userInfos: {}, waitingUsers: [] };
    }
    exports2.BusinessContent_ListChangeBizContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        Object.entries(message.userInfos).forEach(([key, value]) => {
          exports2.BusinessContent_ListChangeBizContent_UserInfosEntry.encode({ key, value }, writer.uint32(10).fork()).join();
        });
        for (const v of message.waitingUsers) {
          exports2.BusinessContent_ListChangeBizContent_VirtualWaitingUser.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_ListChangeBizContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              const entry1 = exports2.BusinessContent_ListChangeBizContent_UserInfosEntry.decode(reader, reader.uint32());
              if (entry1.value !== void 0) {
                message.userInfos[entry1.key] = entry1.value;
              }
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.waitingUsers.push(exports2.BusinessContent_ListChangeBizContent_VirtualWaitingUser.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_ListChangeBizContent_UserInfosEntry() {
      return { key: "0", value: void 0 };
    }
    exports2.BusinessContent_ListChangeBizContent_UserInfosEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "0") {
          writer.uint32(8).int64(message.key);
        }
        if (message.value !== void 0) {
          exports2.BusinessContent_CohostUserInfo.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_ListChangeBizContent_UserInfosEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = exports2.BusinessContent_CohostUserInfo.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_ListChangeBizContent_VirtualWaitingUser() {
      return { userId: "0", timestamp: "0", avatars: [] };
    }
    exports2.BusinessContent_ListChangeBizContent_VirtualWaitingUser = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.timestamp !== "0") {
          writer.uint32(16).int64(message.timestamp);
        }
        for (const v of message.avatars) {
          exports2.Image.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_ListChangeBizContent_VirtualWaitingUser();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.timestamp = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.avatars.push(exports2.Image.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_CohostUserInfo() {
      return {
        permissionType: "0",
        sourceType: 0,
        isLowVersion: false,
        bestTeammateUid: "0",
        hasTopicPerm: false,
        streamConfig: void 0,
        inDifferentInviteTypeControlGroup: false,
        nickname: "",
        displayId: "",
        avatarThumb: void 0,
        followStatus: "0",
        userIdStr: ""
      };
    }
    exports2.BusinessContent_CohostUserInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.permissionType !== "0") {
          writer.uint32(8).int64(message.permissionType);
        }
        if (message.sourceType !== 0) {
          writer.uint32(16).int32(message.sourceType);
        }
        if (message.isLowVersion !== false) {
          writer.uint32(24).bool(message.isLowVersion);
        }
        if (message.bestTeammateUid !== "0") {
          writer.uint32(32).int64(message.bestTeammateUid);
        }
        if (message.hasTopicPerm !== false) {
          writer.uint32(40).bool(message.hasTopicPerm);
        }
        if (message.streamConfig !== void 0) {
          exports2.BusinessContent_CohostUserInfo_CohostStreamConfig.encode(message.streamConfig, writer.uint32(50).fork()).join();
        }
        if (message.inDifferentInviteTypeControlGroup !== false) {
          writer.uint32(56).bool(message.inDifferentInviteTypeControlGroup);
        }
        if (message.nickname !== "") {
          writer.uint32(90).string(message.nickname);
        }
        if (message.displayId !== "") {
          writer.uint32(98).string(message.displayId);
        }
        if (message.avatarThumb !== void 0) {
          exports2.Image.encode(message.avatarThumb, writer.uint32(106).fork()).join();
        }
        if (message.followStatus !== "0") {
          writer.uint32(112).int64(message.followStatus);
        }
        if (message.userIdStr !== "") {
          writer.uint32(122).string(message.userIdStr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_CohostUserInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.permissionType = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.sourceType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.isLowVersion = reader.bool();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.bestTeammateUid = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.hasTopicPerm = reader.bool();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.streamConfig = exports2.BusinessContent_CohostUserInfo_CohostStreamConfig.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.inDifferentInviteTypeControlGroup = reader.bool();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.nickname = reader.string();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.displayId = reader.string();
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.avatarThumb = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 14: {
              if (tag !== 112) {
                break;
              }
              message.followStatus = reader.int64().toString();
              continue;
            }
            case 15: {
              if (tag !== 122) {
                break;
              }
              message.userIdStr = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_CohostUserInfo_CohostStreamConfig() {
      return { screenShareStreamId: "" };
    }
    exports2.BusinessContent_CohostUserInfo_CohostStreamConfig = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.screenShareStreamId !== "") {
          writer.uint32(10).string(message.screenShareStreamId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_CohostUserInfo_CohostStreamConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.screenShareStreamId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_JoinGroupBizContent() {
      return {
        fromRoomAgeRestricted: 0,
        fromTag: void 0,
        dialog: void 0,
        punishInfo: void 0,
        topicInfo: void 0,
        algoRequestId: "",
        cohostLayoutMode: 0,
        tag: void 0,
        gameTag: void 0,
        newUserEducation: "",
        joinGroupMsgExtra: void 0
      };
    }
    exports2.BusinessContent_JoinGroupBizContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.fromRoomAgeRestricted !== 0) {
          writer.uint32(8).int32(message.fromRoomAgeRestricted);
        }
        if (message.fromTag !== void 0) {
          exports2.BusinessContent_Tag.encode(message.fromTag, writer.uint32(18).fork()).join();
        }
        if (message.dialog !== void 0) {
          exports2.BusinessContent_PerceptionDialogInfo.encode(message.dialog, writer.uint32(26).fork()).join();
        }
        if (message.punishInfo !== void 0) {
          exports2.PunishEventInfo.encode(message.punishInfo, writer.uint32(34).fork()).join();
        }
        if (message.topicInfo !== void 0) {
          exports2.CohostTopic.encode(message.topicInfo, writer.uint32(42).fork()).join();
        }
        if (message.algoRequestId !== "") {
          writer.uint32(50).string(message.algoRequestId);
        }
        if (message.cohostLayoutMode !== 0) {
          writer.uint32(56).int32(message.cohostLayoutMode);
        }
        if (message.tag !== void 0) {
          exports2.BusinessContent_JoinGroupBizContent_TagV2.encode(message.tag, writer.uint32(66).fork()).join();
        }
        if (message.gameTag !== void 0) {
          exports2.BusinessContent_JoinGroupBizContent_RivalsGameTag.encode(message.gameTag, writer.uint32(74).fork()).join();
        }
        if (message.newUserEducation !== "") {
          writer.uint32(90).string(message.newUserEducation);
        }
        if (message.joinGroupMsgExtra !== void 0) {
          exports2.BusinessContent_JoinGroupMessageExtra.encode(message.joinGroupMsgExtra, writer.uint32(810).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_JoinGroupBizContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.fromRoomAgeRestricted = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.fromTag = exports2.BusinessContent_Tag.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.dialog = exports2.BusinessContent_PerceptionDialogInfo.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.punishInfo = exports2.PunishEventInfo.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.topicInfo = exports2.CohostTopic.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.algoRequestId = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.cohostLayoutMode = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.tag = exports2.BusinessContent_JoinGroupBizContent_TagV2.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.gameTag = exports2.BusinessContent_JoinGroupBizContent_RivalsGameTag.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.newUserEducation = reader.string();
              continue;
            }
            case 101: {
              if (tag !== 810) {
                break;
              }
              message.joinGroupMsgExtra = exports2.BusinessContent_JoinGroupMessageExtra.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_JoinGroupBizContent_RivalsGameTag() {
      return { tagId: "0", tagDisplayText: "" };
    }
    exports2.BusinessContent_JoinGroupBizContent_RivalsGameTag = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.tagId !== "0") {
          writer.uint32(8).int64(message.tagId);
        }
        if (message.tagDisplayText !== "") {
          writer.uint32(18).string(message.tagDisplayText);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_JoinGroupBizContent_RivalsGameTag();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.tagId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.tagDisplayText = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_JoinGroupBizContent_TagV2() {
      return {
        tagClassification: 0,
        tagType: 0,
        tagValue: "",
        starlingKey: "",
        secondDegreeRelationContent: void 0,
        cohostHistoryDay: "0",
        similarInterestContent: void 0
      };
    }
    exports2.BusinessContent_JoinGroupBizContent_TagV2 = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.tagClassification !== 0) {
          writer.uint32(8).int32(message.tagClassification);
        }
        if (message.tagType !== 0) {
          writer.uint32(16).int32(message.tagType);
        }
        if (message.tagValue !== "") {
          writer.uint32(26).string(message.tagValue);
        }
        if (message.starlingKey !== "") {
          writer.uint32(34).string(message.starlingKey);
        }
        if (message.secondDegreeRelationContent !== void 0) {
          exports2.BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent.encode(message.secondDegreeRelationContent, writer.uint32(82).fork()).join();
        }
        if (message.cohostHistoryDay !== "0") {
          writer.uint32(88).int64(message.cohostHistoryDay);
        }
        if (message.similarInterestContent !== void 0) {
          exports2.BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent.encode(message.similarInterestContent, writer.uint32(98).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_JoinGroupBizContent_TagV2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.tagClassification = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.tagType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.tagValue = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.starlingKey = reader.string();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.secondDegreeRelationContent = exports2.BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.cohostHistoryDay = reader.int64().toString();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.similarInterestContent = exports2.BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_JoinGroupBizContent_TagV2_UserInfo() {
      return { userId: "0", nickName: "", avatarThumb: void 0 };
    }
    exports2.BusinessContent_JoinGroupBizContent_TagV2_UserInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.nickName !== "") {
          writer.uint32(18).string(message.nickName);
        }
        if (message.avatarThumb !== void 0) {
          exports2.Image.encode(message.avatarThumb, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_JoinGroupBizContent_TagV2_UserInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.nickName = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.avatarThumb = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent() {
      return { relatedUsers: [], totalRelatedUserCnt: "0" };
    }
    exports2.BusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.relatedUsers) {
          exports2.BusinessContent_JoinGroupBizContent_TagV2_UserInfo.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.totalRelatedUserCnt !== "0") {
          writer.uint32(16).int64(message.totalRelatedUserCnt);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_JoinGroupBizContent_TagV2_SecondDegreeRelationContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.relatedUsers.push(exports2.BusinessContent_JoinGroupBizContent_TagV2_UserInfo.decode(reader, reader.uint32()));
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.totalRelatedUserCnt = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent() {
      return { contentId: "0", displayText: "" };
    }
    exports2.BusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.contentId !== "0") {
          writer.uint32(8).int64(message.contentId);
        }
        if (message.displayText !== "") {
          writer.uint32(18).string(message.displayText);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_JoinGroupBizContent_TagV2_SimilarInterestContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.contentId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.displayText = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_Tag() {
      return { tagType: 0, tagValue: "", tagText: "" };
    }
    exports2.BusinessContent_Tag = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.tagType !== 0) {
          writer.uint32(8).int32(message.tagType);
        }
        if (message.tagValue !== "") {
          writer.uint32(18).string(message.tagValue);
        }
        if (message.tagText !== "") {
          writer.uint32(26).string(message.tagText);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_Tag();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.tagType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.tagValue = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.tagText = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_PerceptionDialogInfo() {
      return {
        iconType: "0",
        title: void 0,
        subTitle: void 0,
        adviceActionText: void 0,
        defaultActionText: void 0,
        violationDetailUrl: "",
        scene: 0,
        targetUserId: "0",
        targetRoomId: "0",
        countDownTime: "0",
        showFeedback: false,
        feedbackOptionsList: [],
        policyTip: "0"
      };
    }
    exports2.BusinessContent_PerceptionDialogInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.iconType !== "0") {
          writer.uint32(8).int64(message.iconType);
        }
        if (message.title !== void 0) {
          exports2.Text.encode(message.title, writer.uint32(18).fork()).join();
        }
        if (message.subTitle !== void 0) {
          exports2.Text.encode(message.subTitle, writer.uint32(26).fork()).join();
        }
        if (message.adviceActionText !== void 0) {
          exports2.Text.encode(message.adviceActionText, writer.uint32(34).fork()).join();
        }
        if (message.defaultActionText !== void 0) {
          exports2.Text.encode(message.defaultActionText, writer.uint32(42).fork()).join();
        }
        if (message.violationDetailUrl !== "") {
          writer.uint32(50).string(message.violationDetailUrl);
        }
        if (message.scene !== 0) {
          writer.uint32(56).int32(message.scene);
        }
        if (message.targetUserId !== "0") {
          writer.uint32(64).int64(message.targetUserId);
        }
        if (message.targetRoomId !== "0") {
          writer.uint32(72).int64(message.targetRoomId);
        }
        if (message.countDownTime !== "0") {
          writer.uint32(80).int64(message.countDownTime);
        }
        if (message.showFeedback !== false) {
          writer.uint32(88).bool(message.showFeedback);
        }
        for (const v of message.feedbackOptionsList) {
          exports2.BusinessContent_PerceptionFeedbackOption.encode(v, writer.uint32(98).fork()).join();
        }
        if (message.policyTip !== "0") {
          writer.uint32(104).int64(message.policyTip);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_PerceptionDialogInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.iconType = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.title = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.subTitle = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.adviceActionText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.defaultActionText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.violationDetailUrl = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.scene = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.targetUserId = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.targetRoomId = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.countDownTime = reader.int64().toString();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.showFeedback = reader.bool();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.feedbackOptionsList.push(exports2.BusinessContent_PerceptionFeedbackOption.decode(reader, reader.uint32()));
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.policyTip = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_PerceptionFeedbackOption() {
      return { id: "0", contentKey: "" };
    }
    exports2.BusinessContent_PerceptionFeedbackOption = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== "0") {
          writer.uint32(8).int64(message.id);
        }
        if (message.contentKey !== "") {
          writer.uint32(18).string(message.contentKey);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_PerceptionFeedbackOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.contentKey = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_JoinGroupMessageExtra() {
      return { sourceType: "0", extra: void 0, otherUsersList: [] };
    }
    exports2.BusinessContent_JoinGroupMessageExtra = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.sourceType !== "0") {
          writer.uint32(8).int64(message.sourceType);
        }
        if (message.extra !== void 0) {
          exports2.BusinessContent_JoinGroupMessageExtra_RivalExtra.encode(message.extra, writer.uint32(18).fork()).join();
        }
        for (const v of message.otherUsersList) {
          exports2.BusinessContent_JoinGroupMessageExtra_RivalExtra.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_JoinGroupMessageExtra();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.sourceType = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.extra = exports2.BusinessContent_JoinGroupMessageExtra_RivalExtra.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.otherUsersList.push(exports2.BusinessContent_JoinGroupMessageExtra_RivalExtra.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra() {
      return {
        userCount: "0",
        avatarThumb: void 0,
        displayId: "",
        authenticationInfo: void 0,
        nickname: "",
        followStatus: "0",
        hashtag: void 0,
        topHostInfo: void 0,
        userId: "0",
        isBestTeammate: false
      };
    }
    exports2.BusinessContent_JoinGroupMessageExtra_RivalExtra = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userCount !== "0") {
          writer.uint32(32).int64(message.userCount);
        }
        if (message.avatarThumb !== void 0) {
          exports2.Image.encode(message.avatarThumb, writer.uint32(42).fork()).join();
        }
        if (message.displayId !== "") {
          writer.uint32(50).string(message.displayId);
        }
        if (message.authenticationInfo !== void 0) {
          exports2.BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo.encode(message.authenticationInfo, writer.uint32(58).fork()).join();
        }
        if (message.nickname !== "") {
          writer.uint32(66).string(message.nickname);
        }
        if (message.followStatus !== "0") {
          writer.uint32(72).int64(message.followStatus);
        }
        if (message.hashtag !== void 0) {
          exports2.BusinessContent_Hashtag.encode(message.hashtag, writer.uint32(82).fork()).join();
        }
        if (message.topHostInfo !== void 0) {
          exports2.BusinessContent_TopHostInfo.encode(message.topHostInfo, writer.uint32(90).fork()).join();
        }
        if (message.userId !== "0") {
          writer.uint32(96).int64(message.userId);
        }
        if (message.isBestTeammate !== false) {
          writer.uint32(104).bool(message.isBestTeammate);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.userCount = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.avatarThumb = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.displayId = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.authenticationInfo = exports2.BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.nickname = reader.string();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.followStatus = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.hashtag = exports2.BusinessContent_Hashtag.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.topHostInfo = exports2.BusinessContent_TopHostInfo.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.isBestTeammate = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo() {
      return { customVerify: "", enterpriseVerifyReason: "", authenticationBadge: void 0 };
    }
    exports2.BusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.customVerify !== "") {
          writer.uint32(10).string(message.customVerify);
        }
        if (message.enterpriseVerifyReason !== "") {
          writer.uint32(18).string(message.enterpriseVerifyReason);
        }
        if (message.authenticationBadge !== void 0) {
          exports2.Image.encode(message.authenticationBadge, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_JoinGroupMessageExtra_RivalExtra_AuthenticationInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.customVerify = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.enterpriseVerifyReason = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.authenticationBadge = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_Hashtag() {
      return { id: "0", title: "", image: void 0, namespace: 0 };
    }
    exports2.BusinessContent_Hashtag = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== "0") {
          writer.uint32(8).int64(message.id);
        }
        if (message.title !== "") {
          writer.uint32(18).string(message.title);
        }
        if (message.image !== void 0) {
          exports2.Image.encode(message.image, writer.uint32(26).fork()).join();
        }
        if (message.namespace !== 0) {
          writer.uint32(32).int32(message.namespace);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_Hashtag();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.title = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.image = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.namespace = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBusinessContent_TopHostInfo() {
      return { rankType: "", topIndex: "0" };
    }
    exports2.BusinessContent_TopHostInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.rankType !== "") {
          writer.uint32(10).string(message.rankType);
        }
        if (message.topIndex !== "0") {
          writer.uint32(16).int64(message.topIndex);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBusinessContent_TopHostInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.rankType = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.topIndex = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseJoinGroupContent() {
      return { groupUser: void 0, joinUser: void 0, type: 0, groupExtInfo: [] };
    }
    exports2.JoinGroupContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.groupUser !== void 0) {
          exports2.GroupChannelAllUser.encode(message.groupUser, writer.uint32(10).fork()).join();
        }
        if (message.joinUser !== void 0) {
          exports2.GroupPlayer.encode(message.joinUser, writer.uint32(18).fork()).join();
        }
        if (message.type !== 0) {
          writer.uint32(24).int32(message.type);
        }
        for (const v of message.groupExtInfo) {
          exports2.RTCExtraInfo.encode(v, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseJoinGroupContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.groupUser = exports2.GroupChannelAllUser.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.joinUser = exports2.GroupPlayer.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.groupExtInfo.push(exports2.RTCExtraInfo.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePrivilegeLogExtra() {
      return { dataVersion: "", privilegeId: "", privilegeVersion: "", privilegeOrderId: "", level: "" };
    }
    exports2.PrivilegeLogExtra = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.dataVersion !== "") {
          writer.uint32(10).string(message.dataVersion);
        }
        if (message.privilegeId !== "") {
          writer.uint32(18).string(message.privilegeId);
        }
        if (message.privilegeVersion !== "") {
          writer.uint32(26).string(message.privilegeVersion);
        }
        if (message.privilegeOrderId !== "") {
          writer.uint32(34).string(message.privilegeOrderId);
        }
        if (message.level !== "") {
          writer.uint32(42).string(message.level);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePrivilegeLogExtra();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.dataVersion = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.privilegeId = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.privilegeVersion = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.privilegeOrderId = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.level = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseFontStyle() {
      return { fontSize: 0, fontWidth: 0, fontColor: "", borderColor: "" };
    }
    exports2.FontStyle = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.fontSize !== 0) {
          writer.uint32(8).int32(message.fontSize);
        }
        if (message.fontWidth !== 0) {
          writer.uint32(16).int32(message.fontWidth);
        }
        if (message.fontColor !== "") {
          writer.uint32(26).string(message.fontColor);
        }
        if (message.borderColor !== "") {
          writer.uint32(34).string(message.borderColor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFontStyle();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.fontSize = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.fontWidth = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.fontColor = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.borderColor = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUserHonor() {
      return {
        totalDiamond: "0",
        diamondIcon: void 0,
        currentHonorName: "",
        currentHonorIcon: void 0,
        nextHonorName: "",
        level: 0,
        nextHonorIcon: void 0,
        currentDiamond: "0",
        thisGradeMinDiamond: "0",
        thisGradeMaxDiamond: "0",
        gradeDescribe: "",
        gradeIconList: [],
        screenChatType: "0",
        imIcon: void 0,
        imIconWithLevel: void 0,
        liveIcon: void 0,
        newImIconWithLevel: void 0,
        newLiveIcon: void 0,
        upgradeNeedConsume: "0",
        nextPrivileges: "",
        profileDialogBg: void 0,
        profileDialogBackBg: void 0,
        score: "0",
        gradeBanner: ""
      };
    }
    exports2.UserHonor = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.totalDiamond !== "0") {
          writer.uint32(8).int64(message.totalDiamond);
        }
        if (message.diamondIcon !== void 0) {
          exports2.Image.encode(message.diamondIcon, writer.uint32(18).fork()).join();
        }
        if (message.currentHonorName !== "") {
          writer.uint32(26).string(message.currentHonorName);
        }
        if (message.currentHonorIcon !== void 0) {
          exports2.Image.encode(message.currentHonorIcon, writer.uint32(34).fork()).join();
        }
        if (message.nextHonorName !== "") {
          writer.uint32(42).string(message.nextHonorName);
        }
        if (message.level !== 0) {
          writer.uint32(48).int32(message.level);
        }
        if (message.nextHonorIcon !== void 0) {
          exports2.Image.encode(message.nextHonorIcon, writer.uint32(58).fork()).join();
        }
        if (message.currentDiamond !== "0") {
          writer.uint32(72).int64(message.currentDiamond);
        }
        if (message.thisGradeMinDiamond !== "0") {
          writer.uint32(80).int64(message.thisGradeMinDiamond);
        }
        if (message.thisGradeMaxDiamond !== "0") {
          writer.uint32(88).int64(message.thisGradeMaxDiamond);
        }
        if (message.gradeDescribe !== "") {
          writer.uint32(106).string(message.gradeDescribe);
        }
        for (const v of message.gradeIconList) {
          exports2.GradeIcon.encode(v, writer.uint32(114).fork()).join();
        }
        if (message.screenChatType !== "0") {
          writer.uint32(120).int64(message.screenChatType);
        }
        if (message.imIcon !== void 0) {
          exports2.Image.encode(message.imIcon, writer.uint32(130).fork()).join();
        }
        if (message.imIconWithLevel !== void 0) {
          exports2.Image.encode(message.imIconWithLevel, writer.uint32(138).fork()).join();
        }
        if (message.liveIcon !== void 0) {
          exports2.Image.encode(message.liveIcon, writer.uint32(146).fork()).join();
        }
        if (message.newImIconWithLevel !== void 0) {
          exports2.Image.encode(message.newImIconWithLevel, writer.uint32(154).fork()).join();
        }
        if (message.newLiveIcon !== void 0) {
          exports2.Image.encode(message.newLiveIcon, writer.uint32(162).fork()).join();
        }
        if (message.upgradeNeedConsume !== "0") {
          writer.uint32(168).int64(message.upgradeNeedConsume);
        }
        if (message.nextPrivileges !== "") {
          writer.uint32(178).string(message.nextPrivileges);
        }
        if (message.profileDialogBg !== void 0) {
          exports2.Image.encode(message.profileDialogBg, writer.uint32(186).fork()).join();
        }
        if (message.profileDialogBackBg !== void 0) {
          exports2.Image.encode(message.profileDialogBackBg, writer.uint32(194).fork()).join();
        }
        if (message.score !== "0") {
          writer.uint32(200).int64(message.score);
        }
        if (message.gradeBanner !== "") {
          writer.uint32(8010).string(message.gradeBanner);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUserHonor();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.totalDiamond = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.diamondIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.currentHonorName = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.currentHonorIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.nextHonorName = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.level = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.nextHonorIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.currentDiamond = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.thisGradeMinDiamond = reader.int64().toString();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.thisGradeMaxDiamond = reader.int64().toString();
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.gradeDescribe = reader.string();
              continue;
            }
            case 14: {
              if (tag !== 114) {
                break;
              }
              message.gradeIconList.push(exports2.GradeIcon.decode(reader, reader.uint32()));
              continue;
            }
            case 15: {
              if (tag !== 120) {
                break;
              }
              message.screenChatType = reader.int64().toString();
              continue;
            }
            case 16: {
              if (tag !== 130) {
                break;
              }
              message.imIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 17: {
              if (tag !== 138) {
                break;
              }
              message.imIconWithLevel = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 18: {
              if (tag !== 146) {
                break;
              }
              message.liveIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 19: {
              if (tag !== 154) {
                break;
              }
              message.newImIconWithLevel = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 20: {
              if (tag !== 162) {
                break;
              }
              message.newLiveIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 21: {
              if (tag !== 168) {
                break;
              }
              message.upgradeNeedConsume = reader.int64().toString();
              continue;
            }
            case 22: {
              if (tag !== 178) {
                break;
              }
              message.nextPrivileges = reader.string();
              continue;
            }
            case 23: {
              if (tag !== 186) {
                break;
              }
              message.profileDialogBg = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 24: {
              if (tag !== 194) {
                break;
              }
              message.profileDialogBackBg = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 25: {
              if (tag !== 200) {
                break;
              }
              message.score = reader.int64().toString();
              continue;
            }
            case 1001: {
              if (tag !== 8010) {
                break;
              }
              message.gradeBanner = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGradeIcon() {
      return { icon: void 0, iconDiamond: "0", level: "0", levelStr: "" };
    }
    exports2.GradeIcon = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(10).fork()).join();
        }
        if (message.iconDiamond !== "0") {
          writer.uint32(16).int64(message.iconDiamond);
        }
        if (message.level !== "0") {
          writer.uint32(24).int64(message.level);
        }
        if (message.levelStr !== "") {
          writer.uint32(34).string(message.levelStr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGradeIcon();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.iconDiamond = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.level = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.levelStr = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBorderInfo() {
      return {
        icon: void 0,
        level: "0",
        source: "",
        profileDecorationRibbon: void 0,
        borderLogExtra: void 0,
        ribbonLogExtra: void 0,
        avatarBackgroundColor: "",
        avatarBackgroundBorderColor: ""
      };
    }
    exports2.BorderInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(10).fork()).join();
        }
        if (message.level !== "0") {
          writer.uint32(16).int64(message.level);
        }
        if (message.source !== "") {
          writer.uint32(26).string(message.source);
        }
        if (message.profileDecorationRibbon !== void 0) {
          exports2.Image.encode(message.profileDecorationRibbon, writer.uint32(34).fork()).join();
        }
        if (message.borderLogExtra !== void 0) {
          exports2.PrivilegeLogExtra.encode(message.borderLogExtra, writer.uint32(42).fork()).join();
        }
        if (message.ribbonLogExtra !== void 0) {
          exports2.PrivilegeLogExtra.encode(message.ribbonLogExtra, writer.uint32(50).fork()).join();
        }
        if (message.avatarBackgroundColor !== "") {
          writer.uint32(58).string(message.avatarBackgroundColor);
        }
        if (message.avatarBackgroundBorderColor !== "") {
          writer.uint32(66).string(message.avatarBackgroundBorderColor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBorderInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.level = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.source = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.profileDecorationRibbon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.borderLogExtra = exports2.PrivilegeLogExtra.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.ribbonLogExtra = exports2.PrivilegeLogExtra.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.avatarBackgroundColor = reader.string();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.avatarBackgroundBorderColor = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseFansClubMember() {
      return { data: void 0, preferData: {} };
    }
    exports2.FansClubMember = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.data !== void 0) {
          exports2.FansClubData.encode(message.data, writer.uint32(10).fork()).join();
        }
        Object.entries(message.preferData).forEach(([key, value]) => {
          exports2.FansClubMember_PreferDataEntry.encode({ key, value }, writer.uint32(18).fork()).join();
        });
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFansClubMember();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.data = exports2.FansClubData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              const entry2 = exports2.FansClubMember_PreferDataEntry.decode(reader, reader.uint32());
              if (entry2.value !== void 0) {
                message.preferData[entry2.key] = entry2.value;
              }
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseFansClubMember_PreferDataEntry() {
      return { key: 0, value: void 0 };
    }
    exports2.FansClubMember_PreferDataEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== 0) {
          writer.uint32(8).int32(message.key);
        }
        if (message.value !== void 0) {
          exports2.FansClubData.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFansClubMember_PreferDataEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = exports2.FansClubData.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseFansClubData() {
      return { clubName: "", level: 0, userFansClubStatus: 0, badge: void 0, availableGiftIds: [], anchorId: "0" };
    }
    exports2.FansClubData = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.clubName !== "") {
          writer.uint32(10).string(message.clubName);
        }
        if (message.level !== 0) {
          writer.uint32(16).int32(message.level);
        }
        if (message.userFansClubStatus !== 0) {
          writer.uint32(24).int32(message.userFansClubStatus);
        }
        if (message.badge !== void 0) {
          exports2.FansClubData_UserBadge.encode(message.badge, writer.uint32(34).fork()).join();
        }
        writer.uint32(42).fork();
        for (const v of message.availableGiftIds) {
          writer.int64(v);
        }
        writer.join();
        if (message.anchorId !== "0") {
          writer.uint32(48).int64(message.anchorId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFansClubData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.clubName = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.level = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.userFansClubStatus = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.badge = exports2.FansClubData_UserBadge.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag === 40) {
                message.availableGiftIds.push(reader.int64().toString());
                continue;
              }
              if (tag === 42) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.availableGiftIds.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.anchorId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseFansClubData_UserBadge() {
      return { icons: {}, title: "" };
    }
    exports2.FansClubData_UserBadge = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        Object.entries(message.icons).forEach(([key, value]) => {
          exports2.FansClubData_UserBadge_IconsEntry.encode({ key, value }, writer.uint32(10).fork()).join();
        });
        if (message.title !== "") {
          writer.uint32(18).string(message.title);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFansClubData_UserBadge();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              const entry1 = exports2.FansClubData_UserBadge_IconsEntry.decode(reader, reader.uint32());
              if (entry1.value !== void 0) {
                message.icons[entry1.key] = entry1.value;
              }
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.title = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseFansClubData_UserBadge_IconsEntry() {
      return { key: 0, value: void 0 };
    }
    exports2.FansClubData_UserBadge_IconsEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== 0) {
          writer.uint32(8).int32(message.key);
        }
        if (message.value !== void 0) {
          exports2.Image.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFansClubData_UserBadge_IconsEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseAuthor() {
      return { videoTotalCount: "0", videoTotalPlayCount: "0", videoTotalFavoriteCount: "0" };
    }
    exports2.Author = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.videoTotalCount !== "0") {
          writer.uint32(8).int64(message.videoTotalCount);
        }
        if (message.videoTotalPlayCount !== "0") {
          writer.uint32(16).int64(message.videoTotalPlayCount);
        }
        if (message.videoTotalFavoriteCount !== "0") {
          writer.uint32(48).int64(message.videoTotalFavoriteCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseAuthor();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.videoTotalCount = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.videoTotalPlayCount = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.videoTotalFavoriteCount = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePublicAreaCommon() {
      return { userLabel: void 0, userConsumeInRoom: "0" };
    }
    exports2.PublicAreaCommon = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userLabel !== void 0) {
          exports2.Image.encode(message.userLabel, writer.uint32(10).fork()).join();
        }
        if (message.userConsumeInRoom !== "0") {
          writer.uint32(16).int64(message.userConsumeInRoom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicAreaCommon();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.userLabel = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.userConsumeInRoom = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePublicAreaMessageCommon() {
      return {
        scrollGapCount: "0",
        anchorScrollGapCount: "0",
        releaseToScrollArea: false,
        anchorReleaseToScrollArea: false,
        isAnchorMarked: false,
        creatorSuccessInfo: void 0,
        portraitInfo: void 0,
        userInteractionInfo: void 0,
        adminFoldType: "0"
      };
    }
    exports2.PublicAreaMessageCommon = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.scrollGapCount !== "0") {
          writer.uint32(8).int64(message.scrollGapCount);
        }
        if (message.anchorScrollGapCount !== "0") {
          writer.uint32(16).int64(message.anchorScrollGapCount);
        }
        if (message.releaseToScrollArea !== false) {
          writer.uint32(24).bool(message.releaseToScrollArea);
        }
        if (message.anchorReleaseToScrollArea !== false) {
          writer.uint32(32).bool(message.anchorReleaseToScrollArea);
        }
        if (message.isAnchorMarked !== false) {
          writer.uint32(40).bool(message.isAnchorMarked);
        }
        if (message.creatorSuccessInfo !== void 0) {
          exports2.PublicAreaMessageCommon_CreatorSuccessInfo.encode(message.creatorSuccessInfo, writer.uint32(50).fork()).join();
        }
        if (message.portraitInfo !== void 0) {
          exports2.PublicAreaMessageCommon_PortraitInfo.encode(message.portraitInfo, writer.uint32(58).fork()).join();
        }
        if (message.userInteractionInfo !== void 0) {
          exports2.PublicAreaMessageCommon_UserInteractionInfo.encode(message.userInteractionInfo, writer.uint32(66).fork()).join();
        }
        if (message.adminFoldType !== "0") {
          writer.uint32(72).int64(message.adminFoldType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicAreaMessageCommon();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.scrollGapCount = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.anchorScrollGapCount = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.releaseToScrollArea = reader.bool();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.anchorReleaseToScrollArea = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.isAnchorMarked = reader.bool();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.creatorSuccessInfo = exports2.PublicAreaMessageCommon_CreatorSuccessInfo.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.portraitInfo = exports2.PublicAreaMessageCommon_PortraitInfo.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.userInteractionInfo = exports2.PublicAreaMessageCommon_UserInteractionInfo.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.adminFoldType = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePublicAreaMessageCommon_TagItem() {
      return { tagType: 0, tagText: void 0 };
    }
    exports2.PublicAreaMessageCommon_TagItem = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.tagType !== 0) {
          writer.uint32(8).int32(message.tagType);
        }
        if (message.tagText !== void 0) {
          exports2.Text.encode(message.tagText, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicAreaMessageCommon_TagItem();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.tagType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.tagText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePublicAreaMessageCommon_Topic() {
      return { topicActionType: 0, topicText: void 0, topicTips: void 0 };
    }
    exports2.PublicAreaMessageCommon_Topic = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.topicActionType !== 0) {
          writer.uint32(8).int32(message.topicActionType);
        }
        if (message.topicText !== void 0) {
          exports2.Text.encode(message.topicText, writer.uint32(18).fork()).join();
        }
        if (message.topicTips !== void 0) {
          exports2.Text.encode(message.topicTips, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicAreaMessageCommon_Topic();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.topicActionType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.topicText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.topicTips = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePublicAreaMessageCommon_CreatorSuccessInfo() {
      return { tags: [], topic: void 0 };
    }
    exports2.PublicAreaMessageCommon_CreatorSuccessInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.tags) {
          exports2.PublicAreaMessageCommon_TagItem.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.topic !== void 0) {
          exports2.PublicAreaMessageCommon_Topic.encode(message.topic, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicAreaMessageCommon_CreatorSuccessInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.tags.push(exports2.PublicAreaMessageCommon_TagItem.decode(reader, reader.uint32()));
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.topic = exports2.PublicAreaMessageCommon_Topic.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePublicAreaMessageCommon_UserMetrics() {
      return { type: 0, metricsValue: "" };
    }
    exports2.PublicAreaMessageCommon_UserMetrics = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.metricsValue !== "") {
          writer.uint32(18).string(message.metricsValue);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicAreaMessageCommon_UserMetrics();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.metricsValue = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePublicAreaMessageCommon_PortraitTag() {
      return { tagId: "", priority: "0", showValue: "", showArgs: "" };
    }
    exports2.PublicAreaMessageCommon_PortraitTag = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.tagId !== "") {
          writer.uint32(10).string(message.tagId);
        }
        if (message.priority !== "0") {
          writer.uint32(16).int64(message.priority);
        }
        if (message.showValue !== "") {
          writer.uint32(26).string(message.showValue);
        }
        if (message.showArgs !== "") {
          writer.uint32(34).string(message.showArgs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicAreaMessageCommon_PortraitTag();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.tagId = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.priority = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.showValue = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.showArgs = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePublicAreaMessageCommon_PortraitInfo() {
      return { userMetrics: [], portraitTag: [] };
    }
    exports2.PublicAreaMessageCommon_PortraitInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.userMetrics) {
          exports2.PublicAreaMessageCommon_UserMetrics.encode(v, writer.uint32(10).fork()).join();
        }
        for (const v of message.portraitTag) {
          exports2.PublicAreaMessageCommon_PortraitTag.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicAreaMessageCommon_PortraitInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.userMetrics.push(exports2.PublicAreaMessageCommon_UserMetrics.decode(reader, reader.uint32()));
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.portraitTag.push(exports2.PublicAreaMessageCommon_PortraitTag.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBasePublicAreaMessageCommon_UserInteractionInfo() {
      return { likeCnt: "0", commentCnt: "0", shareCnt: "0" };
    }
    exports2.PublicAreaMessageCommon_UserInteractionInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.likeCnt !== "0") {
          writer.uint32(8).int64(message.likeCnt);
        }
        if (message.commentCnt !== "0") {
          writer.uint32(16).int64(message.commentCnt);
        }
        if (message.shareCnt !== "0") {
          writer.uint32(24).int64(message.shareCnt);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBasePublicAreaMessageCommon_UserInteractionInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.likeCnt = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.commentCnt = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.shareCnt = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseGiftModeMeta() {
      return { giftId: "0", giftNameKey: "", giftIconImage: void 0, giftModeDesc: void 0 };
    }
    exports2.GiftModeMeta = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.giftId !== "0") {
          writer.uint32(8).int64(message.giftId);
        }
        if (message.giftNameKey !== "") {
          writer.uint32(18).string(message.giftNameKey);
        }
        if (message.giftIconImage !== void 0) {
          exports2.Image.encode(message.giftIconImage, writer.uint32(26).fork()).join();
        }
        if (message.giftModeDesc !== void 0) {
          exports2.Text.encode(message.giftModeDesc, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseGiftModeMeta();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.giftId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.giftNameKey = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.giftIconImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.giftModeDesc = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBattleTeamUser() {
      return { userId: "0", score: "0", userIdStr: "" };
    }
    exports2.BattleTeamUser = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.score !== "0") {
          writer.uint32(16).int64(message.score);
        }
        if (message.userIdStr !== "") {
          writer.uint32(26).string(message.userIdStr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBattleTeamUser();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.score = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.userIdStr = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBattleSetting() {
      return {
        battleId: "0",
        startTimeMs: "0",
        duration: 0,
        channelId: "0",
        status: 0,
        inviteType: 0,
        giftModeMeta: void 0,
        battleType: 0,
        extraDurationSecond: "0",
        endTimeMs: "0"
      };
    }
    exports2.BattleSetting = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.battleId !== "0") {
          writer.uint32(8).int64(message.battleId);
        }
        if (message.startTimeMs !== "0") {
          writer.uint32(16).int64(message.startTimeMs);
        }
        if (message.duration !== 0) {
          writer.uint32(24).int32(message.duration);
        }
        if (message.channelId !== "0") {
          writer.uint32(32).int64(message.channelId);
        }
        if (message.status !== 0) {
          writer.uint32(40).int32(message.status);
        }
        if (message.inviteType !== 0) {
          writer.uint32(48).int32(message.inviteType);
        }
        if (message.giftModeMeta !== void 0) {
          exports2.GiftModeMeta.encode(message.giftModeMeta, writer.uint32(58).fork()).join();
        }
        if (message.battleType !== 0) {
          writer.uint32(64).int32(message.battleType);
        }
        if (message.extraDurationSecond !== "0") {
          writer.uint32(72).int64(message.extraDurationSecond);
        }
        if (message.endTimeMs !== "0") {
          writer.uint32(80).int64(message.endTimeMs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBattleSetting();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.battleId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.startTimeMs = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.duration = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.channelId = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.status = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.inviteType = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.giftModeMeta = exports2.GiftModeMeta.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.battleType = reader.int32();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.extraDurationSecond = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.endTimeMs = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBattleTeamUserArmies() {
      return { teamId: "0", teamUsers: [], teamTotalScore: "0", userArmies: void 0, hostRank: "0" };
    }
    exports2.BattleTeamUserArmies = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.teamId !== "0") {
          writer.uint32(8).int64(message.teamId);
        }
        for (const v of message.teamUsers) {
          exports2.BattleTeamUser.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.teamTotalScore !== "0") {
          writer.uint32(24).int64(message.teamTotalScore);
        }
        if (message.userArmies !== void 0) {
          exports2.BattleUserArmies.encode(message.userArmies, writer.uint32(34).fork()).join();
        }
        if (message.hostRank !== "0") {
          writer.uint32(40).int64(message.hostRank);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBattleTeamUserArmies();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.teamId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.teamUsers.push(exports2.BattleTeamUser.decode(reader, reader.uint32()));
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.teamTotalScore = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.userArmies = exports2.BattleUserArmies.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.hostRank = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBattleUserArmies() {
      return { userArmy: [], hostScore: "0", anchorIdStr: "" };
    }
    exports2.BattleUserArmies = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.userArmy) {
          exports2.BattleUserArmy.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.hostScore !== "0") {
          writer.uint32(16).int64(message.hostScore);
        }
        if (message.anchorIdStr !== "") {
          writer.uint32(26).string(message.anchorIdStr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBattleUserArmies();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.userArmy.push(exports2.BattleUserArmy.decode(reader, reader.uint32()));
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.hostScore = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.anchorIdStr = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBattleUserArmy() {
      return { userId: "0", score: "0", nickname: "", avatarThumb: void 0, diamondScore: "0", userIdStr: "" };
    }
    exports2.BattleUserArmy = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.score !== "0") {
          writer.uint32(16).int64(message.score);
        }
        if (message.nickname !== "") {
          writer.uint32(26).string(message.nickname);
        }
        if (message.avatarThumb !== void 0) {
          exports2.Image.encode(message.avatarThumb, writer.uint32(34).fork()).join();
        }
        if (message.diamondScore !== "0") {
          writer.uint32(40).int64(message.diamondScore);
        }
        if (message.userIdStr !== "") {
          writer.uint32(50).string(message.userIdStr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBattleUserArmy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.score = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.nickname = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.avatarThumb = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.diamondScore = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.userIdStr = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseHighScoreControlCfg() {
      return { normalControlApplied: false, threshold: "0", originDisplayToUserList: [] };
    }
    exports2.HighScoreControlCfg = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.normalControlApplied !== false) {
          writer.uint32(8).bool(message.normalControlApplied);
        }
        if (message.threshold !== "0") {
          writer.uint32(16).int64(message.threshold);
        }
        writer.uint32(26).fork();
        for (const v of message.originDisplayToUserList) {
          writer.int64(v);
        }
        writer.join();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHighScoreControlCfg();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.normalControlApplied = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.threshold = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag === 24) {
                message.originDisplayToUserList.push(reader.int64().toString());
                continue;
              }
              if (tag === 26) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.originDisplayToUserList.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseHeartbeatMessage() {
      return { roomId: "0", sendPacketSeqId: "0" };
    }
    exports2.HeartbeatMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.roomId !== "0") {
          writer.uint32(8).uint64(message.roomId);
        }
        if (message.sendPacketSeqId !== "0") {
          writer.uint32(16).uint64(message.sendPacketSeqId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseHeartbeatMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.roomId = reader.uint64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.sendPacketSeqId = reader.uint64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastPushFrame() {
      return {
        seqId: "0",
        logId: "0",
        service: "0",
        method: "0",
        headers: {},
        payloadEncoding: "",
        payloadType: "",
        payload: new Uint8Array(0)
      };
    }
    exports2.WebcastPushFrame = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.seqId !== "0") {
          writer.uint32(8).int64(message.seqId);
        }
        if (message.logId !== "0") {
          writer.uint32(16).int64(message.logId);
        }
        if (message.service !== "0") {
          writer.uint32(24).int64(message.service);
        }
        if (message.method !== "0") {
          writer.uint32(32).int64(message.method);
        }
        Object.entries(message.headers).forEach(([key, value]) => {
          exports2.WebcastPushFrame_HeadersEntry.encode({ key, value }, writer.uint32(42).fork()).join();
        });
        if (message.payloadEncoding !== "") {
          writer.uint32(50).string(message.payloadEncoding);
        }
        if (message.payloadType !== "") {
          writer.uint32(58).string(message.payloadType);
        }
        if (message.payload.length !== 0) {
          writer.uint32(66).bytes(message.payload);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastPushFrame();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.seqId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.logId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.service = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.method = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              const entry5 = exports2.WebcastPushFrame_HeadersEntry.decode(reader, reader.uint32());
              if (entry5.value !== void 0) {
                message.headers[entry5.key] = entry5.value;
              }
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.payloadEncoding = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.payloadType = reader.string();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.payload = reader.bytes();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastPushFrame_HeadersEntry() {
      return { key: "", value: "" };
    }
    exports2.WebcastPushFrame_HeadersEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastPushFrame_HeadersEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseMessage() {
      return { type: "", binary: new Uint8Array(0) };
    }
    exports2.Message = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        if (message.binary.length !== 0) {
          writer.uint32(18).bytes(message.binary);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.type = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.binary = reader.bytes();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebsocketParam() {
      return { name: "", value: "" };
    }
    exports2.WebsocketParam = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebsocketParam();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.name = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastRoomUserSeqMessage() {
      return {
        common: void 0,
        viewerCount: 0,
        ranksList: [],
        popStr: "",
        seatsList: [],
        popularity: "0",
        totalUser: 0,
        anonymous: "0"
      };
    }
    exports2.WebcastRoomUserSeqMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.viewerCount !== 0) {
          writer.uint32(24).int32(message.viewerCount);
        }
        for (const v of message.ranksList) {
          exports2.WebcastRoomUserSeqMessage_Contributor.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.popStr !== "") {
          writer.uint32(34).string(message.popStr);
        }
        for (const v of message.seatsList) {
          exports2.WebcastRoomUserSeqMessage_Contributor.encode(v, writer.uint32(42).fork()).join();
        }
        if (message.popularity !== "0") {
          writer.uint32(48).int64(message.popularity);
        }
        if (message.totalUser !== 0) {
          writer.uint32(56).int32(message.totalUser);
        }
        if (message.anonymous !== "0") {
          writer.uint32(64).int64(message.anonymous);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastRoomUserSeqMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.viewerCount = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.ranksList.push(exports2.WebcastRoomUserSeqMessage_Contributor.decode(reader, reader.uint32()));
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.popStr = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.seatsList.push(exports2.WebcastRoomUserSeqMessage_Contributor.decode(reader, reader.uint32()));
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.popularity = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.totalUser = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.anonymous = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastRoomUserSeqMessage_Contributor() {
      return { coinCount: 0, user: void 0, rank: 0, delta: "0" };
    }
    exports2.WebcastRoomUserSeqMessage_Contributor = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.coinCount !== 0) {
          writer.uint32(8).int32(message.coinCount);
        }
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(18).fork()).join();
        }
        if (message.rank !== 0) {
          writer.uint32(24).int32(message.rank);
        }
        if (message.delta !== "0") {
          writer.uint32(32).int64(message.delta);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastRoomUserSeqMessage_Contributor();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.coinCount = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.rank = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.delta = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseImageModel() {
      return {
        mUrls: [],
        mUri: "",
        height: 0,
        width: 0,
        avgColor: "",
        imageType: 0,
        schema: "",
        content: void 0,
        isAnimated: false
      };
    }
    exports2.ImageModel = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.mUrls) {
          writer.uint32(10).string(v);
        }
        if (message.mUri !== "") {
          writer.uint32(18).string(message.mUri);
        }
        if (message.height !== 0) {
          writer.uint32(24).int32(message.height);
        }
        if (message.width !== 0) {
          writer.uint32(32).int32(message.width);
        }
        if (message.avgColor !== "") {
          writer.uint32(42).string(message.avgColor);
        }
        if (message.imageType !== 0) {
          writer.uint32(48).int32(message.imageType);
        }
        if (message.schema !== "") {
          writer.uint32(58).string(message.schema);
        }
        if (message.content !== void 0) {
          exports2.ImageModel_Content.encode(message.content, writer.uint32(66).fork()).join();
        }
        if (message.isAnimated !== false) {
          writer.uint32(72).bool(message.isAnimated);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseImageModel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.mUrls.push(reader.string());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.mUri = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.height = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.width = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.avgColor = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.imageType = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.schema = reader.string();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.content = exports2.ImageModel_Content.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.isAnimated = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseImageModel_Content() {
      return { name: "", fontColor: "", level: "0" };
    }
    exports2.ImageModel_Content = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.fontColor !== "") {
          writer.uint32(18).string(message.fontColor);
        }
        if (message.level !== "0") {
          writer.uint32(24).int64(message.level);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseImageModel_Content();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.name = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.fontColor = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.level = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastChatMessage() {
      return {
        common: void 0,
        user: void 0,
        comment: "",
        visibleToSender: false,
        background: void 0,
        fullScreenTextColor: "",
        backgroundImageV2: void 0,
        publicAreaCommon: void 0,
        giftImage: void 0,
        inputType: 0,
        atUser: void 0,
        emotes: [],
        contentLanguage: "",
        msgFilter: void 0,
        quickChatScene: 0,
        communityflaggedStatus: 0,
        commentQualityScores: [],
        userIdentity: void 0,
        commentTag: [],
        publicAreaMessageCommon: void 0,
        screenTime: "0",
        signature: "",
        signatureVersion: "",
        ecStreamerKey: ""
      };
    }
    exports2.WebcastChatMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(18).fork()).join();
        }
        if (message.comment !== "") {
          writer.uint32(26).string(message.comment);
        }
        if (message.visibleToSender !== false) {
          writer.uint32(32).bool(message.visibleToSender);
        }
        if (message.background !== void 0) {
          exports2.ImageModel.encode(message.background, writer.uint32(42).fork()).join();
        }
        if (message.fullScreenTextColor !== "") {
          writer.uint32(50).string(message.fullScreenTextColor);
        }
        if (message.backgroundImageV2 !== void 0) {
          exports2.ImageModel.encode(message.backgroundImageV2, writer.uint32(58).fork()).join();
        }
        if (message.publicAreaCommon !== void 0) {
          exports2.PublicAreaCommon.encode(message.publicAreaCommon, writer.uint32(74).fork()).join();
        }
        if (message.giftImage !== void 0) {
          exports2.ImageModel.encode(message.giftImage, writer.uint32(82).fork()).join();
        }
        if (message.inputType !== 0) {
          writer.uint32(88).int32(message.inputType);
        }
        if (message.atUser !== void 0) {
          exports2.User.encode(message.atUser, writer.uint32(98).fork()).join();
        }
        for (const v of message.emotes) {
          exports2.WebcastSubEmote.encode(v, writer.uint32(106).fork()).join();
        }
        if (message.contentLanguage !== "") {
          writer.uint32(114).string(message.contentLanguage);
        }
        if (message.msgFilter !== void 0) {
          exports2.MsgFilter.encode(message.msgFilter, writer.uint32(122).fork()).join();
        }
        if (message.quickChatScene !== 0) {
          writer.uint32(128).int32(message.quickChatScene);
        }
        if (message.communityflaggedStatus !== 0) {
          writer.uint32(136).int32(message.communityflaggedStatus);
        }
        for (const v of message.commentQualityScores) {
          exports2.WebcastChatMessage_CommentQualityScore.encode(v, writer.uint32(154).fork()).join();
        }
        if (message.userIdentity !== void 0) {
          exports2.WebcastChatMessage_UserIdentity.encode(message.userIdentity, writer.uint32(146).fork()).join();
        }
        writer.uint32(162).fork();
        for (const v of message.commentTag) {
          writer.int32(v);
        }
        writer.join();
        if (message.publicAreaMessageCommon !== void 0) {
          exports2.PublicAreaMessageCommon.encode(message.publicAreaMessageCommon, writer.uint32(170).fork()).join();
        }
        if (message.screenTime !== "0") {
          writer.uint32(176).int64(message.screenTime);
        }
        if (message.signature !== "") {
          writer.uint32(186).string(message.signature);
        }
        if (message.signatureVersion !== "") {
          writer.uint32(194).string(message.signatureVersion);
        }
        if (message.ecStreamerKey !== "") {
          writer.uint32(202).string(message.ecStreamerKey);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastChatMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.comment = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.visibleToSender = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.background = exports2.ImageModel.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.fullScreenTextColor = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.backgroundImageV2 = exports2.ImageModel.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.publicAreaCommon = exports2.PublicAreaCommon.decode(reader, reader.uint32());
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.giftImage = exports2.ImageModel.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.inputType = reader.int32();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.atUser = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.emotes.push(exports2.WebcastSubEmote.decode(reader, reader.uint32()));
              continue;
            }
            case 14: {
              if (tag !== 114) {
                break;
              }
              message.contentLanguage = reader.string();
              continue;
            }
            case 15: {
              if (tag !== 122) {
                break;
              }
              message.msgFilter = exports2.MsgFilter.decode(reader, reader.uint32());
              continue;
            }
            case 16: {
              if (tag !== 128) {
                break;
              }
              message.quickChatScene = reader.int32();
              continue;
            }
            case 17: {
              if (tag !== 136) {
                break;
              }
              message.communityflaggedStatus = reader.int32();
              continue;
            }
            case 19: {
              if (tag !== 154) {
                break;
              }
              message.commentQualityScores.push(exports2.WebcastChatMessage_CommentQualityScore.decode(reader, reader.uint32()));
              continue;
            }
            case 18: {
              if (tag !== 146) {
                break;
              }
              message.userIdentity = exports2.WebcastChatMessage_UserIdentity.decode(reader, reader.uint32());
              continue;
            }
            case 20: {
              if (tag === 160) {
                message.commentTag.push(reader.int32());
                continue;
              }
              if (tag === 162) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.commentTag.push(reader.int32());
                }
                continue;
              }
              break;
            }
            case 21: {
              if (tag !== 170) {
                break;
              }
              message.publicAreaMessageCommon = exports2.PublicAreaMessageCommon.decode(reader, reader.uint32());
              continue;
            }
            case 22: {
              if (tag !== 176) {
                break;
              }
              message.screenTime = reader.int64().toString();
              continue;
            }
            case 23: {
              if (tag !== 186) {
                break;
              }
              message.signature = reader.string();
              continue;
            }
            case 24: {
              if (tag !== 194) {
                break;
              }
              message.signatureVersion = reader.string();
              continue;
            }
            case 25: {
              if (tag !== 202) {
                break;
              }
              message.ecStreamerKey = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastChatMessage_UserIdentity() {
      return {
        isGiftGiverOfAnchor: false,
        isSubscriberOfAnchor: false,
        isMutualFollowingWithAnchor: false,
        isFollowerOfAnchor: false,
        isModeratorOfAnchor: false,
        isAnchor: false
      };
    }
    exports2.WebcastChatMessage_UserIdentity = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.isGiftGiverOfAnchor !== false) {
          writer.uint32(8).bool(message.isGiftGiverOfAnchor);
        }
        if (message.isSubscriberOfAnchor !== false) {
          writer.uint32(16).bool(message.isSubscriberOfAnchor);
        }
        if (message.isMutualFollowingWithAnchor !== false) {
          writer.uint32(24).bool(message.isMutualFollowingWithAnchor);
        }
        if (message.isFollowerOfAnchor !== false) {
          writer.uint32(32).bool(message.isFollowerOfAnchor);
        }
        if (message.isModeratorOfAnchor !== false) {
          writer.uint32(40).bool(message.isModeratorOfAnchor);
        }
        if (message.isAnchor !== false) {
          writer.uint32(48).bool(message.isAnchor);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastChatMessage_UserIdentity();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.isGiftGiverOfAnchor = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.isSubscriberOfAnchor = reader.bool();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.isMutualFollowingWithAnchor = reader.bool();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.isFollowerOfAnchor = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.isModeratorOfAnchor = reader.bool();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.isAnchor = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastChatMessage_CommentQualityScore() {
      return { version: "", score: "0" };
    }
    exports2.WebcastChatMessage_CommentQualityScore = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        if (message.score !== "0") {
          writer.uint32(16).int64(message.score);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastChatMessage_CommentQualityScore();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.version = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.score = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseEmoteUploadInfo() {
      return { userId: "0", emoteUploadSource: void 0, userInfo: void 0, userIdStr: "" };
    }
    exports2.EmoteUploadInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.emoteUploadSource !== void 0) {
          writer.uint32(16).int32(message.emoteUploadSource);
        }
        if (message.userInfo !== void 0) {
          exports2.User.encode(message.userInfo, writer.uint32(26).fork()).join();
        }
        if (message.userIdStr !== "") {
          writer.uint32(34).string(message.userIdStr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEmoteUploadInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.emoteUploadSource = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.userInfo = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.userIdStr = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastEmoteChatMessage() {
      return { common: void 0, user: void 0, emoteList: [], msgFilter: void 0, userIdentity: void 0 };
    }
    exports2.WebcastEmoteChatMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(18).fork()).join();
        }
        for (const v of message.emoteList) {
          exports2.Emote.encode(v, writer.uint32(26).fork()).join();
        }
        if (message.msgFilter !== void 0) {
          exports2.MsgFilter.encode(message.msgFilter, writer.uint32(34).fork()).join();
        }
        if (message.userIdentity !== void 0) {
          exports2.UserIdentity.encode(message.userIdentity, writer.uint32(42).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastEmoteChatMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.emoteList.push(exports2.Emote.decode(reader, reader.uint32()));
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.msgFilter = exports2.MsgFilter.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.userIdentity = exports2.UserIdentity.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastSubEmote() {
      return { placeInComment: 0, emote: void 0 };
    }
    exports2.WebcastSubEmote = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.placeInComment !== 0) {
          writer.uint32(8).int32(message.placeInComment);
        }
        if (message.emote !== void 0) {
          exports2.EmoteDetails.encode(message.emote, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastSubEmote();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.placeInComment = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.emote = exports2.EmoteDetails.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastMemberMessage() {
      return {
        common: void 0,
        user: void 0,
        action: 0,
        memberCount: 0,
        operator: void 0,
        isSetToAdmin: false,
        isTopUser: false,
        rankScore: "0",
        topUserNo: "0",
        enterType: "0",
        actionDescription: "",
        userId: "0",
        effectConfig: void 0,
        popStr: "",
        enterEffectConfig: void 0,
        backgroundImage: void 0,
        backgroundImageV2: void 0,
        anchorDisplayText: void 0,
        clientEnterSource: "",
        clientEnterType: "",
        clientLiveReason: "",
        actionDuration: "0",
        userShareType: "",
        displayStyle: 0,
        adminPermissions: {},
        kickSource: 0,
        allowPreviewTime: "0",
        lastSubscriptionAction: "0",
        publicAreaMessageCommon: void 0,
        liveSubOnlyTier: "0",
        liveSubOnlyMonth: "0",
        ecStreamerKey: "",
        showWave: "0",
        waveAlgorithmData: void 0,
        hitAbStatus: 0
      };
    }
    exports2.WebcastMemberMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(18).fork()).join();
        }
        if (message.action !== 0) {
          writer.uint32(80).int32(message.action);
        }
        if (message.memberCount !== 0) {
          writer.uint32(24).int32(message.memberCount);
        }
        if (message.operator !== void 0) {
          exports2.User.encode(message.operator, writer.uint32(34).fork()).join();
        }
        if (message.isSetToAdmin !== false) {
          writer.uint32(40).bool(message.isSetToAdmin);
        }
        if (message.isTopUser !== false) {
          writer.uint32(48).bool(message.isTopUser);
        }
        if (message.rankScore !== "0") {
          writer.uint32(56).int64(message.rankScore);
        }
        if (message.topUserNo !== "0") {
          writer.uint32(64).int64(message.topUserNo);
        }
        if (message.enterType !== "0") {
          writer.uint32(72).int64(message.enterType);
        }
        if (message.actionDescription !== "") {
          writer.uint32(90).string(message.actionDescription);
        }
        if (message.userId !== "0") {
          writer.uint32(96).int64(message.userId);
        }
        if (message.effectConfig !== void 0) {
          exports2.WebcastMemberMessage_EffectConfig.encode(message.effectConfig, writer.uint32(106).fork()).join();
        }
        if (message.popStr !== "") {
          writer.uint32(114).string(message.popStr);
        }
        if (message.enterEffectConfig !== void 0) {
          exports2.WebcastMemberMessage_EffectConfig.encode(message.enterEffectConfig, writer.uint32(122).fork()).join();
        }
        if (message.backgroundImage !== void 0) {
          exports2.Image.encode(message.backgroundImage, writer.uint32(130).fork()).join();
        }
        if (message.backgroundImageV2 !== void 0) {
          exports2.Image.encode(message.backgroundImageV2, writer.uint32(138).fork()).join();
        }
        if (message.anchorDisplayText !== void 0) {
          exports2.Text.encode(message.anchorDisplayText, writer.uint32(146).fork()).join();
        }
        if (message.clientEnterSource !== "") {
          writer.uint32(154).string(message.clientEnterSource);
        }
        if (message.clientEnterType !== "") {
          writer.uint32(162).string(message.clientEnterType);
        }
        if (message.clientLiveReason !== "") {
          writer.uint32(170).string(message.clientLiveReason);
        }
        if (message.actionDuration !== "0") {
          writer.uint32(176).int64(message.actionDuration);
        }
        if (message.userShareType !== "") {
          writer.uint32(186).string(message.userShareType);
        }
        if (message.displayStyle !== 0) {
          writer.uint32(192).int32(message.displayStyle);
        }
        Object.entries(message.adminPermissions).forEach(([key, value]) => {
          exports2.WebcastMemberMessage_AdminPermissionsEntry.encode({ key, value }, writer.uint32(202).fork()).join();
        });
        if (message.kickSource !== 0) {
          writer.uint32(208).int32(message.kickSource);
        }
        if (message.allowPreviewTime !== "0") {
          writer.uint32(216).int64(message.allowPreviewTime);
        }
        if (message.lastSubscriptionAction !== "0") {
          writer.uint32(224).int64(message.lastSubscriptionAction);
        }
        if (message.publicAreaMessageCommon !== void 0) {
          exports2.PublicAreaMessageCommon.encode(message.publicAreaMessageCommon, writer.uint32(234).fork()).join();
        }
        if (message.liveSubOnlyTier !== "0") {
          writer.uint32(240).int64(message.liveSubOnlyTier);
        }
        if (message.liveSubOnlyMonth !== "0") {
          writer.uint32(248).int64(message.liveSubOnlyMonth);
        }
        if (message.ecStreamerKey !== "") {
          writer.uint32(258).string(message.ecStreamerKey);
        }
        if (message.showWave !== "0") {
          writer.uint32(264).int64(message.showWave);
        }
        if (message.waveAlgorithmData !== void 0) {
          exports2.WebcastMemberMessage_WaveAlgorithmData.encode(message.waveAlgorithmData, writer.uint32(274).fork()).join();
        }
        if (message.hitAbStatus !== 0) {
          writer.uint32(280).int32(message.hitAbStatus);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastMemberMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.action = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.memberCount = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.operator = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.isSetToAdmin = reader.bool();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.isTopUser = reader.bool();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.rankScore = reader.int64().toString();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.topUserNo = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.enterType = reader.int64().toString();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.actionDescription = reader.string();
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.effectConfig = exports2.WebcastMemberMessage_EffectConfig.decode(reader, reader.uint32());
              continue;
            }
            case 14: {
              if (tag !== 114) {
                break;
              }
              message.popStr = reader.string();
              continue;
            }
            case 15: {
              if (tag !== 122) {
                break;
              }
              message.enterEffectConfig = exports2.WebcastMemberMessage_EffectConfig.decode(reader, reader.uint32());
              continue;
            }
            case 16: {
              if (tag !== 130) {
                break;
              }
              message.backgroundImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 17: {
              if (tag !== 138) {
                break;
              }
              message.backgroundImageV2 = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 18: {
              if (tag !== 146) {
                break;
              }
              message.anchorDisplayText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 19: {
              if (tag !== 154) {
                break;
              }
              message.clientEnterSource = reader.string();
              continue;
            }
            case 20: {
              if (tag !== 162) {
                break;
              }
              message.clientEnterType = reader.string();
              continue;
            }
            case 21: {
              if (tag !== 170) {
                break;
              }
              message.clientLiveReason = reader.string();
              continue;
            }
            case 22: {
              if (tag !== 176) {
                break;
              }
              message.actionDuration = reader.int64().toString();
              continue;
            }
            case 23: {
              if (tag !== 186) {
                break;
              }
              message.userShareType = reader.string();
              continue;
            }
            case 24: {
              if (tag !== 192) {
                break;
              }
              message.displayStyle = reader.int32();
              continue;
            }
            case 25: {
              if (tag !== 202) {
                break;
              }
              const entry25 = exports2.WebcastMemberMessage_AdminPermissionsEntry.decode(reader, reader.uint32());
              if (entry25.value !== void 0) {
                message.adminPermissions[entry25.key] = entry25.value;
              }
              continue;
            }
            case 26: {
              if (tag !== 208) {
                break;
              }
              message.kickSource = reader.int32();
              continue;
            }
            case 27: {
              if (tag !== 216) {
                break;
              }
              message.allowPreviewTime = reader.int64().toString();
              continue;
            }
            case 28: {
              if (tag !== 224) {
                break;
              }
              message.lastSubscriptionAction = reader.int64().toString();
              continue;
            }
            case 29: {
              if (tag !== 234) {
                break;
              }
              message.publicAreaMessageCommon = exports2.PublicAreaMessageCommon.decode(reader, reader.uint32());
              continue;
            }
            case 30: {
              if (tag !== 240) {
                break;
              }
              message.liveSubOnlyTier = reader.int64().toString();
              continue;
            }
            case 31: {
              if (tag !== 248) {
                break;
              }
              message.liveSubOnlyMonth = reader.int64().toString();
              continue;
            }
            case 32: {
              if (tag !== 258) {
                break;
              }
              message.ecStreamerKey = reader.string();
              continue;
            }
            case 33: {
              if (tag !== 264) {
                break;
              }
              message.showWave = reader.int64().toString();
              continue;
            }
            case 34: {
              if (tag !== 274) {
                break;
              }
              message.waveAlgorithmData = exports2.WebcastMemberMessage_WaveAlgorithmData.decode(reader, reader.uint32());
              continue;
            }
            case 35: {
              if (tag !== 280) {
                break;
              }
              message.hitAbStatus = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastMemberMessage_AdminPermissionsEntry() {
      return { key: 0, value: 0 };
    }
    exports2.WebcastMemberMessage_AdminPermissionsEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== 0) {
          writer.uint32(8).int32(message.key);
        }
        if (message.value !== 0) {
          writer.uint32(16).int32(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastMemberMessage_AdminPermissionsEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.value = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastMemberMessage_EffectConfig() {
      return {
        type: "0",
        icon: void 0,
        avatarPos: "0",
        text: void 0,
        textIcon: void 0,
        stayTime: 0,
        animAssetId: "0",
        badge: void 0,
        flexSettingArrayList: []
      };
    }
    exports2.WebcastMemberMessage_EffectConfig = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== "0") {
          writer.uint32(8).int64(message.type);
        }
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(18).fork()).join();
        }
        if (message.avatarPos !== "0") {
          writer.uint32(24).int64(message.avatarPos);
        }
        if (message.text !== void 0) {
          exports2.Text.encode(message.text, writer.uint32(34).fork()).join();
        }
        if (message.textIcon !== void 0) {
          exports2.Image.encode(message.textIcon, writer.uint32(42).fork()).join();
        }
        if (message.stayTime !== 0) {
          writer.uint32(48).int32(message.stayTime);
        }
        if (message.animAssetId !== "0") {
          writer.uint32(56).int64(message.animAssetId);
        }
        if (message.badge !== void 0) {
          exports2.Image.encode(message.badge, writer.uint32(66).fork()).join();
        }
        writer.uint32(74).fork();
        for (const v of message.flexSettingArrayList) {
          writer.int64(v);
        }
        writer.join();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastMemberMessage_EffectConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.type = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.avatarPos = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.text = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.textIcon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.stayTime = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.animAssetId = reader.int64().toString();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.badge = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag === 72) {
                message.flexSettingArrayList.push(reader.int64().toString());
                continue;
              }
              if (tag === 74) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.flexSettingArrayList.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastMemberMessage_WaveAlgorithmData() {
      return { algorithmVersion: "", isAlgHit: false, predictScore: "", isRewatch: false, isFollow: false };
    }
    exports2.WebcastMemberMessage_WaveAlgorithmData = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.algorithmVersion !== "") {
          writer.uint32(10).string(message.algorithmVersion);
        }
        if (message.isAlgHit !== false) {
          writer.uint32(16).bool(message.isAlgHit);
        }
        if (message.predictScore !== "") {
          writer.uint32(26).string(message.predictScore);
        }
        if (message.isRewatch !== false) {
          writer.uint32(32).bool(message.isRewatch);
        }
        if (message.isFollow !== false) {
          writer.uint32(40).bool(message.isFollow);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastMemberMessage_WaveAlgorithmData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.algorithmVersion = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.isAlgHit = reader.bool();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.predictScore = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.isRewatch = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.isFollow = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastMemberMessage_EffectConfigBean() {
      return { type: 0, icon: void 0, textKey: void 0, badge: void 0 };
    }
    exports2.WebcastMemberMessage_EffectConfigBean = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.icon !== void 0) {
          exports2.ImageModel.encode(message.icon, writer.uint32(18).fork()).join();
        }
        if (message.textKey !== void 0) {
          exports2.Text.encode(message.textKey, writer.uint32(34).fork()).join();
        }
        if (message.badge !== void 0) {
          exports2.ImageModel.encode(message.badge, writer.uint32(66).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastMemberMessage_EffectConfigBean();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.icon = exports2.ImageModel.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.textKey = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.badge = exports2.ImageModel.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage() {
      return {
        common: void 0,
        giftId: 0,
        user: void 0,
        repeatEnd: 0,
        groupId: "0",
        giftDetails: void 0,
        monitorExtra: "",
        fanTicketCount: "0",
        groupCount: 0,
        repeatCount: 0,
        comboCount: 0,
        toUser: void 0,
        textEffect: void 0,
        incomeTaskgifts: "0",
        roomFanTicketCount: "0",
        priority: void 0,
        logId: "",
        sendType: "0",
        publicAreaCommon: void 0,
        trayDisplayText: void 0,
        bannedDisplayEffects: "0",
        mTrayInfo: void 0,
        giftExtra: void 0,
        colorId: "0",
        isFirstSent: false,
        displayTextForAnchor: void 0,
        displayTextForAudience: void 0,
        orderId: "",
        giftsInBox: void 0,
        msgFilter: void 0,
        lynxExtra: [],
        userIdentity: void 0,
        matchInfo: void 0,
        linkmicGiftExpressionStrategy: 0,
        flyingMicResources: void 0,
        disableGiftTracking: false,
        asset: void 0,
        version: 0,
        sponsorshipInfo: [],
        flyingMicResourcesV2: void 0,
        publicAreaMessageCommon: void 0,
        signature: "",
        signatureVersion: "",
        multiGenerateMessage: false,
        toMemberId: "",
        toMemberIdInt: "0",
        toMemberNickname: "",
        interactiveGiftInfo: void 0
      };
    }
    exports2.WebcastGiftMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.giftId !== 0) {
          writer.uint32(16).int32(message.giftId);
        }
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(58).fork()).join();
        }
        if (message.repeatEnd !== 0) {
          writer.uint32(72).int32(message.repeatEnd);
        }
        if (message.groupId !== "0") {
          writer.uint32(88).uint64(message.groupId);
        }
        if (message.giftDetails !== void 0) {
          exports2.Gift.encode(message.giftDetails, writer.uint32(122).fork()).join();
        }
        if (message.monitorExtra !== "") {
          writer.uint32(178).string(message.monitorExtra);
        }
        if (message.fanTicketCount !== "0") {
          writer.uint32(24).int64(message.fanTicketCount);
        }
        if (message.groupCount !== 0) {
          writer.uint32(32).int32(message.groupCount);
        }
        if (message.repeatCount !== 0) {
          writer.uint32(40).int32(message.repeatCount);
        }
        if (message.comboCount !== 0) {
          writer.uint32(48).int32(message.comboCount);
        }
        if (message.toUser !== void 0) {
          exports2.User.encode(message.toUser, writer.uint32(66).fork()).join();
        }
        if (message.textEffect !== void 0) {
          exports2.WebcastGiftMessage_TextEffect.encode(message.textEffect, writer.uint32(82).fork()).join();
        }
        if (message.incomeTaskgifts !== "0") {
          writer.uint32(96).int64(message.incomeTaskgifts);
        }
        if (message.roomFanTicketCount !== "0") {
          writer.uint32(104).int64(message.roomFanTicketCount);
        }
        if (message.priority !== void 0) {
          exports2.WebcastGiftMessage_GiftIMPriority.encode(message.priority, writer.uint32(114).fork()).join();
        }
        if (message.logId !== "") {
          writer.uint32(130).string(message.logId);
        }
        if (message.sendType !== "0") {
          writer.uint32(136).int64(message.sendType);
        }
        if (message.publicAreaCommon !== void 0) {
          exports2.PublicAreaCommon.encode(message.publicAreaCommon, writer.uint32(146).fork()).join();
        }
        if (message.trayDisplayText !== void 0) {
          exports2.Text.encode(message.trayDisplayText, writer.uint32(154).fork()).join();
        }
        if (message.bannedDisplayEffects !== "0") {
          writer.uint32(160).int64(message.bannedDisplayEffects);
        }
        if (message.mTrayInfo !== void 0) {
          exports2.WebcastGiftMessage_GiftTrayInfo.encode(message.mTrayInfo, writer.uint32(170).fork()).join();
        }
        if (message.giftExtra !== void 0) {
          exports2.WebcastGiftMessage_GiftMonitorInfo.encode(message.giftExtra, writer.uint32(186).fork()).join();
        }
        if (message.colorId !== "0") {
          writer.uint32(192).int64(message.colorId);
        }
        if (message.isFirstSent !== false) {
          writer.uint32(200).bool(message.isFirstSent);
        }
        if (message.displayTextForAnchor !== void 0) {
          exports2.Text.encode(message.displayTextForAnchor, writer.uint32(210).fork()).join();
        }
        if (message.displayTextForAudience !== void 0) {
          exports2.Text.encode(message.displayTextForAudience, writer.uint32(218).fork()).join();
        }
        if (message.orderId !== "") {
          writer.uint32(226).string(message.orderId);
        }
        if (message.giftsInBox !== void 0) {
          exports2.WebcastGiftMessage_GiftsBoxInfo.encode(message.giftsInBox, writer.uint32(234).fork()).join();
        }
        if (message.msgFilter !== void 0) {
          exports2.MsgFilter.encode(message.msgFilter, writer.uint32(242).fork()).join();
        }
        for (const v of message.lynxExtra) {
          exports2.WebcastGiftMessage_LynxGiftExtra.encode(v, writer.uint32(250).fork()).join();
        }
        if (message.userIdentity !== void 0) {
          exports2.UserIdentity.encode(message.userIdentity, writer.uint32(258).fork()).join();
        }
        if (message.matchInfo !== void 0) {
          exports2.WebcastGiftMessage_MatchInfo.encode(message.matchInfo, writer.uint32(266).fork()).join();
        }
        if (message.linkmicGiftExpressionStrategy !== 0) {
          writer.uint32(272).int32(message.linkmicGiftExpressionStrategy);
        }
        if (message.flyingMicResources !== void 0) {
          exports2.WebcastGiftMessage_FlyingMicResources.encode(message.flyingMicResources, writer.uint32(282).fork()).join();
        }
        if (message.disableGiftTracking !== false) {
          writer.uint32(288).bool(message.disableGiftTracking);
        }
        if (message.asset !== void 0) {
          exports2.WebcastGiftMessage_AssetsModel.encode(message.asset, writer.uint32(298).fork()).join();
        }
        if (message.version !== 0) {
          writer.uint32(304).int32(message.version);
        }
        for (const v of message.sponsorshipInfo) {
          exports2.WebcastGiftMessage_SponsorshipInfo.encode(v, writer.uint32(314).fork()).join();
        }
        if (message.flyingMicResourcesV2 !== void 0) {
          exports2.WebcastGiftMessage_FlyingMicResources.encode(message.flyingMicResourcesV2, writer.uint32(322).fork()).join();
        }
        if (message.publicAreaMessageCommon !== void 0) {
          exports2.PublicAreaMessageCommon.encode(message.publicAreaMessageCommon, writer.uint32(330).fork()).join();
        }
        if (message.signature !== "") {
          writer.uint32(338).string(message.signature);
        }
        if (message.signatureVersion !== "") {
          writer.uint32(346).string(message.signatureVersion);
        }
        if (message.multiGenerateMessage !== false) {
          writer.uint32(352).bool(message.multiGenerateMessage);
        }
        if (message.toMemberId !== "") {
          writer.uint32(362).string(message.toMemberId);
        }
        if (message.toMemberIdInt !== "0") {
          writer.uint32(368).int64(message.toMemberIdInt);
        }
        if (message.toMemberNickname !== "") {
          writer.uint32(378).string(message.toMemberNickname);
        }
        if (message.interactiveGiftInfo !== void 0) {
          exports2.WebcastGiftMessage_InteractiveGiftInfo.encode(message.interactiveGiftInfo, writer.uint32(386).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.giftId = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.repeatEnd = reader.int32();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.groupId = reader.uint64().toString();
              continue;
            }
            case 15: {
              if (tag !== 122) {
                break;
              }
              message.giftDetails = exports2.Gift.decode(reader, reader.uint32());
              continue;
            }
            case 22: {
              if (tag !== 178) {
                break;
              }
              message.monitorExtra = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.fanTicketCount = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.groupCount = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.repeatCount = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.comboCount = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.toUser = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.textEffect = exports2.WebcastGiftMessage_TextEffect.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.incomeTaskgifts = reader.int64().toString();
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.roomFanTicketCount = reader.int64().toString();
              continue;
            }
            case 14: {
              if (tag !== 114) {
                break;
              }
              message.priority = exports2.WebcastGiftMessage_GiftIMPriority.decode(reader, reader.uint32());
              continue;
            }
            case 16: {
              if (tag !== 130) {
                break;
              }
              message.logId = reader.string();
              continue;
            }
            case 17: {
              if (tag !== 136) {
                break;
              }
              message.sendType = reader.int64().toString();
              continue;
            }
            case 18: {
              if (tag !== 146) {
                break;
              }
              message.publicAreaCommon = exports2.PublicAreaCommon.decode(reader, reader.uint32());
              continue;
            }
            case 19: {
              if (tag !== 154) {
                break;
              }
              message.trayDisplayText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 20: {
              if (tag !== 160) {
                break;
              }
              message.bannedDisplayEffects = reader.int64().toString();
              continue;
            }
            case 21: {
              if (tag !== 170) {
                break;
              }
              message.mTrayInfo = exports2.WebcastGiftMessage_GiftTrayInfo.decode(reader, reader.uint32());
              continue;
            }
            case 23: {
              if (tag !== 186) {
                break;
              }
              message.giftExtra = exports2.WebcastGiftMessage_GiftMonitorInfo.decode(reader, reader.uint32());
              continue;
            }
            case 24: {
              if (tag !== 192) {
                break;
              }
              message.colorId = reader.int64().toString();
              continue;
            }
            case 25: {
              if (tag !== 200) {
                break;
              }
              message.isFirstSent = reader.bool();
              continue;
            }
            case 26: {
              if (tag !== 210) {
                break;
              }
              message.displayTextForAnchor = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 27: {
              if (tag !== 218) {
                break;
              }
              message.displayTextForAudience = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 28: {
              if (tag !== 226) {
                break;
              }
              message.orderId = reader.string();
              continue;
            }
            case 29: {
              if (tag !== 234) {
                break;
              }
              message.giftsInBox = exports2.WebcastGiftMessage_GiftsBoxInfo.decode(reader, reader.uint32());
              continue;
            }
            case 30: {
              if (tag !== 242) {
                break;
              }
              message.msgFilter = exports2.MsgFilter.decode(reader, reader.uint32());
              continue;
            }
            case 31: {
              if (tag !== 250) {
                break;
              }
              message.lynxExtra.push(exports2.WebcastGiftMessage_LynxGiftExtra.decode(reader, reader.uint32()));
              continue;
            }
            case 32: {
              if (tag !== 258) {
                break;
              }
              message.userIdentity = exports2.UserIdentity.decode(reader, reader.uint32());
              continue;
            }
            case 33: {
              if (tag !== 266) {
                break;
              }
              message.matchInfo = exports2.WebcastGiftMessage_MatchInfo.decode(reader, reader.uint32());
              continue;
            }
            case 34: {
              if (tag !== 272) {
                break;
              }
              message.linkmicGiftExpressionStrategy = reader.int32();
              continue;
            }
            case 35: {
              if (tag !== 282) {
                break;
              }
              message.flyingMicResources = exports2.WebcastGiftMessage_FlyingMicResources.decode(reader, reader.uint32());
              continue;
            }
            case 36: {
              if (tag !== 288) {
                break;
              }
              message.disableGiftTracking = reader.bool();
              continue;
            }
            case 37: {
              if (tag !== 298) {
                break;
              }
              message.asset = exports2.WebcastGiftMessage_AssetsModel.decode(reader, reader.uint32());
              continue;
            }
            case 38: {
              if (tag !== 304) {
                break;
              }
              message.version = reader.int32();
              continue;
            }
            case 39: {
              if (tag !== 314) {
                break;
              }
              message.sponsorshipInfo.push(exports2.WebcastGiftMessage_SponsorshipInfo.decode(reader, reader.uint32()));
              continue;
            }
            case 40: {
              if (tag !== 322) {
                break;
              }
              message.flyingMicResourcesV2 = exports2.WebcastGiftMessage_FlyingMicResources.decode(reader, reader.uint32());
              continue;
            }
            case 41: {
              if (tag !== 330) {
                break;
              }
              message.publicAreaMessageCommon = exports2.PublicAreaMessageCommon.decode(reader, reader.uint32());
              continue;
            }
            case 42: {
              if (tag !== 338) {
                break;
              }
              message.signature = reader.string();
              continue;
            }
            case 43: {
              if (tag !== 346) {
                break;
              }
              message.signatureVersion = reader.string();
              continue;
            }
            case 44: {
              if (tag !== 352) {
                break;
              }
              message.multiGenerateMessage = reader.bool();
              continue;
            }
            case 45: {
              if (tag !== 362) {
                break;
              }
              message.toMemberId = reader.string();
              continue;
            }
            case 46: {
              if (tag !== 368) {
                break;
              }
              message.toMemberIdInt = reader.int64().toString();
              continue;
            }
            case 47: {
              if (tag !== 378) {
                break;
              }
              message.toMemberNickname = reader.string();
              continue;
            }
            case 48: {
              if (tag !== 386) {
                break;
              }
              message.interactiveGiftInfo = exports2.WebcastGiftMessage_InteractiveGiftInfo.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_InteractiveGiftInfo() {
      return { crossScreenDelay: "0", crossScreenRole: "0", ignoreConfig: 0, uniqId: "0", toUserTeamId: "0" };
    }
    exports2.WebcastGiftMessage_InteractiveGiftInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.crossScreenDelay !== "0") {
          writer.uint32(8).int64(message.crossScreenDelay);
        }
        if (message.crossScreenRole !== "0") {
          writer.uint32(16).int64(message.crossScreenRole);
        }
        if (message.ignoreConfig !== 0) {
          writer.uint32(24).int32(message.ignoreConfig);
        }
        if (message.uniqId !== "0") {
          writer.uint32(32).int64(message.uniqId);
        }
        if (message.toUserTeamId !== "0") {
          writer.uint32(40).int64(message.toUserTeamId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_InteractiveGiftInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.crossScreenDelay = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.crossScreenRole = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.ignoreConfig = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.uniqId = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.toUserTeamId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_GiftIMPriority() {
      return { queueSizesList: [], selfQueuePriority: "0", priority: "0" };
    }
    exports2.WebcastGiftMessage_GiftIMPriority = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        writer.uint32(10).fork();
        for (const v of message.queueSizesList) {
          writer.int64(v);
        }
        writer.join();
        if (message.selfQueuePriority !== "0") {
          writer.uint32(16).int64(message.selfQueuePriority);
        }
        if (message.priority !== "0") {
          writer.uint32(24).int64(message.priority);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_GiftIMPriority();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag === 8) {
                message.queueSizesList.push(reader.int64().toString());
                continue;
              }
              if (tag === 10) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.queueSizesList.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.selfQueuePriority = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.priority = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_TextEffect() {
      return { portraitDetail: void 0, landscapeDetail: void 0 };
    }
    exports2.WebcastGiftMessage_TextEffect = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.portraitDetail !== void 0) {
          exports2.WebcastGiftMessage_TextEffect_Detail.encode(message.portraitDetail, writer.uint32(10).fork()).join();
        }
        if (message.landscapeDetail !== void 0) {
          exports2.WebcastGiftMessage_TextEffect_Detail.encode(message.landscapeDetail, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_TextEffect();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.portraitDetail = exports2.WebcastGiftMessage_TextEffect_Detail.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.landscapeDetail = exports2.WebcastGiftMessage_TextEffect_Detail.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_TextEffect_Detail() {
      return {
        text: void 0,
        textFontSize: 0,
        background: void 0,
        start: "0",
        duration: "0",
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        shadowDx: 0,
        shadowDy: 0,
        shadowRadius: 0,
        shadowColor: "",
        strokeColor: "",
        strokeWidth: 0
      };
    }
    exports2.WebcastGiftMessage_TextEffect_Detail = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.text !== void 0) {
          exports2.Text.encode(message.text, writer.uint32(10).fork()).join();
        }
        if (message.textFontSize !== 0) {
          writer.uint32(16).int32(message.textFontSize);
        }
        if (message.background !== void 0) {
          exports2.Image.encode(message.background, writer.uint32(26).fork()).join();
        }
        if (message.start !== "0") {
          writer.uint32(32).int64(message.start);
        }
        if (message.duration !== "0") {
          writer.uint32(40).int64(message.duration);
        }
        if (message.x !== 0) {
          writer.uint32(48).int32(message.x);
        }
        if (message.y !== 0) {
          writer.uint32(56).int32(message.y);
        }
        if (message.width !== 0) {
          writer.uint32(64).int32(message.width);
        }
        if (message.height !== 0) {
          writer.uint32(72).int32(message.height);
        }
        if (message.shadowDx !== 0) {
          writer.uint32(80).int32(message.shadowDx);
        }
        if (message.shadowDy !== 0) {
          writer.uint32(88).int32(message.shadowDy);
        }
        if (message.shadowRadius !== 0) {
          writer.uint32(96).int32(message.shadowRadius);
        }
        if (message.shadowColor !== "") {
          writer.uint32(106).string(message.shadowColor);
        }
        if (message.strokeColor !== "") {
          writer.uint32(114).string(message.strokeColor);
        }
        if (message.strokeWidth !== 0) {
          writer.uint32(120).int32(message.strokeWidth);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_TextEffect_Detail();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.text = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.textFontSize = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.background = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.start = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.duration = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.x = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.y = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.width = reader.int32();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.height = reader.int32();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.shadowDx = reader.int32();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.shadowDy = reader.int32();
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.shadowRadius = reader.int32();
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.shadowColor = reader.string();
              continue;
            }
            case 14: {
              if (tag !== 114) {
                break;
              }
              message.strokeColor = reader.string();
              continue;
            }
            case 15: {
              if (tag !== 120) {
                break;
              }
              message.strokeWidth = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_GiftTrayInfo() {
      return {
        mDynamicImg: void 0,
        canMirror: false,
        trayNormalBgImg: void 0,
        trayNormalBgColor: [],
        traySmallBgImg: void 0,
        traySmallBgColor: [],
        rightTagText: void 0,
        rightTagBgImg: void 0,
        rightTagBgColor: [],
        trayNameTextColor: "",
        trayDescTextColor: "",
        rightTagJumpSchema: ""
      };
    }
    exports2.WebcastGiftMessage_GiftTrayInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.mDynamicImg !== void 0) {
          exports2.Image.encode(message.mDynamicImg, writer.uint32(10).fork()).join();
        }
        if (message.canMirror !== false) {
          writer.uint32(16).bool(message.canMirror);
        }
        if (message.trayNormalBgImg !== void 0) {
          exports2.Image.encode(message.trayNormalBgImg, writer.uint32(26).fork()).join();
        }
        for (const v of message.trayNormalBgColor) {
          writer.uint32(34).string(v);
        }
        if (message.traySmallBgImg !== void 0) {
          exports2.Image.encode(message.traySmallBgImg, writer.uint32(42).fork()).join();
        }
        for (const v of message.traySmallBgColor) {
          writer.uint32(50).string(v);
        }
        if (message.rightTagText !== void 0) {
          exports2.Text.encode(message.rightTagText, writer.uint32(58).fork()).join();
        }
        if (message.rightTagBgImg !== void 0) {
          exports2.Image.encode(message.rightTagBgImg, writer.uint32(66).fork()).join();
        }
        for (const v of message.rightTagBgColor) {
          writer.uint32(74).string(v);
        }
        if (message.trayNameTextColor !== "") {
          writer.uint32(82).string(message.trayNameTextColor);
        }
        if (message.trayDescTextColor !== "") {
          writer.uint32(90).string(message.trayDescTextColor);
        }
        if (message.rightTagJumpSchema !== "") {
          writer.uint32(98).string(message.rightTagJumpSchema);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_GiftTrayInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.mDynamicImg = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.canMirror = reader.bool();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.trayNormalBgImg = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.trayNormalBgColor.push(reader.string());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.traySmallBgImg = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.traySmallBgColor.push(reader.string());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.rightTagText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.rightTagBgImg = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.rightTagBgColor.push(reader.string());
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.trayNameTextColor = reader.string();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.trayDescTextColor = reader.string();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.rightTagJumpSchema = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_GiftMonitorInfo() {
      return {
        anchorId: "0",
        profitApiMessageDur: "0",
        sendGiftProfitApiStartMs: "0",
        sendGiftProfitCoreStartMs: "0",
        sendGiftReqStartMs: "0",
        sendGiftSendMessageSuccessMs: "0",
        sendProfitApiDur: "0",
        toUserId: "0",
        sendGiftStartClientLocalMs: "0",
        fromPlatform: "",
        fromVersion: ""
      };
    }
    exports2.WebcastGiftMessage_GiftMonitorInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.anchorId !== "0") {
          writer.uint32(8).int64(message.anchorId);
        }
        if (message.profitApiMessageDur !== "0") {
          writer.uint32(16).int64(message.profitApiMessageDur);
        }
        if (message.sendGiftProfitApiStartMs !== "0") {
          writer.uint32(24).int64(message.sendGiftProfitApiStartMs);
        }
        if (message.sendGiftProfitCoreStartMs !== "0") {
          writer.uint32(32).int64(message.sendGiftProfitCoreStartMs);
        }
        if (message.sendGiftReqStartMs !== "0") {
          writer.uint32(40).int64(message.sendGiftReqStartMs);
        }
        if (message.sendGiftSendMessageSuccessMs !== "0") {
          writer.uint32(48).int64(message.sendGiftSendMessageSuccessMs);
        }
        if (message.sendProfitApiDur !== "0") {
          writer.uint32(56).int64(message.sendProfitApiDur);
        }
        if (message.toUserId !== "0") {
          writer.uint32(64).int64(message.toUserId);
        }
        if (message.sendGiftStartClientLocalMs !== "0") {
          writer.uint32(72).int64(message.sendGiftStartClientLocalMs);
        }
        if (message.fromPlatform !== "") {
          writer.uint32(82).string(message.fromPlatform);
        }
        if (message.fromVersion !== "") {
          writer.uint32(90).string(message.fromVersion);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_GiftMonitorInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.anchorId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.profitApiMessageDur = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.sendGiftProfitApiStartMs = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.sendGiftProfitCoreStartMs = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.sendGiftReqStartMs = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.sendGiftSendMessageSuccessMs = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.sendProfitApiDur = reader.int64().toString();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.toUserId = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.sendGiftStartClientLocalMs = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.fromPlatform = reader.string();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.fromVersion = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_MatchInfo() {
      return { critical: "0", effectCardInUse: false, multiplierType: 0, multiplierValue: "0" };
    }
    exports2.WebcastGiftMessage_MatchInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.critical !== "0") {
          writer.uint32(8).int64(message.critical);
        }
        if (message.effectCardInUse !== false) {
          writer.uint32(16).bool(message.effectCardInUse);
        }
        if (message.multiplierType !== 0) {
          writer.uint32(24).int32(message.multiplierType);
        }
        if (message.multiplierValue !== "0") {
          writer.uint32(32).int64(message.multiplierValue);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_MatchInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.critical = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.effectCardInUse = reader.bool();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.multiplierType = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.multiplierValue = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_GiftsBoxInfo() {
      return { gifts: [] };
    }
    exports2.WebcastGiftMessage_GiftsBoxInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.gifts) {
          exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_GiftsBoxInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.gifts.push(exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox() {
      return { giftId: "0", effectId: "0", colorId: "0", remainTimes: 0, asset: void 0 };
    }
    exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.giftId !== "0") {
          writer.uint32(8).int64(message.giftId);
        }
        if (message.effectId !== "0") {
          writer.uint32(16).int64(message.effectId);
        }
        if (message.colorId !== "0") {
          writer.uint32(24).int64(message.colorId);
        }
        if (message.remainTimes !== 0) {
          writer.uint32(32).int32(message.remainTimes);
        }
        if (message.asset !== void 0) {
          exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel.encode(message.asset, writer.uint32(42).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.giftId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.effectId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.colorId = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.remainTimes = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.asset = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel() {
      return {
        name: "",
        resourceUri: "",
        resourceModel: void 0,
        describe: "",
        id: "0",
        resourceType: 0,
        md5: "",
        size: "0",
        lokiExtraContent: void 0,
        downloadType: 0,
        resourceByteVC1Model: void 0,
        bytevc1Md5: "",
        videoResourceList: [],
        faceRecognitionArchiveMeta: void 0,
        lynxUrlSettingsKey: "",
        downgradeResourceType: 0,
        assetExtra: void 0,
        stickerAssetVariant: 0,
        immediateDownload: false,
        stickerAssetVariantReason: 0
      };
    }
    exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.resourceUri !== "") {
          writer.uint32(18).string(message.resourceUri);
        }
        if (message.resourceModel !== void 0) {
          exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel.encode(message.resourceModel, writer.uint32(34).fork()).join();
        }
        if (message.describe !== "") {
          writer.uint32(42).string(message.describe);
        }
        if (message.id !== "0") {
          writer.uint32(48).int64(message.id);
        }
        if (message.resourceType !== 0) {
          writer.uint32(56).int32(message.resourceType);
        }
        if (message.md5 !== "") {
          writer.uint32(66).string(message.md5);
        }
        if (message.size !== "0") {
          writer.uint32(72).int64(message.size);
        }
        if (message.lokiExtraContent !== void 0) {
          exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent.encode(message.lokiExtraContent, writer.uint32(82).fork()).join();
        }
        if (message.downloadType !== 0) {
          writer.uint32(208).int32(message.downloadType);
        }
        if (message.resourceByteVC1Model !== void 0) {
          exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel.encode(message.resourceByteVC1Model, writer.uint32(226).fork()).join();
        }
        if (message.bytevc1Md5 !== "") {
          writer.uint32(234).string(message.bytevc1Md5);
        }
        for (const v of message.videoResourceList) {
          exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource.encode(v, writer.uint32(242).fork()).join();
        }
        if (message.faceRecognitionArchiveMeta !== void 0) {
          exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta.encode(message.faceRecognitionArchiveMeta, writer.uint32(250).fork()).join();
        }
        if (message.lynxUrlSettingsKey !== "") {
          writer.uint32(258).string(message.lynxUrlSettingsKey);
        }
        if (message.downgradeResourceType !== 0) {
          writer.uint32(264).int32(message.downgradeResourceType);
        }
        if (message.assetExtra !== void 0) {
          exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra.encode(message.assetExtra, writer.uint32(274).fork()).join();
        }
        if (message.stickerAssetVariant !== 0) {
          writer.uint32(280).int32(message.stickerAssetVariant);
        }
        if (message.immediateDownload !== false) {
          writer.uint32(288).bool(message.immediateDownload);
        }
        if (message.stickerAssetVariantReason !== 0) {
          writer.uint32(296).int32(message.stickerAssetVariantReason);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.name = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.resourceUri = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.resourceModel = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.describe = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.resourceType = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.md5 = reader.string();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.size = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.lokiExtraContent = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent.decode(reader, reader.uint32());
              continue;
            }
            case 26: {
              if (tag !== 208) {
                break;
              }
              message.downloadType = reader.int32();
              continue;
            }
            case 28: {
              if (tag !== 226) {
                break;
              }
              message.resourceByteVC1Model = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel.decode(reader, reader.uint32());
              continue;
            }
            case 29: {
              if (tag !== 234) {
                break;
              }
              message.bytevc1Md5 = reader.string();
              continue;
            }
            case 30: {
              if (tag !== 242) {
                break;
              }
              message.videoResourceList.push(exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource.decode(reader, reader.uint32()));
              continue;
            }
            case 31: {
              if (tag !== 250) {
                break;
              }
              message.faceRecognitionArchiveMeta = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta.decode(reader, reader.uint32());
              continue;
            }
            case 32: {
              if (tag !== 258) {
                break;
              }
              message.lynxUrlSettingsKey = reader.string();
              continue;
            }
            case 33: {
              if (tag !== 264) {
                break;
              }
              message.downgradeResourceType = reader.int32();
              continue;
            }
            case 34: {
              if (tag !== 274) {
                break;
              }
              message.assetExtra = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra.decode(reader, reader.uint32());
              continue;
            }
            case 35: {
              if (tag !== 280) {
                break;
              }
              message.stickerAssetVariant = reader.int32();
              continue;
            }
            case 36: {
              if (tag !== 288) {
                break;
              }
              message.immediateDownload = reader.bool();
              continue;
            }
            case 37: {
              if (tag !== 296) {
                break;
              }
              message.stickerAssetVariantReason = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra() {
      return { effectStarlingKey: "" };
    }
    exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.effectStarlingKey !== "") {
          writer.uint32(10).string(message.effectStarlingKey);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_AssetExtra();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.effectStarlingKey = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel() {
      return { urlList: [], uri: "" };
    }
    exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.urlList) {
          writer.uint32(10).string(v);
        }
        if (message.uri !== "") {
          writer.uint32(18).string(message.uri);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.urlList.push(reader.string());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.uri = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent() {
      return {
        giftType: "",
        giftDuration: "0",
        needScreenShot: false,
        ismultiFrame: false,
        viewOverlay: "",
        befViewRenderSize: void 0,
        befViewRenderFPS: 0,
        befViewFitMode: 0,
        modelNames: "",
        requirements: []
      };
    }
    exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.giftType !== "") {
          writer.uint32(10).string(message.giftType);
        }
        if (message.giftDuration !== "0") {
          writer.uint32(16).int64(message.giftDuration);
        }
        if (message.needScreenShot !== false) {
          writer.uint32(24).bool(message.needScreenShot);
        }
        if (message.ismultiFrame !== false) {
          writer.uint32(32).bool(message.ismultiFrame);
        }
        if (message.viewOverlay !== "") {
          writer.uint32(42).string(message.viewOverlay);
        }
        if (message.befViewRenderSize !== void 0) {
          exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize.encode(message.befViewRenderSize, writer.uint32(50).fork()).join();
        }
        if (message.befViewRenderFPS !== 0) {
          writer.uint32(56).int32(message.befViewRenderFPS);
        }
        if (message.befViewFitMode !== 0) {
          writer.uint32(64).int32(message.befViewFitMode);
        }
        if (message.modelNames !== "") {
          writer.uint32(74).string(message.modelNames);
        }
        for (const v of message.requirements) {
          writer.uint32(82).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.giftType = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.giftDuration = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.needScreenShot = reader.bool();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.ismultiFrame = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.viewOverlay = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.befViewRenderSize = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.befViewRenderFPS = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.befViewFitMode = reader.int32();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.modelNames = reader.string();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.requirements.push(reader.string());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize() {
      return { with: 0, height: 0 };
    }
    exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.with !== 0) {
          writer.uint32(8).int32(message.with);
        }
        if (message.height !== 0) {
          writer.uint32(16).int32(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_LokiExtraContent_BEFViewRenderSize();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.with = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.height = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource() {
      return { videoTypeName: "", videoUrl: void 0, videoMd5: "" };
    }
    exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.videoTypeName !== "") {
          writer.uint32(10).string(message.videoTypeName);
        }
        if (message.videoUrl !== void 0) {
          exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel.encode(message.videoUrl, writer.uint32(18).fork()).join();
        }
        if (message.videoMd5 !== "") {
          writer.uint32(26).string(message.videoMd5);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_VideoResource();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.videoTypeName = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.videoUrl = exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_ResourceModel.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.videoMd5 = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta() {
      return { version: "", requirements: [], modelNames: "", sdkExtra: "" };
    }
    exports2.WebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        for (const v of message.requirements) {
          writer.uint32(18).string(v);
        }
        if (message.modelNames !== "") {
          writer.uint32(26).string(message.modelNames);
        }
        if (message.sdkExtra !== "") {
          writer.uint32(34).string(message.sdkExtra);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_GiftsBoxInfo_GiftInfoInBox_AssetsModel_FaceRecognitionMeta();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.version = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.requirements.push(reader.string());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.modelNames = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.sdkExtra = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_AssetsModel() {
      return {
        name: "",
        resourceUri: "",
        resourceModel: void 0,
        describe: "",
        id: "0",
        resourceType: 0,
        md5: "",
        size: "0",
        lokiExtraContent: void 0,
        downloadType: 0,
        resourceByteVC1Model: void 0,
        bytevc1Md5: "",
        videoResourceList: [],
        faceRecognitionArchiveMeta: void 0,
        lynxUrlSettingsKey: "",
        downgradeResourceType: 0,
        assetExtra: void 0,
        stickerAssetVariant: 0,
        immediateDownload: false,
        stickerAssetVariantReason: 0
      };
    }
    exports2.WebcastGiftMessage_AssetsModel = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.resourceUri !== "") {
          writer.uint32(18).string(message.resourceUri);
        }
        if (message.resourceModel !== void 0) {
          exports2.WebcastGiftMessage_AssetsModel_ResourceModel.encode(message.resourceModel, writer.uint32(34).fork()).join();
        }
        if (message.describe !== "") {
          writer.uint32(42).string(message.describe);
        }
        if (message.id !== "0") {
          writer.uint32(48).int64(message.id);
        }
        if (message.resourceType !== 0) {
          writer.uint32(56).int32(message.resourceType);
        }
        if (message.md5 !== "") {
          writer.uint32(66).string(message.md5);
        }
        if (message.size !== "0") {
          writer.uint32(72).int64(message.size);
        }
        if (message.lokiExtraContent !== void 0) {
          exports2.WebcastGiftMessage_AssetsModel_LokiExtraContent.encode(message.lokiExtraContent, writer.uint32(82).fork()).join();
        }
        if (message.downloadType !== 0) {
          writer.uint32(208).int32(message.downloadType);
        }
        if (message.resourceByteVC1Model !== void 0) {
          exports2.WebcastGiftMessage_AssetsModel_ResourceModel.encode(message.resourceByteVC1Model, writer.uint32(226).fork()).join();
        }
        if (message.bytevc1Md5 !== "") {
          writer.uint32(234).string(message.bytevc1Md5);
        }
        for (const v of message.videoResourceList) {
          exports2.WebcastGiftMessage_AssetsModel_VideoResource.encode(v, writer.uint32(242).fork()).join();
        }
        if (message.faceRecognitionArchiveMeta !== void 0) {
          exports2.WebcastGiftMessage_AssetsModel_FaceRecognitionMeta.encode(message.faceRecognitionArchiveMeta, writer.uint32(250).fork()).join();
        }
        if (message.lynxUrlSettingsKey !== "") {
          writer.uint32(258).string(message.lynxUrlSettingsKey);
        }
        if (message.downgradeResourceType !== 0) {
          writer.uint32(264).int32(message.downgradeResourceType);
        }
        if (message.assetExtra !== void 0) {
          exports2.WebcastGiftMessage_AssetsModel_AssetExtra.encode(message.assetExtra, writer.uint32(274).fork()).join();
        }
        if (message.stickerAssetVariant !== 0) {
          writer.uint32(280).int32(message.stickerAssetVariant);
        }
        if (message.immediateDownload !== false) {
          writer.uint32(288).bool(message.immediateDownload);
        }
        if (message.stickerAssetVariantReason !== 0) {
          writer.uint32(296).int32(message.stickerAssetVariantReason);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_AssetsModel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.name = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.resourceUri = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.resourceModel = exports2.WebcastGiftMessage_AssetsModel_ResourceModel.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.describe = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.resourceType = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.md5 = reader.string();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.size = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.lokiExtraContent = exports2.WebcastGiftMessage_AssetsModel_LokiExtraContent.decode(reader, reader.uint32());
              continue;
            }
            case 26: {
              if (tag !== 208) {
                break;
              }
              message.downloadType = reader.int32();
              continue;
            }
            case 28: {
              if (tag !== 226) {
                break;
              }
              message.resourceByteVC1Model = exports2.WebcastGiftMessage_AssetsModel_ResourceModel.decode(reader, reader.uint32());
              continue;
            }
            case 29: {
              if (tag !== 234) {
                break;
              }
              message.bytevc1Md5 = reader.string();
              continue;
            }
            case 30: {
              if (tag !== 242) {
                break;
              }
              message.videoResourceList.push(exports2.WebcastGiftMessage_AssetsModel_VideoResource.decode(reader, reader.uint32()));
              continue;
            }
            case 31: {
              if (tag !== 250) {
                break;
              }
              message.faceRecognitionArchiveMeta = exports2.WebcastGiftMessage_AssetsModel_FaceRecognitionMeta.decode(reader, reader.uint32());
              continue;
            }
            case 32: {
              if (tag !== 258) {
                break;
              }
              message.lynxUrlSettingsKey = reader.string();
              continue;
            }
            case 33: {
              if (tag !== 264) {
                break;
              }
              message.downgradeResourceType = reader.int32();
              continue;
            }
            case 34: {
              if (tag !== 274) {
                break;
              }
              message.assetExtra = exports2.WebcastGiftMessage_AssetsModel_AssetExtra.decode(reader, reader.uint32());
              continue;
            }
            case 35: {
              if (tag !== 280) {
                break;
              }
              message.stickerAssetVariant = reader.int32();
              continue;
            }
            case 36: {
              if (tag !== 288) {
                break;
              }
              message.immediateDownload = reader.bool();
              continue;
            }
            case 37: {
              if (tag !== 296) {
                break;
              }
              message.stickerAssetVariantReason = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_AssetsModel_AssetExtra() {
      return { effectStarlingKey: "" };
    }
    exports2.WebcastGiftMessage_AssetsModel_AssetExtra = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.effectStarlingKey !== "") {
          writer.uint32(10).string(message.effectStarlingKey);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_AssetsModel_AssetExtra();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.effectStarlingKey = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_AssetsModel_ResourceModel() {
      return { urlList: [], uri: "" };
    }
    exports2.WebcastGiftMessage_AssetsModel_ResourceModel = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.urlList) {
          writer.uint32(10).string(v);
        }
        if (message.uri !== "") {
          writer.uint32(18).string(message.uri);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_AssetsModel_ResourceModel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.urlList.push(reader.string());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.uri = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_AssetsModel_LokiExtraContent() {
      return {
        giftType: "",
        giftDuration: "0",
        needScreenShot: false,
        ismultiFrame: false,
        viewOverlay: "",
        befViewRenderSize: void 0,
        befViewRenderFPS: 0,
        befViewFitMode: 0,
        modelNames: "",
        requirements: []
      };
    }
    exports2.WebcastGiftMessage_AssetsModel_LokiExtraContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.giftType !== "") {
          writer.uint32(10).string(message.giftType);
        }
        if (message.giftDuration !== "0") {
          writer.uint32(16).int64(message.giftDuration);
        }
        if (message.needScreenShot !== false) {
          writer.uint32(24).bool(message.needScreenShot);
        }
        if (message.ismultiFrame !== false) {
          writer.uint32(32).bool(message.ismultiFrame);
        }
        if (message.viewOverlay !== "") {
          writer.uint32(42).string(message.viewOverlay);
        }
        if (message.befViewRenderSize !== void 0) {
          exports2.WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize.encode(message.befViewRenderSize, writer.uint32(50).fork()).join();
        }
        if (message.befViewRenderFPS !== 0) {
          writer.uint32(56).int32(message.befViewRenderFPS);
        }
        if (message.befViewFitMode !== 0) {
          writer.uint32(64).int32(message.befViewFitMode);
        }
        if (message.modelNames !== "") {
          writer.uint32(74).string(message.modelNames);
        }
        for (const v of message.requirements) {
          writer.uint32(82).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_AssetsModel_LokiExtraContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.giftType = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.giftDuration = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.needScreenShot = reader.bool();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.ismultiFrame = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.viewOverlay = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.befViewRenderSize = exports2.WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.befViewRenderFPS = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.befViewFitMode = reader.int32();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.modelNames = reader.string();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.requirements.push(reader.string());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize() {
      return { with: 0, height: 0 };
    }
    exports2.WebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.with !== 0) {
          writer.uint32(8).int32(message.with);
        }
        if (message.height !== 0) {
          writer.uint32(16).int32(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_AssetsModel_LokiExtraContent_BEFViewRenderSize();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.with = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.height = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_AssetsModel_VideoResource() {
      return { videoTypeName: "", videoUrl: void 0, videoMd5: "" };
    }
    exports2.WebcastGiftMessage_AssetsModel_VideoResource = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.videoTypeName !== "") {
          writer.uint32(10).string(message.videoTypeName);
        }
        if (message.videoUrl !== void 0) {
          exports2.WebcastGiftMessage_AssetsModel_ResourceModel.encode(message.videoUrl, writer.uint32(18).fork()).join();
        }
        if (message.videoMd5 !== "") {
          writer.uint32(26).string(message.videoMd5);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_AssetsModel_VideoResource();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.videoTypeName = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.videoUrl = exports2.WebcastGiftMessage_AssetsModel_ResourceModel.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.videoMd5 = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_AssetsModel_FaceRecognitionMeta() {
      return { version: "", requirements: [], modelNames: "", sdkExtra: "" };
    }
    exports2.WebcastGiftMessage_AssetsModel_FaceRecognitionMeta = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.version !== "") {
          writer.uint32(10).string(message.version);
        }
        for (const v of message.requirements) {
          writer.uint32(18).string(v);
        }
        if (message.modelNames !== "") {
          writer.uint32(26).string(message.modelNames);
        }
        if (message.sdkExtra !== "") {
          writer.uint32(34).string(message.sdkExtra);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_AssetsModel_FaceRecognitionMeta();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.version = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.requirements.push(reader.string());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.modelNames = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.sdkExtra = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_LynxGiftExtra() {
      return { id: "0", code: "0", type: "0", params: [], extra: "" };
    }
    exports2.WebcastGiftMessage_LynxGiftExtra = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== "0") {
          writer.uint32(8).int64(message.id);
        }
        if (message.code !== "0") {
          writer.uint32(16).int64(message.code);
        }
        if (message.type !== "0") {
          writer.uint32(24).int64(message.type);
        }
        for (const v of message.params) {
          writer.uint32(34).string(v);
        }
        if (message.extra !== "") {
          writer.uint32(42).string(message.extra);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_LynxGiftExtra();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.code = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.type = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.params.push(reader.string());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.extra = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_FlyingMicResources() {
      return { pathImage: void 0, micImage: void 0, transitionConfigs: [] };
    }
    exports2.WebcastGiftMessage_FlyingMicResources = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.pathImage !== void 0) {
          exports2.Image.encode(message.pathImage, writer.uint32(10).fork()).join();
        }
        if (message.micImage !== void 0) {
          exports2.Image.encode(message.micImage, writer.uint32(18).fork()).join();
        }
        for (const v of message.transitionConfigs) {
          exports2.WebcastGiftMessage_FlyingMicResources_TransitionConfig.encode(v, writer.uint32(26).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_FlyingMicResources();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.pathImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.micImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.transitionConfigs.push(exports2.WebcastGiftMessage_FlyingMicResources_TransitionConfig.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_FlyingMicResources_TransitionConfig() {
      return { configId: "0", resourceImage: void 0 };
    }
    exports2.WebcastGiftMessage_FlyingMicResources_TransitionConfig = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.configId !== "0") {
          writer.uint32(8).int64(message.configId);
        }
        if (message.resourceImage !== void 0) {
          exports2.Image.encode(message.resourceImage, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_FlyingMicResources_TransitionConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.configId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.resourceImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGiftMessage_SponsorshipInfo() {
      return {
        giftId: "0",
        sponsorId: "0",
        lightGiftUp: false,
        unlightedGiftIcon: "",
        giftGalleryDetailPageSchemeUrl: "",
        giftGalleryClickSponsor: false,
        becomeAllSponsored: false
      };
    }
    exports2.WebcastGiftMessage_SponsorshipInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.giftId !== "0") {
          writer.uint32(8).int64(message.giftId);
        }
        if (message.sponsorId !== "0") {
          writer.uint32(16).int64(message.sponsorId);
        }
        if (message.lightGiftUp !== false) {
          writer.uint32(24).bool(message.lightGiftUp);
        }
        if (message.unlightedGiftIcon !== "") {
          writer.uint32(34).string(message.unlightedGiftIcon);
        }
        if (message.giftGalleryDetailPageSchemeUrl !== "") {
          writer.uint32(42).string(message.giftGalleryDetailPageSchemeUrl);
        }
        if (message.giftGalleryClickSponsor !== false) {
          writer.uint32(48).bool(message.giftGalleryClickSponsor);
        }
        if (message.becomeAllSponsored !== false) {
          writer.uint32(168).bool(message.becomeAllSponsored);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGiftMessage_SponsorshipInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.giftId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.sponsorId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.lightGiftUp = reader.bool();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.unlightedGiftIcon = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.giftGalleryDetailPageSchemeUrl = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.giftGalleryClickSponsor = reader.bool();
              continue;
            }
            case 21: {
              if (tag !== 168) {
                break;
              }
              message.becomeAllSponsored = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle() {
      return {
        common: void 0,
        battleId: "0",
        battleSetting: void 0,
        action: 0,
        battleResult: {},
        mBattleDisplayConfig: void 0,
        inviteeGiftPermissionType: 0,
        armies: {},
        anchorInfo: {},
        bubbleText: "",
        supportedActions: [],
        battleCombos: {},
        teamUsers: [],
        inviteeGiftPermissionTypes: [],
        actionByUserId: "0",
        teamBattleResult: [],
        teamArmies: [],
        abtestSettings: [],
        teamMatchCampaign: void 0,
        fuzzyDisplayConfigV2: void 0
      };
    }
    exports2.WebcastLinkMicBattle = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.battleId !== "0") {
          writer.uint32(16).int64(message.battleId);
        }
        if (message.battleSetting !== void 0) {
          exports2.BattleSetting.encode(message.battleSetting, writer.uint32(26).fork()).join();
        }
        if (message.action !== 0) {
          writer.uint32(32).int32(message.action);
        }
        Object.entries(message.battleResult).forEach(([key, value]) => {
          exports2.WebcastLinkMicBattle_BattleResultEntry.encode({ key, value }, writer.uint32(42).fork()).join();
        });
        if (message.mBattleDisplayConfig !== void 0) {
          exports2.WebcastLinkMicBattle_BattleDisplayConfig.encode(message.mBattleDisplayConfig, writer.uint32(50).fork()).join();
        }
        if (message.inviteeGiftPermissionType !== 0) {
          writer.uint32(64).int32(message.inviteeGiftPermissionType);
        }
        Object.entries(message.armies).forEach(([key, value]) => {
          exports2.WebcastLinkMicBattle_ArmiesEntry.encode({ key, value }, writer.uint32(74).fork()).join();
        });
        Object.entries(message.anchorInfo).forEach(([key, value]) => {
          exports2.WebcastLinkMicBattle_AnchorInfoEntry.encode({ key, value }, writer.uint32(82).fork()).join();
        });
        if (message.bubbleText !== "") {
          writer.uint32(90).string(message.bubbleText);
        }
        for (const v of message.supportedActions) {
          exports2.WebcastLinkMicBattle_SupportedActionsWrapper.encode(v, writer.uint32(98).fork()).join();
        }
        Object.entries(message.battleCombos).forEach(([key, value]) => {
          exports2.WebcastLinkMicBattle_BattleCombosEntry.encode({ key, value }, writer.uint32(106).fork()).join();
        });
        for (const v of message.teamUsers) {
          exports2.WebcastLinkMicBattle_TeamUsersInfo.encode(v, writer.uint32(114).fork()).join();
        }
        for (const v of message.inviteeGiftPermissionTypes) {
          exports2.WebcastLinkMicBattle_BattleInviteeGiftPermission.encode(v, writer.uint32(122).fork()).join();
        }
        if (message.actionByUserId !== "0") {
          writer.uint32(128).int64(message.actionByUserId);
        }
        for (const v of message.teamBattleResult) {
          exports2.WebcastLinkMicBattle_BattleTeamResult.encode(v, writer.uint32(138).fork()).join();
        }
        for (const v of message.teamArmies) {
          exports2.BattleTeamUserArmies.encode(v, writer.uint32(146).fork()).join();
        }
        for (const v of message.abtestSettings) {
          exports2.WebcastLinkMicBattle_BattleABTestSetting.encode(v, writer.uint32(154).fork()).join();
        }
        if (message.teamMatchCampaign !== void 0) {
          exports2.WebcastLinkMicBattle_TeamMatchCampaign.encode(message.teamMatchCampaign, writer.uint32(162).fork()).join();
        }
        if (message.fuzzyDisplayConfigV2 !== void 0) {
          exports2.HighScoreControlCfg.encode(message.fuzzyDisplayConfigV2, writer.uint32(170).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.battleId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.battleSetting = exports2.BattleSetting.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.action = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              const entry5 = exports2.WebcastLinkMicBattle_BattleResultEntry.decode(reader, reader.uint32());
              if (entry5.value !== void 0) {
                message.battleResult[entry5.key] = entry5.value;
              }
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.mBattleDisplayConfig = exports2.WebcastLinkMicBattle_BattleDisplayConfig.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.inviteeGiftPermissionType = reader.int32();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              const entry9 = exports2.WebcastLinkMicBattle_ArmiesEntry.decode(reader, reader.uint32());
              if (entry9.value !== void 0) {
                message.armies[entry9.key] = entry9.value;
              }
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              const entry10 = exports2.WebcastLinkMicBattle_AnchorInfoEntry.decode(reader, reader.uint32());
              if (entry10.value !== void 0) {
                message.anchorInfo[entry10.key] = entry10.value;
              }
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.bubbleText = reader.string();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.supportedActions.push(exports2.WebcastLinkMicBattle_SupportedActionsWrapper.decode(reader, reader.uint32()));
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              const entry13 = exports2.WebcastLinkMicBattle_BattleCombosEntry.decode(reader, reader.uint32());
              if (entry13.value !== void 0) {
                message.battleCombos[entry13.key] = entry13.value;
              }
              continue;
            }
            case 14: {
              if (tag !== 114) {
                break;
              }
              message.teamUsers.push(exports2.WebcastLinkMicBattle_TeamUsersInfo.decode(reader, reader.uint32()));
              continue;
            }
            case 15: {
              if (tag !== 122) {
                break;
              }
              message.inviteeGiftPermissionTypes.push(exports2.WebcastLinkMicBattle_BattleInviteeGiftPermission.decode(reader, reader.uint32()));
              continue;
            }
            case 16: {
              if (tag !== 128) {
                break;
              }
              message.actionByUserId = reader.int64().toString();
              continue;
            }
            case 17: {
              if (tag !== 138) {
                break;
              }
              message.teamBattleResult.push(exports2.WebcastLinkMicBattle_BattleTeamResult.decode(reader, reader.uint32()));
              continue;
            }
            case 18: {
              if (tag !== 146) {
                break;
              }
              message.teamArmies.push(exports2.BattleTeamUserArmies.decode(reader, reader.uint32()));
              continue;
            }
            case 19: {
              if (tag !== 154) {
                break;
              }
              message.abtestSettings.push(exports2.WebcastLinkMicBattle_BattleABTestSetting.decode(reader, reader.uint32()));
              continue;
            }
            case 20: {
              if (tag !== 162) {
                break;
              }
              message.teamMatchCampaign = exports2.WebcastLinkMicBattle_TeamMatchCampaign.decode(reader, reader.uint32());
              continue;
            }
            case 21: {
              if (tag !== 170) {
                break;
              }
              message.fuzzyDisplayConfigV2 = exports2.HighScoreControlCfg.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleResultEntry() {
      return { key: "0", value: void 0 };
    }
    exports2.WebcastLinkMicBattle_BattleResultEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "0") {
          writer.uint32(8).int64(message.key);
        }
        if (message.value !== void 0) {
          exports2.WebcastLinkMicBattle_BattleResult.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleResultEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = exports2.WebcastLinkMicBattle_BattleResult.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_ArmiesEntry() {
      return { key: "0", value: void 0 };
    }
    exports2.WebcastLinkMicBattle_ArmiesEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "0") {
          writer.uint32(8).int64(message.key);
        }
        if (message.value !== void 0) {
          exports2.BattleUserArmies.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_ArmiesEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = exports2.BattleUserArmies.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_AnchorInfoEntry() {
      return { key: "0", value: void 0 };
    }
    exports2.WebcastLinkMicBattle_AnchorInfoEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "0") {
          writer.uint32(8).int64(message.key);
        }
        if (message.value !== void 0) {
          exports2.WebcastLinkMicBattle_BattleUserInfo.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_AnchorInfoEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = exports2.WebcastLinkMicBattle_BattleUserInfo.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleCombosEntry() {
      return { key: "0", value: void 0 };
    }
    exports2.WebcastLinkMicBattle_BattleCombosEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "0") {
          writer.uint32(8).int64(message.key);
        }
        if (message.value !== void 0) {
          exports2.WebcastLinkMicBattle_BattleComboInfo.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleCombosEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = exports2.WebcastLinkMicBattle_BattleComboInfo.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_TeamMatchCampaign() {
      return { bestTeammateRelation: [], startSfxTeamId: [], hasTeamMatchMvpSfx: false };
    }
    exports2.WebcastLinkMicBattle_TeamMatchCampaign = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.bestTeammateRelation) {
          exports2.WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation.encode(v, writer.uint32(10).fork()).join();
        }
        writer.uint32(18).fork();
        for (const v of message.startSfxTeamId) {
          writer.int64(v);
        }
        writer.join();
        if (message.hasTeamMatchMvpSfx !== false) {
          writer.uint32(24).bool(message.hasTeamMatchMvpSfx);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_TeamMatchCampaign();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.bestTeammateRelation.push(exports2.WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation.decode(reader, reader.uint32()));
              continue;
            }
            case 2: {
              if (tag === 16) {
                message.startSfxTeamId.push(reader.int64().toString());
                continue;
              }
              if (tag === 18) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.startSfxTeamId.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.hasTeamMatchMvpSfx = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation() {
      return { userId: "0", bestTeammateId: "0" };
    }
    exports2.WebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.bestTeammateId !== "0") {
          writer.uint32(16).int64(message.bestTeammateId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_TeamMatchCampaign_BestTeammateRelation();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.bestTeammateId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleTeamResult() {
      return { teamId: "0", teamUsers: [], result: 0, totalScore: "0" };
    }
    exports2.WebcastLinkMicBattle_BattleTeamResult = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.teamId !== "0") {
          writer.uint32(8).int64(message.teamId);
        }
        for (const v of message.teamUsers) {
          exports2.BattleTeamUser.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.result !== 0) {
          writer.uint32(24).int32(message.result);
        }
        if (message.totalScore !== "0") {
          writer.uint32(32).int64(message.totalScore);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleTeamResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.teamId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.teamUsers.push(exports2.BattleTeamUser.decode(reader, reader.uint32()));
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.result = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.totalScore = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleInviteeGiftPermission() {
      return { userId: "0", giftPermissionType: 0 };
    }
    exports2.WebcastLinkMicBattle_BattleInviteeGiftPermission = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.giftPermissionType !== 0) {
          writer.uint32(16).int32(message.giftPermissionType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleInviteeGiftPermission();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.giftPermissionType = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_SupportedActionsWrapper() {
      return { actionType: "0" };
    }
    exports2.WebcastLinkMicBattle_SupportedActionsWrapper = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.actionType !== "0") {
          writer.uint32(8).int64(message.actionType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_SupportedActionsWrapper();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.actionType = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_TeamUsersInfo() {
      return { teamId: "0", userIds: [] };
    }
    exports2.WebcastLinkMicBattle_TeamUsersInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.teamId !== "0") {
          writer.uint32(8).int64(message.teamId);
        }
        writer.uint32(18).fork();
        for (const v of message.userIds) {
          writer.int64(v);
        }
        writer.join();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_TeamUsersInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.teamId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag === 16) {
                message.userIds.push(reader.int64().toString());
                continue;
              }
              if (tag === 18) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.userIds.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleComboInfo() {
      return { userId: "0", comboStatus: "0", comboCount: "0", comboIconUrl: "", comboType: 0, comboRuleGuideSchema: "" };
    }
    exports2.WebcastLinkMicBattle_BattleComboInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.comboStatus !== "0") {
          writer.uint32(16).int64(message.comboStatus);
        }
        if (message.comboCount !== "0") {
          writer.uint32(24).int64(message.comboCount);
        }
        if (message.comboIconUrl !== "") {
          writer.uint32(34).string(message.comboIconUrl);
        }
        if (message.comboType !== 0) {
          writer.uint32(40).int32(message.comboType);
        }
        if (message.comboRuleGuideSchema !== "") {
          writer.uint32(50).string(message.comboRuleGuideSchema);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleComboInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.comboStatus = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.comboCount = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.comboIconUrl = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.comboType = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.comboRuleGuideSchema = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleResult() {
      return { userId: "0", result: 0, score: "0" };
    }
    exports2.WebcastLinkMicBattle_BattleResult = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.result !== 0) {
          writer.uint32(16).int32(message.result);
        }
        if (message.score !== "0") {
          writer.uint32(24).int64(message.score);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.result = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.score = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleDisplayConfig() {
      return { threshold: 0, text: "", diffThreshold: 0, diffText: "", exemptStrategy: void 0 };
    }
    exports2.WebcastLinkMicBattle_BattleDisplayConfig = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.threshold !== 0) {
          writer.uint32(8).int32(message.threshold);
        }
        if (message.text !== "") {
          writer.uint32(18).string(message.text);
        }
        if (message.diffThreshold !== 0) {
          writer.uint32(24).int32(message.diffThreshold);
        }
        if (message.diffText !== "") {
          writer.uint32(34).string(message.diffText);
        }
        if (message.exemptStrategy !== void 0) {
          exports2.WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy.encode(message.exemptStrategy, writer.uint32(42).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleDisplayConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.threshold = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.text = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.diffThreshold = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.diffText = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.exemptStrategy = exports2.WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy() {
      return { exemptBothHost: false, exemptAudienceTop: 0 };
    }
    exports2.WebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.exemptBothHost !== false) {
          writer.uint32(8).bool(message.exemptBothHost);
        }
        if (message.exemptAudienceTop !== 0) {
          writer.uint32(16).int32(message.exemptAudienceTop);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleDisplayConfig_ExemptStrategy();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.exemptBothHost = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.exemptAudienceTop = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleUserInfo() {
      return { user: void 0, tags: [] };
    }
    exports2.WebcastLinkMicBattle_BattleUserInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.user !== void 0) {
          exports2.WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo.encode(message.user, writer.uint32(10).fork()).join();
        }
        for (const v of message.tags) {
          exports2.WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleUserInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.user = exports2.WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.tags.push(exports2.WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo() {
      return { userId: "0", nickName: "", avatarThumb: void 0, displayId: "" };
    }
    exports2.WebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.userId !== "0") {
          writer.uint32(8).int64(message.userId);
        }
        if (message.nickName !== "") {
          writer.uint32(18).string(message.nickName);
        }
        if (message.avatarThumb !== void 0) {
          exports2.Image.encode(message.avatarThumb, writer.uint32(26).fork()).join();
        }
        if (message.displayId !== "") {
          writer.uint32(34).string(message.displayId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleUserInfo_BattleBaseUserInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.nickName = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.avatarThumb = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.displayId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleUserInfo_BattleRivalTag() {
      return { bgImage: void 0, iconImage: void 0, content: "" };
    }
    exports2.WebcastLinkMicBattle_BattleUserInfo_BattleRivalTag = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.bgImage !== void 0) {
          exports2.Image.encode(message.bgImage, writer.uint32(10).fork()).join();
        }
        if (message.iconImage !== void 0) {
          exports2.Image.encode(message.iconImage, writer.uint32(18).fork()).join();
        }
        if (message.content !== "") {
          writer.uint32(26).string(message.content);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleUserInfo_BattleRivalTag();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.bgImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.iconImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.content = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleABTestSetting() {
      return { uid: "0", abTestList: void 0 };
    }
    exports2.WebcastLinkMicBattle_BattleABTestSetting = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.uid !== "0") {
          writer.uint32(8).int64(message.uid);
        }
        if (message.abTestList !== void 0) {
          exports2.WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList.encode(message.abTestList, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleABTestSetting();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.uid = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.abTestList = exports2.WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleABTestSetting_BattleABTestList() {
      return { abTestList: [] };
    }
    exports2.WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.abTestList) {
          exports2.WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleABTestSetting_BattleABTestList();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.abTestList.push(exports2.WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest() {
      return { abTestType: 0, group: 0 };
    }
    exports2.WebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.abTestType !== 0) {
          writer.uint32(8).int32(message.abTestType);
        }
        if (message.group !== 0) {
          writer.uint32(16).int32(message.group);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattle_BattleABTestSetting_BattleABTestList_BattleABTest();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.abTestType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.group = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicArmies() {
      return {
        common: void 0,
        battleId: "0",
        battleItems: {},
        channelId: "0",
        giftSentTime: "0",
        scoreUpdateTime: "0",
        battleStatus: 0,
        fromUserId: "0",
        giftId: "0",
        giftCount: 0,
        gifIconImage: void 0,
        totalDiamondCount: 0,
        repeatCount: 0,
        teamArmies: [],
        triggerCriticalStrike: false,
        hasTeamMatchMvpSfx: false,
        logId: "",
        battleSettings: void 0,
        fuzzyDisplayConfigV2: void 0
      };
    }
    exports2.WebcastLinkMicArmies = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.battleId !== "0") {
          writer.uint32(16).int64(message.battleId);
        }
        Object.entries(message.battleItems).forEach(([key, value]) => {
          exports2.WebcastLinkMicArmies_BattleItemsEntry.encode({ key, value }, writer.uint32(26).fork()).join();
        });
        if (message.channelId !== "0") {
          writer.uint32(32).int64(message.channelId);
        }
        if (message.giftSentTime !== "0") {
          writer.uint32(40).int64(message.giftSentTime);
        }
        if (message.scoreUpdateTime !== "0") {
          writer.uint32(48).int64(message.scoreUpdateTime);
        }
        if (message.battleStatus !== 0) {
          writer.uint32(56).int32(message.battleStatus);
        }
        if (message.fromUserId !== "0") {
          writer.uint32(64).int64(message.fromUserId);
        }
        if (message.giftId !== "0") {
          writer.uint32(72).int64(message.giftId);
        }
        if (message.giftCount !== 0) {
          writer.uint32(80).int32(message.giftCount);
        }
        if (message.gifIconImage !== void 0) {
          exports2.Image.encode(message.gifIconImage, writer.uint32(90).fork()).join();
        }
        if (message.totalDiamondCount !== 0) {
          writer.uint32(96).int32(message.totalDiamondCount);
        }
        if (message.repeatCount !== 0) {
          writer.uint32(104).int32(message.repeatCount);
        }
        for (const v of message.teamArmies) {
          exports2.BattleTeamUserArmies.encode(v, writer.uint32(114).fork()).join();
        }
        if (message.triggerCriticalStrike !== false) {
          writer.uint32(120).bool(message.triggerCriticalStrike);
        }
        if (message.hasTeamMatchMvpSfx !== false) {
          writer.uint32(128).bool(message.hasTeamMatchMvpSfx);
        }
        if (message.logId !== "") {
          writer.uint32(138).string(message.logId);
        }
        if (message.battleSettings !== void 0) {
          exports2.BattleSetting.encode(message.battleSettings, writer.uint32(146).fork()).join();
        }
        if (message.fuzzyDisplayConfigV2 !== void 0) {
          exports2.HighScoreControlCfg.encode(message.fuzzyDisplayConfigV2, writer.uint32(154).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicArmies();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.battleId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              const entry3 = exports2.WebcastLinkMicArmies_BattleItemsEntry.decode(reader, reader.uint32());
              if (entry3.value !== void 0) {
                message.battleItems[entry3.key] = entry3.value;
              }
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.channelId = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.giftSentTime = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.scoreUpdateTime = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.battleStatus = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.fromUserId = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.giftId = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.giftCount = reader.int32();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.gifIconImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.totalDiamondCount = reader.int32();
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.repeatCount = reader.int32();
              continue;
            }
            case 14: {
              if (tag !== 114) {
                break;
              }
              message.teamArmies.push(exports2.BattleTeamUserArmies.decode(reader, reader.uint32()));
              continue;
            }
            case 15: {
              if (tag !== 120) {
                break;
              }
              message.triggerCriticalStrike = reader.bool();
              continue;
            }
            case 16: {
              if (tag !== 128) {
                break;
              }
              message.hasTeamMatchMvpSfx = reader.bool();
              continue;
            }
            case 17: {
              if (tag !== 138) {
                break;
              }
              message.logId = reader.string();
              continue;
            }
            case 18: {
              if (tag !== 146) {
                break;
              }
              message.battleSettings = exports2.BattleSetting.decode(reader, reader.uint32());
              continue;
            }
            case 19: {
              if (tag !== 154) {
                break;
              }
              message.fuzzyDisplayConfigV2 = exports2.HighScoreControlCfg.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicArmies_BattleItemsEntry() {
      return { key: "0", value: void 0 };
    }
    exports2.WebcastLinkMicArmies_BattleItemsEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "0") {
          writer.uint32(8).int64(message.key);
        }
        if (message.value !== void 0) {
          exports2.BattleUserArmies.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicArmies_BattleItemsEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = exports2.BattleUserArmies.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicArmiesItems() {
      return { hostUserId: "0", battleGroups: [] };
    }
    exports2.WebcastLinkMicArmiesItems = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.hostUserId !== "0") {
          writer.uint32(8).uint64(message.hostUserId);
        }
        for (const v of message.battleGroups) {
          exports2.WebcastLinkMicArmiesGroup.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicArmiesItems();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.hostUserId = reader.uint64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.battleGroups.push(exports2.WebcastLinkMicArmiesGroup.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicArmiesGroup() {
      return { users: [], points: 0 };
    }
    exports2.WebcastLinkMicArmiesGroup = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.users) {
          exports2.User.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.points !== 0) {
          writer.uint32(16).int32(message.points);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicArmiesGroup();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.users.push(exports2.User.decode(reader, reader.uint32()));
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.points = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastSocialMessage() {
      return {
        common: void 0,
        user: void 0,
        shareType: "0",
        action: "0",
        shareTarget: "",
        followCount: 0,
        shareDisplayStyle: "0",
        shareCount: 0,
        publicAreaMessageCommon: void 0,
        signature: "",
        signatureVersion: "",
        showDurationMs: "0"
      };
    }
    exports2.WebcastSocialMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(18).fork()).join();
        }
        if (message.shareType !== "0") {
          writer.uint32(24).int64(message.shareType);
        }
        if (message.action !== "0") {
          writer.uint32(32).int64(message.action);
        }
        if (message.shareTarget !== "") {
          writer.uint32(42).string(message.shareTarget);
        }
        if (message.followCount !== 0) {
          writer.uint32(48).int32(message.followCount);
        }
        if (message.shareDisplayStyle !== "0") {
          writer.uint32(56).int64(message.shareDisplayStyle);
        }
        if (message.shareCount !== 0) {
          writer.uint32(64).int32(message.shareCount);
        }
        if (message.publicAreaMessageCommon !== void 0) {
          exports2.PublicAreaMessageCommon.encode(message.publicAreaMessageCommon, writer.uint32(74).fork()).join();
        }
        if (message.signature !== "") {
          writer.uint32(82).string(message.signature);
        }
        if (message.signatureVersion !== "") {
          writer.uint32(90).string(message.signatureVersion);
        }
        if (message.showDurationMs !== "0") {
          writer.uint32(96).int64(message.showDurationMs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastSocialMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.shareType = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.action = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.shareTarget = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.followCount = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.shareDisplayStyle = reader.int64().toString();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.shareCount = reader.int32();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.publicAreaMessageCommon = exports2.PublicAreaMessageCommon.decode(reader, reader.uint32());
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.signature = reader.string();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.signatureVersion = reader.string();
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.showDurationMs = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLikeMessage() {
      return {
        common: void 0,
        likeCount: 0,
        totalLikeCount: 0,
        color: 0,
        user: void 0,
        icon: "",
        icons: [],
        specifiedDisplayText: [],
        effectCnt: "0",
        likeEffect: [],
        publicAreaMessageCommon: void 0,
        roomMessageHeatLevel: "0"
      };
    }
    exports2.WebcastLikeMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.likeCount !== 0) {
          writer.uint32(16).int32(message.likeCount);
        }
        if (message.totalLikeCount !== 0) {
          writer.uint32(24).int32(message.totalLikeCount);
        }
        if (message.color !== 0) {
          writer.uint32(32).int32(message.color);
        }
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(42).fork()).join();
        }
        if (message.icon !== "") {
          writer.uint32(50).string(message.icon);
        }
        for (const v of message.icons) {
          exports2.Image.encode(v, writer.uint32(58).fork()).join();
        }
        for (const v of message.specifiedDisplayText) {
          exports2.SpecifiedDisplayText.encode(v, writer.uint32(66).fork()).join();
        }
        if (message.effectCnt !== "0") {
          writer.uint32(72).int64(message.effectCnt);
        }
        for (const v of message.likeEffect) {
          exports2.LikeEffect.encode(v, writer.uint32(82).fork()).join();
        }
        if (message.publicAreaMessageCommon !== void 0) {
          exports2.PublicAreaMessageCommon.encode(message.publicAreaMessageCommon, writer.uint32(90).fork()).join();
        }
        if (message.roomMessageHeatLevel !== "0") {
          writer.uint32(96).int64(message.roomMessageHeatLevel);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLikeMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.likeCount = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.totalLikeCount = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.color = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.icon = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.icons.push(exports2.Image.decode(reader, reader.uint32()));
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.specifiedDisplayText.push(exports2.SpecifiedDisplayText.decode(reader, reader.uint32()));
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.effectCnt = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.likeEffect.push(exports2.LikeEffect.decode(reader, reader.uint32()));
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.publicAreaMessageCommon = exports2.PublicAreaMessageCommon.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.roomMessageHeatLevel = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseSpecifiedDisplayText() {
      return { uid: "0", displayText: void 0 };
    }
    exports2.SpecifiedDisplayText = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.uid !== "0") {
          writer.uint32(8).int64(message.uid);
        }
        if (message.displayText !== void 0) {
          exports2.Text.encode(message.displayText, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSpecifiedDisplayText();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.uid = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.displayText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseLikeEffect() {
      return { version: "0", effectCnt: "0", effectIntervalMs: "0", level: "0" };
    }
    exports2.LikeEffect = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.version !== "0") {
          writer.uint32(8).int64(message.version);
        }
        if (message.effectCnt !== "0") {
          writer.uint32(16).int64(message.effectCnt);
        }
        if (message.effectIntervalMs !== "0") {
          writer.uint32(24).int64(message.effectIntervalMs);
        }
        if (message.level !== "0") {
          writer.uint32(32).int64(message.level);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseLikeEffect();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.version = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.effectCnt = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.effectIntervalMs = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.level = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastQuestionNewMessage() {
      return { common: void 0, details: void 0 };
    }
    exports2.WebcastQuestionNewMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.details !== void 0) {
          exports2.WebcastQuestionNewMessage_Question.encode(message.details, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastQuestionNewMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.details = exports2.WebcastQuestionNewMessage_Question.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastQuestionNewMessage_Question() {
      return {
        questionId: "0",
        questionText: "",
        answerStatus: 0,
        createTime: "0",
        user: void 0,
        createFrom: 0,
        answerFrom: 0
      };
    }
    exports2.WebcastQuestionNewMessage_Question = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.questionId !== "0") {
          writer.uint32(8).int64(message.questionId);
        }
        if (message.questionText !== "") {
          writer.uint32(18).string(message.questionText);
        }
        if (message.answerStatus !== 0) {
          writer.uint32(24).int32(message.answerStatus);
        }
        if (message.createTime !== "0") {
          writer.uint32(32).int64(message.createTime);
        }
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(42).fork()).join();
        }
        if (message.createFrom !== 0) {
          writer.uint32(160).int32(message.createFrom);
        }
        if (message.answerFrom !== 0) {
          writer.uint32(168).int32(message.answerFrom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastQuestionNewMessage_Question();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.questionId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.questionText = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.answerStatus = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.createTime = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 20: {
              if (tag !== 160) {
                break;
              }
              message.createFrom = reader.int32();
              continue;
            }
            case 21: {
              if (tag !== 168) {
                break;
              }
              message.answerFrom = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastMessageEventDetails() {
      return { displayType: "", label: "" };
    }
    exports2.WebcastMessageEventDetails = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.displayType !== "") {
          writer.uint32(10).string(message.displayType);
        }
        if (message.label !== "") {
          writer.uint32(18).string(message.label);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastMessageEventDetails();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.displayType = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.label = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLiveIntroMessage() {
      return {
        common: void 0,
        roomId: "0",
        auditStatus: 0,
        description: "",
        host: void 0,
        introMode: 0,
        badges: [],
        language: ""
      };
    }
    exports2.WebcastLiveIntroMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.roomId !== "0") {
          writer.uint32(16).int64(message.roomId);
        }
        if (message.auditStatus !== 0) {
          writer.uint32(24).int32(message.auditStatus);
        }
        if (message.description !== "") {
          writer.uint32(34).string(message.description);
        }
        if (message.host !== void 0) {
          exports2.User.encode(message.host, writer.uint32(42).fork()).join();
        }
        if (message.introMode !== 0) {
          writer.uint32(48).int32(message.introMode);
        }
        for (const v of message.badges) {
          exports2.BadgeStruct.encode(v, writer.uint32(58).fork()).join();
        }
        if (message.language !== "") {
          writer.uint32(66).string(message.language);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLiveIntroMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.roomId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.auditStatus = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.description = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.host = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.introMode = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.badges.push(exports2.BadgeStruct.decode(reader, reader.uint32()));
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.language = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseSystemMessage() {
      return { description: "" };
    }
    exports2.SystemMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.description !== "") {
          writer.uint32(18).string(message.description);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseSystemMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.description = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseRankItem() {
      return { colour: "", id: "0" };
    }
    exports2.RankItem = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.colour !== "") {
          writer.uint32(10).string(message.colour);
        }
        if (message.id !== "0") {
          writer.uint32(32).uint64(message.id);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRankItem();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.colour = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.id = reader.uint64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastHourlyRankMessage() {
      return { data: void 0, common: void 0, data2: 0 };
    }
    exports2.WebcastHourlyRankMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.data !== void 0) {
          exports2.WebcastHourlyRankMessage_RankContainer.encode(message.data, writer.uint32(18).fork()).join();
        }
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.data2 !== 0) {
          writer.uint32(24).uint32(message.data2);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastHourlyRankMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.data = exports2.WebcastHourlyRankMessage_RankContainer.decode(reader, reader.uint32());
              continue;
            }
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.data2 = reader.uint32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastHourlyRankMessage_RankContainer() {
      return {
        data1: 0,
        rankingData: void 0,
        data2: 0,
        rankings: void 0,
        rankingData2: void 0,
        data3: 0,
        data4: 0
      };
    }
    exports2.WebcastHourlyRankMessage_RankContainer = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.data1 !== 0) {
          writer.uint32(8).uint32(message.data1);
        }
        if (message.rankingData !== void 0) {
          exports2.WebcastHourlyRankMessage_RankContainer_RankingData.encode(message.rankingData, writer.uint32(18).fork()).join();
        }
        if (message.data2 !== 0) {
          writer.uint32(24).uint32(message.data2);
        }
        if (message.rankings !== void 0) {
          exports2.Ranking.encode(message.rankings, writer.uint32(34).fork()).join();
        }
        if (message.rankingData2 !== void 0) {
          exports2.WebcastHourlyRankMessage_RankContainer_RankingData2.encode(message.rankingData2, writer.uint32(42).fork()).join();
        }
        if (message.data3 !== 0) {
          writer.uint32(48).uint32(message.data3);
        }
        if (message.data4 !== 0) {
          writer.uint32(56).uint32(message.data4);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastHourlyRankMessage_RankContainer();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.data1 = reader.uint32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.rankingData = exports2.WebcastHourlyRankMessage_RankContainer_RankingData.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.data2 = reader.uint32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.rankings = exports2.Ranking.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.rankingData2 = exports2.WebcastHourlyRankMessage_RankContainer_RankingData2.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.data3 = reader.uint32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.data4 = reader.uint32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastHourlyRankMessage_RankContainer_RankingData() {
      return { data1: 0, rankdata: void 0, data2: "" };
    }
    exports2.WebcastHourlyRankMessage_RankContainer_RankingData = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.data1 !== 0) {
          writer.uint32(8).uint32(message.data1);
        }
        if (message.rankdata !== void 0) {
          exports2.Ranking.encode(message.rankdata, writer.uint32(18).fork()).join();
        }
        if (message.data2 !== "") {
          writer.uint32(26).string(message.data2);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastHourlyRankMessage_RankContainer_RankingData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.data1 = reader.uint32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.rankdata = exports2.Ranking.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.data2 = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastHourlyRankMessage_RankContainer_RankingData2() {
      return { data1: 0, data2: 0, rankdata: void 0, data3: "", data4: 0, data5: 0 };
    }
    exports2.WebcastHourlyRankMessage_RankContainer_RankingData2 = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.data1 !== 0) {
          writer.uint32(8).uint32(message.data1);
        }
        if (message.data2 !== 0) {
          writer.uint32(16).uint32(message.data2);
        }
        if (message.rankdata !== void 0) {
          exports2.Ranking.encode(message.rankdata, writer.uint32(26).fork()).join();
        }
        if (message.data3 !== "") {
          writer.uint32(34).string(message.data3);
        }
        if (message.data4 !== 0) {
          writer.uint32(40).uint32(message.data4);
        }
        if (message.data5 !== 0) {
          writer.uint32(48).uint32(message.data5);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastHourlyRankMessage_RankContainer_RankingData2();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.data1 = reader.uint32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.data2 = reader.uint32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.rankdata = exports2.Ranking.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.data3 = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.data4 = reader.uint32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.data5 = reader.uint32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseEmoteDetails() {
      return { emoteId: "", image: void 0 };
    }
    exports2.EmoteDetails = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.emoteId !== "") {
          writer.uint32(10).string(message.emoteId);
        }
        if (message.image !== void 0) {
          exports2.EmoteImage.encode(message.image, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEmoteDetails();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.emoteId = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.image = exports2.EmoteImage.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseEmoteImage() {
      return { imageUrl: "" };
    }
    exports2.EmoteImage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.imageUrl !== "") {
          writer.uint32(10).string(message.imageUrl);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseEmoteImage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.imageUrl = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastEnvelopeMessage() {
      return { common: void 0, envelopeInfo: void 0, display: 0 };
    }
    exports2.WebcastEnvelopeMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.envelopeInfo !== void 0) {
          exports2.WebcastEnvelopeMessage_EnvelopeInfo.encode(message.envelopeInfo, writer.uint32(18).fork()).join();
        }
        if (message.display !== 0) {
          writer.uint32(24).int32(message.display);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastEnvelopeMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.envelopeInfo = exports2.WebcastEnvelopeMessage_EnvelopeInfo.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.display = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastEnvelopeMessage_EnvelopeInfo() {
      return {
        envelopeId: "",
        businessType: 0,
        envelopeIdc: "",
        sendUserName: "",
        diamondCount: 0,
        peopleCount: 0,
        unpackAt: 0,
        sendUserId: "",
        sendUserAvatar: void 0,
        createAt: "",
        roomId: "",
        followShowStatus: 0,
        skinId: 0
      };
    }
    exports2.WebcastEnvelopeMessage_EnvelopeInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.envelopeId !== "") {
          writer.uint32(10).string(message.envelopeId);
        }
        if (message.businessType !== 0) {
          writer.uint32(16).int32(message.businessType);
        }
        if (message.envelopeIdc !== "") {
          writer.uint32(26).string(message.envelopeIdc);
        }
        if (message.sendUserName !== "") {
          writer.uint32(34).string(message.sendUserName);
        }
        if (message.diamondCount !== 0) {
          writer.uint32(40).int32(message.diamondCount);
        }
        if (message.peopleCount !== 0) {
          writer.uint32(48).int32(message.peopleCount);
        }
        if (message.unpackAt !== 0) {
          writer.uint32(56).int32(message.unpackAt);
        }
        if (message.sendUserId !== "") {
          writer.uint32(66).string(message.sendUserId);
        }
        if (message.sendUserAvatar !== void 0) {
          exports2.Image.encode(message.sendUserAvatar, writer.uint32(74).fork()).join();
        }
        if (message.createAt !== "") {
          writer.uint32(82).string(message.createAt);
        }
        if (message.roomId !== "") {
          writer.uint32(90).string(message.roomId);
        }
        if (message.followShowStatus !== 0) {
          writer.uint32(96).int32(message.followShowStatus);
        }
        if (message.skinId !== 0) {
          writer.uint32(104).int32(message.skinId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastEnvelopeMessage_EnvelopeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.envelopeId = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.businessType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.envelopeIdc = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.sendUserName = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.diamondCount = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.peopleCount = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.unpackAt = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.sendUserId = reader.string();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.sendUserAvatar = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.createAt = reader.string();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.roomId = reader.string();
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.followShowStatus = reader.int32();
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.skinId = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseTreasureBoxData() {
      return { coins: 0, canOpen: 0, timestamp: "0" };
    }
    exports2.TreasureBoxData = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.coins !== 0) {
          writer.uint32(40).uint32(message.coins);
        }
        if (message.canOpen !== 0) {
          writer.uint32(48).uint32(message.canOpen);
        }
        if (message.timestamp !== "0") {
          writer.uint32(56).uint64(message.timestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseTreasureBoxData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.coins = reader.uint32();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.canOpen = reader.uint32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.timestamp = reader.uint64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseFollowInfo() {
      return { followingCount: 0, followerCount: 0, followStatus: 0, pushStatus: 0 };
    }
    exports2.FollowInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.followingCount !== 0) {
          writer.uint32(8).int32(message.followingCount);
        }
        if (message.followerCount !== 0) {
          writer.uint32(16).int32(message.followerCount);
        }
        if (message.followStatus !== 0) {
          writer.uint32(24).int32(message.followStatus);
        }
        if (message.pushStatus !== 0) {
          writer.uint32(32).int32(message.pushStatus);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseFollowInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.followingCount = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.followerCount = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.followStatus = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.pushStatus = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseProfilePicture() {
      return { urls: [] };
    }
    exports2.ProfilePicture = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.urls) {
          writer.uint32(10).string(v);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProfilePicture();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.urls.push(reader.string());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUserBadgesAttributes() {
      return { badgeSceneType: 0, imageBadges: [], badges: [], privilegeLogExtra: void 0 };
    }
    exports2.UserBadgesAttributes = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.badgeSceneType !== 0) {
          writer.uint32(24).int32(message.badgeSceneType);
        }
        for (const v of message.imageBadges) {
          exports2.UserImageBadge.encode(v, writer.uint32(162).fork()).join();
        }
        for (const v of message.badges) {
          exports2.UserBadge.encode(v, writer.uint32(170).fork()).join();
        }
        if (message.privilegeLogExtra !== void 0) {
          exports2.PrivilegeLogExtra.encode(message.privilegeLogExtra, writer.uint32(98).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUserBadgesAttributes();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.badgeSceneType = reader.int32();
              continue;
            }
            case 20: {
              if (tag !== 162) {
                break;
              }
              message.imageBadges.push(exports2.UserImageBadge.decode(reader, reader.uint32()));
              continue;
            }
            case 21: {
              if (tag !== 170) {
                break;
              }
              message.badges.push(exports2.UserBadge.decode(reader, reader.uint32()));
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.privilegeLogExtra = exports2.PrivilegeLogExtra.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUserBadge() {
      return { type: "", name: "" };
    }
    exports2.UserBadge = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== "") {
          writer.uint32(18).string(message.type);
        }
        if (message.name !== "") {
          writer.uint32(26).string(message.name);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUserBadge();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.type = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.name = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUserImageBadge() {
      return { displayType: 0, image: void 0 };
    }
    exports2.UserImageBadge = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.displayType !== 0) {
          writer.uint32(8).int32(message.displayType);
        }
        if (message.image !== void 0) {
          exports2.UserImageBadgeImage.encode(message.image, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUserImageBadge();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.displayType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.image = exports2.UserImageBadgeImage.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseUserImageBadgeImage() {
      return { url: "" };
    }
    exports2.UserImageBadgeImage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.url !== "") {
          writer.uint32(10).string(message.url);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseUserImageBadgeImage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.url = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessage() {
      return {
        common: void 0,
        event: void 0,
        msgType: void 0,
        icon: void 0,
        duration: "0",
        backGround: void 0,
        rightIcon: void 0,
        displayConfig: 0,
        galleryGiftId: "0",
        useMarquee: false,
        showType: void 0,
        renderType: void 0,
        leftIconDisplayType: void 0,
        ribbonAnimation: void 0,
        hybridUrl: "",
        schema: "",
        subType: "",
        privilegeLogExtra: void 0,
        content: void 0,
        scene: 0,
        control: void 0,
        rightLabel: void 0,
        badge: void 0,
        animationData: void 0,
        commonBarrageContent: void 0,
        userGradeParam: void 0,
        fansLevelParam: void 0,
        subscribeGiftParam: void 0,
        giftGalleryParams: void 0
      };
    }
    exports2.WebcastBarrageMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.event !== void 0) {
          exports2.WebcastBarrageMessage_BarrageEvent.encode(message.event, writer.uint32(18).fork()).join();
        }
        if (message.msgType !== void 0) {
          writer.uint32(24).int32(message.msgType);
        }
        if (message.icon !== void 0) {
          exports2.ImageModel.encode(message.icon, writer.uint32(34).fork()).join();
        }
        if (message.duration !== "0") {
          writer.uint32(48).int64(message.duration);
        }
        if (message.backGround !== void 0) {
          exports2.ImageModel.encode(message.backGround, writer.uint32(58).fork()).join();
        }
        if (message.rightIcon !== void 0) {
          exports2.ImageModel.encode(message.rightIcon, writer.uint32(66).fork()).join();
        }
        if (message.displayConfig !== 0) {
          writer.uint32(72).int32(message.displayConfig);
        }
        if (message.galleryGiftId !== "0") {
          writer.uint32(80).int64(message.galleryGiftId);
        }
        if (message.useMarquee !== false) {
          writer.uint32(112).bool(message.useMarquee);
        }
        if (message.showType !== void 0) {
          writer.uint32(120).int32(message.showType);
        }
        if (message.renderType !== void 0) {
          writer.uint32(136).int32(message.renderType);
        }
        if (message.leftIconDisplayType !== void 0) {
          writer.uint32(144).int32(message.leftIconDisplayType);
        }
        if (message.ribbonAnimation !== void 0) {
          exports2.ImageModel.encode(message.ribbonAnimation, writer.uint32(154).fork()).join();
        }
        if (message.hybridUrl !== "") {
          writer.uint32(170).string(message.hybridUrl);
        }
        if (message.schema !== "") {
          writer.uint32(178).string(message.schema);
        }
        if (message.subType !== "") {
          writer.uint32(186).string(message.subType);
        }
        if (message.privilegeLogExtra !== void 0) {
          exports2.PrivilegeLogExtra.encode(message.privilegeLogExtra, writer.uint32(826).fork()).join();
        }
        if (message.content !== void 0) {
          exports2.Text.encode(message.content, writer.uint32(42).fork()).join();
        }
        if (message.scene !== 0) {
          writer.uint32(88).int32(message.scene);
        }
        if (message.control !== void 0) {
          exports2.WebcastBarrageMessage_DisplayControl.encode(message.control, writer.uint32(98).fork()).join();
        }
        if (message.rightLabel !== void 0) {
          exports2.WebcastBarrageMessage_RightLabel.encode(message.rightLabel, writer.uint32(106).fork()).join();
        }
        if (message.badge !== void 0) {
          exports2.BadgeStruct.encode(message.badge, writer.uint32(130).fork()).join();
        }
        if (message.animationData !== void 0) {
          exports2.WebcastBarrageMessage_AnimationData.encode(message.animationData, writer.uint32(162).fork()).join();
        }
        if (message.commonBarrageContent !== void 0) {
          exports2.Text.encode(message.commonBarrageContent, writer.uint32(194).fork()).join();
        }
        if (message.userGradeParam !== void 0) {
          exports2.WebcastBarrageMessage_BarrageTypeUserGradeParam.encode(message.userGradeParam, writer.uint32(802).fork()).join();
        }
        if (message.fansLevelParam !== void 0) {
          exports2.WebcastBarrageMessage_BarrageTypeFansLevelParam.encode(message.fansLevelParam, writer.uint32(810).fork()).join();
        }
        if (message.subscribeGiftParam !== void 0) {
          exports2.WebcastBarrageMessage_BarrageTypeSubscribeGiftParam.encode(message.subscribeGiftParam, writer.uint32(818).fork()).join();
        }
        if (message.giftGalleryParams !== void 0) {
          exports2.WebcastBarrageMessage_BarrageTypeGiftGalleryParam.encode(message.giftGalleryParams, writer.uint32(834).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.event = exports2.WebcastBarrageMessage_BarrageEvent.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.msgType = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.icon = exports2.ImageModel.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.duration = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.backGround = exports2.ImageModel.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.rightIcon = exports2.ImageModel.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.displayConfig = reader.int32();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.galleryGiftId = reader.int64().toString();
              continue;
            }
            case 14: {
              if (tag !== 112) {
                break;
              }
              message.useMarquee = reader.bool();
              continue;
            }
            case 15: {
              if (tag !== 120) {
                break;
              }
              message.showType = reader.int32();
              continue;
            }
            case 17: {
              if (tag !== 136) {
                break;
              }
              message.renderType = reader.int32();
              continue;
            }
            case 18: {
              if (tag !== 144) {
                break;
              }
              message.leftIconDisplayType = reader.int32();
              continue;
            }
            case 19: {
              if (tag !== 154) {
                break;
              }
              message.ribbonAnimation = exports2.ImageModel.decode(reader, reader.uint32());
              continue;
            }
            case 21: {
              if (tag !== 170) {
                break;
              }
              message.hybridUrl = reader.string();
              continue;
            }
            case 22: {
              if (tag !== 178) {
                break;
              }
              message.schema = reader.string();
              continue;
            }
            case 23: {
              if (tag !== 186) {
                break;
              }
              message.subType = reader.string();
              continue;
            }
            case 103: {
              if (tag !== 826) {
                break;
              }
              message.privilegeLogExtra = exports2.PrivilegeLogExtra.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.content = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.scene = reader.int32();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.control = exports2.WebcastBarrageMessage_DisplayControl.decode(reader, reader.uint32());
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.rightLabel = exports2.WebcastBarrageMessage_RightLabel.decode(reader, reader.uint32());
              continue;
            }
            case 16: {
              if (tag !== 130) {
                break;
              }
              message.badge = exports2.BadgeStruct.decode(reader, reader.uint32());
              continue;
            }
            case 20: {
              if (tag !== 162) {
                break;
              }
              message.animationData = exports2.WebcastBarrageMessage_AnimationData.decode(reader, reader.uint32());
              continue;
            }
            case 24: {
              if (tag !== 194) {
                break;
              }
              message.commonBarrageContent = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 100: {
              if (tag !== 802) {
                break;
              }
              message.userGradeParam = exports2.WebcastBarrageMessage_BarrageTypeUserGradeParam.decode(reader, reader.uint32());
              continue;
            }
            case 101: {
              if (tag !== 810) {
                break;
              }
              message.fansLevelParam = exports2.WebcastBarrageMessage_BarrageTypeFansLevelParam.decode(reader, reader.uint32());
              continue;
            }
            case 102: {
              if (tag !== 818) {
                break;
              }
              message.subscribeGiftParam = exports2.WebcastBarrageMessage_BarrageTypeSubscribeGiftParam.decode(reader, reader.uint32());
              continue;
            }
            case 104: {
              if (tag !== 834) {
                break;
              }
              message.giftGalleryParams = exports2.WebcastBarrageMessage_BarrageTypeGiftGalleryParam.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessage_BarrageEvent() {
      return { eventName: "", params: {} };
    }
    exports2.WebcastBarrageMessage_BarrageEvent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.eventName !== "") {
          writer.uint32(10).string(message.eventName);
        }
        Object.entries(message.params).forEach(([key, value]) => {
          exports2.WebcastBarrageMessage_BarrageEvent_ParamsEntry.encode({ key, value }, writer.uint32(18).fork()).join();
        });
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessage_BarrageEvent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.eventName = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              const entry2 = exports2.WebcastBarrageMessage_BarrageEvent_ParamsEntry.decode(reader, reader.uint32());
              if (entry2.value !== void 0) {
                message.params[entry2.key] = entry2.value;
              }
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessage_BarrageEvent_ParamsEntry() {
      return { key: "", value: "" };
    }
    exports2.WebcastBarrageMessage_BarrageEvent_ParamsEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessage_BarrageEvent_ParamsEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessage_BarrageTypeUserGradeParam() {
      return { currentGrade: 0, displayConfig: 0, userId: "", user: void 0 };
    }
    exports2.WebcastBarrageMessage_BarrageTypeUserGradeParam = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.currentGrade !== 0) {
          writer.uint32(8).int32(message.currentGrade);
        }
        if (message.displayConfig !== 0) {
          writer.uint32(16).int32(message.displayConfig);
        }
        if (message.userId !== "") {
          writer.uint32(26).string(message.userId);
        }
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessage_BarrageTypeUserGradeParam();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.currentGrade = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.displayConfig = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.userId = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessage_BarrageTypeFansLevelParam() {
      return { currentGrade: 0, displayConfig: 0, user: void 0 };
    }
    exports2.WebcastBarrageMessage_BarrageTypeFansLevelParam = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.currentGrade !== 0) {
          writer.uint32(8).int32(message.currentGrade);
        }
        if (message.displayConfig !== 0) {
          writer.uint32(16).int32(message.displayConfig);
        }
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessage_BarrageTypeFansLevelParam();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.currentGrade = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.displayConfig = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessage_BarrageTypeSubscribeGiftParam() {
      return { giftSubCount: "0", showGiftSubCount: false };
    }
    exports2.WebcastBarrageMessage_BarrageTypeSubscribeGiftParam = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.giftSubCount !== "0") {
          writer.uint32(8).int64(message.giftSubCount);
        }
        if (message.showGiftSubCount !== false) {
          writer.uint32(16).bool(message.showGiftSubCount);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessage_BarrageTypeSubscribeGiftParam();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.giftSubCount = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.showGiftSubCount = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessage_AnimationData() {
      return { geckoChannelName: "", fileName: "", height: "0", width: "0", rightOffset: "0" };
    }
    exports2.WebcastBarrageMessage_AnimationData = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.geckoChannelName !== "") {
          writer.uint32(10).string(message.geckoChannelName);
        }
        if (message.fileName !== "") {
          writer.uint32(18).string(message.fileName);
        }
        if (message.height !== "0") {
          writer.uint32(24).int64(message.height);
        }
        if (message.width !== "0") {
          writer.uint32(32).int64(message.width);
        }
        if (message.rightOffset !== "0") {
          writer.uint32(40).int64(message.rightOffset);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessage_AnimationData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.geckoChannelName = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.fileName = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.height = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.width = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.rightOffset = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessage_BarrageTypeGiftGalleryParam() {
      return { fromUserId: "0", toUserId: "0" };
    }
    exports2.WebcastBarrageMessage_BarrageTypeGiftGalleryParam = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.fromUserId !== "0") {
          writer.uint32(8).int64(message.fromUserId);
        }
        if (message.toUserId !== "0") {
          writer.uint32(16).int64(message.toUserId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessage_BarrageTypeGiftGalleryParam();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.fromUserId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.toUserId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessage_DisplayControl() {
      return { priority: 0, duration: "0", targetGroupShowRst: {}, horizontalTriggerType: 0 };
    }
    exports2.WebcastBarrageMessage_DisplayControl = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.priority !== 0) {
          writer.uint32(8).int32(message.priority);
        }
        if (message.duration !== "0") {
          writer.uint32(16).int64(message.duration);
        }
        Object.entries(message.targetGroupShowRst).forEach(([key, value]) => {
          exports2.WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry.encode({ key, value }, writer.uint32(26).fork()).join();
        });
        if (message.horizontalTriggerType !== 0) {
          writer.uint32(32).int32(message.horizontalTriggerType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessage_DisplayControl();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.priority = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.duration = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              const entry3 = exports2.WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry.decode(reader, reader.uint32());
              if (entry3.value !== void 0) {
                message.targetGroupShowRst[entry3.key] = entry3.value;
              }
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.horizontalTriggerType = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry() {
      return { key: 0, value: void 0 };
    }
    exports2.WebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== 0) {
          writer.uint32(8).int32(message.key);
        }
        if (message.value !== void 0) {
          exports2.WebcastBarrageMessage_DisplayControl_ShowResult.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessage_DisplayControl_TargetGroupShowRstEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = exports2.WebcastBarrageMessage_DisplayControl_ShowResult.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessage_DisplayControl_ShowResult() {
      return { banned: false };
    }
    exports2.WebcastBarrageMessage_DisplayControl_ShowResult = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.banned !== false) {
          writer.uint32(8).bool(message.banned);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessage_DisplayControl_ShowResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.banned = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessage_RightLabel() {
      return { backgroundColor: "", content: void 0, height: "0" };
    }
    exports2.WebcastBarrageMessage_RightLabel = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.backgroundColor !== "") {
          writer.uint32(10).string(message.backgroundColor);
        }
        if (message.content !== void 0) {
          exports2.Text.encode(message.content, writer.uint32(18).fork()).join();
        }
        if (message.height !== "0") {
          writer.uint32(24).int64(message.height);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessage_RightLabel();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.backgroundColor = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.content = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.height = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseProtoMessageFetchResult() {
      return {
        messages: [],
        cursor: "",
        fetchInterval: "0",
        now: "0",
        internalExt: "",
        fetchType: 0,
        wsParams: {},
        heartBeatDuration: 0,
        needsAck: false,
        wsUrl: "",
        isFirst: false,
        historyCommentCursor: "",
        historyNoMore: false
      };
    }
    exports2.ProtoMessageFetchResult = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.messages) {
          exports2.BaseProtoMessage.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.cursor !== "") {
          writer.uint32(18).string(message.cursor);
        }
        if (message.fetchInterval !== "0") {
          writer.uint32(24).int64(message.fetchInterval);
        }
        if (message.now !== "0") {
          writer.uint32(32).int64(message.now);
        }
        if (message.internalExt !== "") {
          writer.uint32(42).string(message.internalExt);
        }
        if (message.fetchType !== 0) {
          writer.uint32(48).int32(message.fetchType);
        }
        Object.entries(message.wsParams).forEach(([key, value]) => {
          exports2.ProtoMessageFetchResult_WsParamsEntry.encode({ key, value }, writer.uint32(58).fork()).join();
        });
        if (message.heartBeatDuration !== 0) {
          writer.uint32(64).int32(message.heartBeatDuration);
        }
        if (message.needsAck !== false) {
          writer.uint32(72).bool(message.needsAck);
        }
        if (message.wsUrl !== "") {
          writer.uint32(82).string(message.wsUrl);
        }
        if (message.isFirst !== false) {
          writer.uint32(88).bool(message.isFirst);
        }
        if (message.historyCommentCursor !== "") {
          writer.uint32(98).string(message.historyCommentCursor);
        }
        if (message.historyNoMore !== false) {
          writer.uint32(104).bool(message.historyNoMore);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProtoMessageFetchResult();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.messages.push(exports2.BaseProtoMessage.decode(reader, reader.uint32()));
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.cursor = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.fetchInterval = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.now = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.internalExt = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.fetchType = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              const entry7 = exports2.ProtoMessageFetchResult_WsParamsEntry.decode(reader, reader.uint32());
              if (entry7.value !== void 0) {
                message.wsParams[entry7.key] = entry7.value;
              }
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.heartBeatDuration = reader.int32();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.needsAck = reader.bool();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.wsUrl = reader.string();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.isFirst = reader.bool();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.historyCommentCursor = reader.string();
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.historyNoMore = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseProtoMessageFetchResult_WsParamsEntry() {
      return { key: "", value: "" };
    }
    exports2.ProtoMessageFetchResult_WsParamsEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
          writer.uint32(18).string(message.value);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseProtoMessageFetchResult_WsParamsEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseBaseProtoMessage() {
      return { type: "", payload: new Uint8Array(0), msgId: "0", msgType: 0, offset: "0", isHistory: false };
    }
    exports2.BaseProtoMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== "") {
          writer.uint32(10).string(message.type);
        }
        if (message.payload.length !== 0) {
          writer.uint32(18).bytes(message.payload);
        }
        if (message.msgId !== "0") {
          writer.uint32(24).int64(message.msgId);
        }
        if (message.msgType !== 0) {
          writer.uint32(32).int32(message.msgType);
        }
        if (message.offset !== "0") {
          writer.uint32(40).int64(message.offset);
        }
        if (message.isHistory !== false) {
          writer.uint32(48).bool(message.isHistory);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseBaseProtoMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.type = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.payload = reader.bytes();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.msgId = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.msgType = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.offset = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.isHistory = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastRoomMessage() {
      return {
        common: void 0,
        content: "",
        supportLandscape: false,
        source: "0",
        icon: void 0,
        scene: 0,
        isWelcome: false,
        publicAreaCommon: void 0,
        showDurationMs: "0",
        subScene: ""
      };
    }
    exports2.WebcastRoomMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.content !== "") {
          writer.uint32(18).string(message.content);
        }
        if (message.supportLandscape !== false) {
          writer.uint32(24).bool(message.supportLandscape);
        }
        if (message.source !== "0") {
          writer.uint32(32).int64(message.source);
        }
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(42).fork()).join();
        }
        if (message.scene !== 0) {
          writer.uint32(48).int32(message.scene);
        }
        if (message.isWelcome !== false) {
          writer.uint32(56).bool(message.isWelcome);
        }
        if (message.publicAreaCommon !== void 0) {
          exports2.PublicAreaMessageCommon.encode(message.publicAreaCommon, writer.uint32(66).fork()).join();
        }
        if (message.showDurationMs !== "0") {
          writer.uint32(72).int64(message.showDurationMs);
        }
        if (message.subScene !== "") {
          writer.uint32(82).string(message.subScene);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastRoomMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.content = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.supportLandscape = reader.bool();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.source = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.scene = reader.int32();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.isWelcome = reader.bool();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.publicAreaCommon = exports2.PublicAreaMessageCommon.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.showDurationMs = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.subScene = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastCaptionMessage() {
      return {
        common: void 0,
        timestampMs: "0",
        durationMs: "0",
        content: [],
        sentenceId: "0",
        sequenceId: "0",
        definite: false
      };
    }
    exports2.WebcastCaptionMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.timestampMs !== "0") {
          writer.uint32(16).int64(message.timestampMs);
        }
        if (message.durationMs !== "0") {
          writer.uint32(24).int64(message.durationMs);
        }
        for (const v of message.content) {
          exports2.WebcastCaptionMessage_CaptionContent.encode(v, writer.uint32(34).fork()).join();
        }
        if (message.sentenceId !== "0") {
          writer.uint32(40).int64(message.sentenceId);
        }
        if (message.sequenceId !== "0") {
          writer.uint32(48).int64(message.sequenceId);
        }
        if (message.definite !== false) {
          writer.uint32(56).bool(message.definite);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastCaptionMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.timestampMs = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.durationMs = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.content.push(exports2.WebcastCaptionMessage_CaptionContent.decode(reader, reader.uint32()));
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.sentenceId = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.sequenceId = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.definite = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastCaptionMessage_CaptionContent() {
      return { lang: "", content: "" };
    }
    exports2.WebcastCaptionMessage_CaptionContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.lang !== "") {
          writer.uint32(10).string(message.lang);
        }
        if (message.content !== "") {
          writer.uint32(18).string(message.content);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastCaptionMessage_CaptionContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.lang = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.content = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastControlMessage() {
      return {
        common: void 0,
        action: 0,
        tips: "",
        extra: void 0,
        perceptionDialog: void 0,
        perceptionAudienceText: void 0,
        punishInfo: void 0,
        floatText: void 0,
        floatStyle: 0
      };
    }
    exports2.WebcastControlMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.action !== 0) {
          writer.uint32(16).int32(message.action);
        }
        if (message.tips !== "") {
          writer.uint32(26).string(message.tips);
        }
        if (message.extra !== void 0) {
          exports2.WebcastControlMessage_Extra.encode(message.extra, writer.uint32(34).fork()).join();
        }
        if (message.perceptionDialog !== void 0) {
          exports2.WebcastControlMessage_PerceptionDialogInfo.encode(message.perceptionDialog, writer.uint32(42).fork()).join();
        }
        if (message.perceptionAudienceText !== void 0) {
          exports2.Text.encode(message.perceptionAudienceText, writer.uint32(50).fork()).join();
        }
        if (message.punishInfo !== void 0) {
          exports2.PunishEventInfo.encode(message.punishInfo, writer.uint32(58).fork()).join();
        }
        if (message.floatText !== void 0) {
          exports2.Text.encode(message.floatText, writer.uint32(66).fork()).join();
        }
        if (message.floatStyle !== 0) {
          writer.uint32(72).int32(message.floatStyle);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastControlMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.action = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.tips = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.extra = exports2.WebcastControlMessage_Extra.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.perceptionDialog = exports2.WebcastControlMessage_PerceptionDialogInfo.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.perceptionAudienceText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.punishInfo = exports2.PunishEventInfo.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.floatText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.floatStyle = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastControlMessage_Extra() {
      return {
        banInfoUrl: "",
        reasonNo: "0",
        title: void 0,
        violationReason: void 0,
        content: void 0,
        gotItButton: void 0,
        banDetailButton: void 0,
        source: ""
      };
    }
    exports2.WebcastControlMessage_Extra = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.banInfoUrl !== "") {
          writer.uint32(10).string(message.banInfoUrl);
        }
        if (message.reasonNo !== "0") {
          writer.uint32(16).int64(message.reasonNo);
        }
        if (message.title !== void 0) {
          exports2.Text.encode(message.title, writer.uint32(26).fork()).join();
        }
        if (message.violationReason !== void 0) {
          exports2.Text.encode(message.violationReason, writer.uint32(34).fork()).join();
        }
        if (message.content !== void 0) {
          exports2.Text.encode(message.content, writer.uint32(42).fork()).join();
        }
        if (message.gotItButton !== void 0) {
          exports2.Text.encode(message.gotItButton, writer.uint32(50).fork()).join();
        }
        if (message.banDetailButton !== void 0) {
          exports2.Text.encode(message.banDetailButton, writer.uint32(58).fork()).join();
        }
        if (message.source !== "") {
          writer.uint32(66).string(message.source);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastControlMessage_Extra();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.banInfoUrl = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.reasonNo = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.title = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.violationReason = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.content = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.gotItButton = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.banDetailButton = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.source = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastControlMessage_PerceptionDialogInfo() {
      return {
        iconType: 0,
        title: void 0,
        subTitle: void 0,
        adviceActionText: void 0,
        defaultActionText: void 0,
        violationDetailUrl: "",
        scene: 0,
        targetUserId: "0",
        targetRoomId: "0",
        countDownTime: "0",
        showFeedback: false,
        feedbackOptions: [],
        policyTip: "0",
        appealPopup: 0
      };
    }
    exports2.WebcastControlMessage_PerceptionDialogInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.iconType !== 0) {
          writer.uint32(8).int32(message.iconType);
        }
        if (message.title !== void 0) {
          exports2.Text.encode(message.title, writer.uint32(18).fork()).join();
        }
        if (message.subTitle !== void 0) {
          exports2.Text.encode(message.subTitle, writer.uint32(26).fork()).join();
        }
        if (message.adviceActionText !== void 0) {
          exports2.Text.encode(message.adviceActionText, writer.uint32(34).fork()).join();
        }
        if (message.defaultActionText !== void 0) {
          exports2.Text.encode(message.defaultActionText, writer.uint32(42).fork()).join();
        }
        if (message.violationDetailUrl !== "") {
          writer.uint32(50).string(message.violationDetailUrl);
        }
        if (message.scene !== 0) {
          writer.uint32(56).int32(message.scene);
        }
        if (message.targetUserId !== "0") {
          writer.uint32(64).int64(message.targetUserId);
        }
        if (message.targetRoomId !== "0") {
          writer.uint32(72).int64(message.targetRoomId);
        }
        if (message.countDownTime !== "0") {
          writer.uint32(80).int64(message.countDownTime);
        }
        if (message.showFeedback !== false) {
          writer.uint32(88).bool(message.showFeedback);
        }
        for (const v of message.feedbackOptions) {
          exports2.WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption.encode(v, writer.uint32(98).fork()).join();
        }
        if (message.policyTip !== "0") {
          writer.uint32(104).int64(message.policyTip);
        }
        if (message.appealPopup !== 0) {
          writer.uint32(112).int32(message.appealPopup);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastControlMessage_PerceptionDialogInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.iconType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.title = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.subTitle = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.adviceActionText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.defaultActionText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.violationDetailUrl = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.scene = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.targetUserId = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.targetRoomId = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.countDownTime = reader.int64().toString();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.showFeedback = reader.bool();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.feedbackOptions.push(exports2.WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption.decode(reader, reader.uint32()));
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.policyTip = reader.int64().toString();
              continue;
            }
            case 14: {
              if (tag !== 112) {
                break;
              }
              message.appealPopup = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption() {
      return { id: "0", contentKey: "" };
    }
    exports2.WebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id !== "0") {
          writer.uint32(8).int64(message.id);
        }
        if (message.contentKey !== "") {
          writer.uint32(18).string(message.contentKey);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastControlMessage_PerceptionDialogInfo_PerceptionFeedbackOption();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.contentKey = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGoalUpdateMessage() {
      return {
        common: void 0,
        indicator: void 0,
        goal: void 0,
        contributorId: "0",
        contributorAvatar: void 0,
        contributorDisplayId: "",
        contributeSubgoal: void 0,
        contributeCount: "0",
        contributeScore: "0",
        giftRepeatCount: "0",
        contributorIdStr: "",
        pin: false,
        unpin: false,
        pinInfo: void 0,
        updateSource: 0,
        goalExtra: ""
      };
    }
    exports2.WebcastGoalUpdateMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.indicator !== void 0) {
          exports2.LiveStreamGoalIndicator.encode(message.indicator, writer.uint32(18).fork()).join();
        }
        if (message.goal !== void 0) {
          exports2.LiveStreamGoal.encode(message.goal, writer.uint32(26).fork()).join();
        }
        if (message.contributorId !== "0") {
          writer.uint32(32).int64(message.contributorId);
        }
        if (message.contributorAvatar !== void 0) {
          exports2.Image.encode(message.contributorAvatar, writer.uint32(42).fork()).join();
        }
        if (message.contributorDisplayId !== "") {
          writer.uint32(50).string(message.contributorDisplayId);
        }
        if (message.contributeSubgoal !== void 0) {
          exports2.WebcastGoalUpdateMessage_LiveStreamSubGoal.encode(message.contributeSubgoal, writer.uint32(58).fork()).join();
        }
        if (message.contributeCount !== "0") {
          writer.uint32(72).int64(message.contributeCount);
        }
        if (message.contributeScore !== "0") {
          writer.uint32(80).int64(message.contributeScore);
        }
        if (message.giftRepeatCount !== "0") {
          writer.uint32(88).int64(message.giftRepeatCount);
        }
        if (message.contributorIdStr !== "") {
          writer.uint32(98).string(message.contributorIdStr);
        }
        if (message.pin !== false) {
          writer.uint32(104).bool(message.pin);
        }
        if (message.unpin !== false) {
          writer.uint32(112).bool(message.unpin);
        }
        if (message.pinInfo !== void 0) {
          exports2.WebcastGoalUpdateMessage_GoalPinInfo.encode(message.pinInfo, writer.uint32(122).fork()).join();
        }
        if (message.updateSource !== 0) {
          writer.uint32(128).int32(message.updateSource);
        }
        if (message.goalExtra !== "") {
          writer.uint32(138).string(message.goalExtra);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGoalUpdateMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.indicator = exports2.LiveStreamGoalIndicator.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.goal = exports2.LiveStreamGoal.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.contributorId = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.contributorAvatar = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.contributorDisplayId = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.contributeSubgoal = exports2.WebcastGoalUpdateMessage_LiveStreamSubGoal.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.contributeCount = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.contributeScore = reader.int64().toString();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.giftRepeatCount = reader.int64().toString();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.contributorIdStr = reader.string();
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.pin = reader.bool();
              continue;
            }
            case 14: {
              if (tag !== 112) {
                break;
              }
              message.unpin = reader.bool();
              continue;
            }
            case 15: {
              if (tag !== 122) {
                break;
              }
              message.pinInfo = exports2.WebcastGoalUpdateMessage_GoalPinInfo.decode(reader, reader.uint32());
              continue;
            }
            case 16: {
              if (tag !== 128) {
                break;
              }
              message.updateSource = reader.int32();
              continue;
            }
            case 17: {
              if (tag !== 138) {
                break;
              }
              message.goalExtra = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal() {
      return {
        type: 0,
        id: "0",
        progress: "0",
        target: "0",
        gift: void 0,
        idStr: "",
        pinInfo: void 0,
        source: 0,
        recommendedText: "",
        recommendedCommon: ""
      };
    }
    exports2.WebcastGoalUpdateMessage_LiveStreamSubGoal = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.id !== "0") {
          writer.uint32(16).int64(message.id);
        }
        if (message.progress !== "0") {
          writer.uint32(24).int64(message.progress);
        }
        if (message.target !== "0") {
          writer.uint32(32).int64(message.target);
        }
        if (message.gift !== void 0) {
          exports2.WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift.encode(message.gift, writer.uint32(42).fork()).join();
        }
        if (message.idStr !== "") {
          writer.uint32(50).string(message.idStr);
        }
        if (message.pinInfo !== void 0) {
          exports2.WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo.encode(message.pinInfo, writer.uint32(58).fork()).join();
        }
        if (message.source !== 0) {
          writer.uint32(64).int32(message.source);
        }
        if (message.recommendedText !== "") {
          writer.uint32(74).string(message.recommendedText);
        }
        if (message.recommendedCommon !== "") {
          writer.uint32(82).string(message.recommendedCommon);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.id = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.progress = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.target = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.gift = exports2.WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.idStr = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.pinInfo = exports2.WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.source = reader.int32();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.recommendedText = reader.string();
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.recommendedCommon = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift() {
      return { name: "", icon: void 0, diamondCount: "0", type: 0 };
    }
    exports2.WebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.name !== "") {
          writer.uint32(10).string(message.name);
        }
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(18).fork()).join();
        }
        if (message.diamondCount !== "0") {
          writer.uint32(24).int64(message.diamondCount);
        }
        if (message.type !== 0) {
          writer.uint32(32).int32(message.type);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal_LiveStreamSubGoalGift();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.name = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.diamondCount = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo() {
      return { pinStartTime: "0", pinEndTime: "0", pinReadyTime: "0" };
    }
    exports2.WebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.pinStartTime !== "0") {
          writer.uint32(8).int64(message.pinStartTime);
        }
        if (message.pinEndTime !== "0") {
          writer.uint32(16).int64(message.pinEndTime);
        }
        if (message.pinReadyTime !== "0") {
          writer.uint32(24).int64(message.pinReadyTime);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGoalUpdateMessage_LiveStreamSubGoal_SubGoalPinInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.pinStartTime = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.pinEndTime = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.pinReadyTime = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastGoalUpdateMessage_GoalPinInfo() {
      return { pin: false, unpin: false, pinEndTime: "0", subGoalId: "0", subGoalIdStr: "" };
    }
    exports2.WebcastGoalUpdateMessage_GoalPinInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.pin !== false) {
          writer.uint32(8).bool(message.pin);
        }
        if (message.unpin !== false) {
          writer.uint32(16).bool(message.unpin);
        }
        if (message.pinEndTime !== "0") {
          writer.uint32(24).int64(message.pinEndTime);
        }
        if (message.subGoalId !== "0") {
          writer.uint32(32).int64(message.subGoalId);
        }
        if (message.subGoalIdStr !== "") {
          writer.uint32(42).string(message.subGoalIdStr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastGoalUpdateMessage_GoalPinInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.pin = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.unpin = reader.bool();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.pinEndTime = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.subGoalId = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.subGoalIdStr = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastImDeleteMessage() {
      return { common: void 0, deleteMsgIdsList: [], deleteUserIdsList: [] };
    }
    exports2.WebcastImDeleteMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        writer.uint32(18).fork();
        for (const v of message.deleteMsgIdsList) {
          writer.int64(v);
        }
        writer.join();
        writer.uint32(26).fork();
        for (const v of message.deleteUserIdsList) {
          writer.int64(v);
        }
        writer.join();
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastImDeleteMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag === 16) {
                message.deleteMsgIdsList.push(reader.int64().toString());
                continue;
              }
              if (tag === 18) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.deleteMsgIdsList.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
            case 3: {
              if (tag === 24) {
                message.deleteUserIdsList.push(reader.int64().toString());
                continue;
              }
              if (tag === 26) {
                const end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2) {
                  message.deleteUserIdsList.push(reader.int64().toString());
                }
                continue;
              }
              break;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastInRoomBannerMessage() {
      return { common: void 0, data: "", position: 0, actionType: 0 };
    }
    exports2.WebcastInRoomBannerMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.data !== "") {
          writer.uint32(18).string(message.data);
        }
        if (message.position !== 0) {
          writer.uint32(24).int32(message.position);
        }
        if (message.actionType !== 0) {
          writer.uint32(32).int32(message.actionType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastInRoomBannerMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.data = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.position = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.actionType = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastRankUpdateMessage() {
      return {
        common: void 0,
        updatesList: [],
        groupType: "0",
        priority: "0",
        tabsList: [],
        isAnimationLoopPlay: false,
        animationLoopForOff: false,
        unionAnimation: [],
        tabInfo: []
      };
    }
    exports2.WebcastRankUpdateMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        for (const v of message.updatesList) {
          exports2.WebcastRankUpdateMessage_RankUpdate.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.groupType !== "0") {
          writer.uint32(24).int64(message.groupType);
        }
        if (message.priority !== "0") {
          writer.uint32(40).int64(message.priority);
        }
        for (const v of message.tabsList) {
          exports2.WebcastRankUpdateMessage_RankTabInfo.encode(v, writer.uint32(50).fork()).join();
        }
        if (message.isAnimationLoopPlay !== false) {
          writer.uint32(56).bool(message.isAnimationLoopPlay);
        }
        if (message.animationLoopForOff !== false) {
          writer.uint32(64).bool(message.animationLoopForOff);
        }
        for (const v of message.unionAnimation) {
          exports2.WebcastRankUpdateMessage_UnionAnimationInfo.encode(v, writer.uint32(74).fork()).join();
        }
        for (const v of message.tabInfo) {
          exports2.WebcastRankUpdateMessage_RankListTabInfo.encode(v, writer.uint32(82).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastRankUpdateMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.updatesList.push(exports2.WebcastRankUpdateMessage_RankUpdate.decode(reader, reader.uint32()));
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.groupType = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.priority = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.tabsList.push(exports2.WebcastRankUpdateMessage_RankTabInfo.decode(reader, reader.uint32()));
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.isAnimationLoopPlay = reader.bool();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.animationLoopForOff = reader.bool();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.unionAnimation.push(exports2.WebcastRankUpdateMessage_UnionAnimationInfo.decode(reader, reader.uint32()));
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.tabInfo.push(exports2.WebcastRankUpdateMessage_RankListTabInfo.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastRankUpdateMessage_UnionAnimationInfo() {
      return { unionType: 0, rankTypeArray: 0, supportedVersion: "0" };
    }
    exports2.WebcastRankUpdateMessage_UnionAnimationInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.unionType !== 0) {
          writer.uint32(8).int32(message.unionType);
        }
        if (message.rankTypeArray !== 0) {
          writer.uint32(16).int32(message.rankTypeArray);
        }
        if (message.supportedVersion !== "0") {
          writer.uint32(24).int64(message.supportedVersion);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastRankUpdateMessage_UnionAnimationInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.unionType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.rankTypeArray = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.supportedVersion = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastRankUpdateMessage_RankListTabInfo() {
      return { tabs: [], supportedVersion: "0" };
    }
    exports2.WebcastRankUpdateMessage_RankListTabInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        for (const v of message.tabs) {
          exports2.WebcastRankUpdateMessage_RankTabInfo.encode(v, writer.uint32(10).fork()).join();
        }
        if (message.supportedVersion !== "0") {
          writer.uint32(16).int64(message.supportedVersion);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastRankUpdateMessage_RankListTabInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.tabs.push(exports2.WebcastRankUpdateMessage_RankTabInfo.decode(reader, reader.uint32()));
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.supportedVersion = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastRankUpdateMessage_RankTabInfo() {
      return { rankType: 0, title: "", titleText: void 0, listLynxType: "0" };
    }
    exports2.WebcastRankUpdateMessage_RankTabInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.rankType !== 0) {
          writer.uint32(8).int32(message.rankType);
        }
        if (message.title !== "") {
          writer.uint32(18).string(message.title);
        }
        if (message.titleText !== void 0) {
          exports2.Text.encode(message.titleText, writer.uint32(26).fork()).join();
        }
        if (message.listLynxType !== "0") {
          writer.uint32(32).int64(message.listLynxType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastRankUpdateMessage_RankTabInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.rankType = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.title = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.titleText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.listLynxType = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastRankUpdateMessage_RankUpdate() {
      return {
        rankType: "0",
        ownerRank: "0",
        defaultContent: void 0,
        showEntranceAnimation: false,
        countdown: "0",
        relatedTabRankType: "0",
        requestFirstShowType: "0",
        supportedVersion: "0",
        owneronrank: false
      };
    }
    exports2.WebcastRankUpdateMessage_RankUpdate = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.rankType !== "0") {
          writer.uint32(8).int64(message.rankType);
        }
        if (message.ownerRank !== "0") {
          writer.uint32(16).int64(message.ownerRank);
        }
        if (message.defaultContent !== void 0) {
          exports2.Text.encode(message.defaultContent, writer.uint32(26).fork()).join();
        }
        if (message.showEntranceAnimation !== false) {
          writer.uint32(40).bool(message.showEntranceAnimation);
        }
        if (message.countdown !== "0") {
          writer.uint32(48).int64(message.countdown);
        }
        if (message.relatedTabRankType !== "0") {
          writer.uint32(64).int64(message.relatedTabRankType);
        }
        if (message.requestFirstShowType !== "0") {
          writer.uint32(72).int64(message.requestFirstShowType);
        }
        if (message.supportedVersion !== "0") {
          writer.uint32(80).int64(message.supportedVersion);
        }
        if (message.owneronrank !== false) {
          writer.uint32(88).bool(message.owneronrank);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastRankUpdateMessage_RankUpdate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.rankType = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.ownerRank = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.defaultContent = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.showEntranceAnimation = reader.bool();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.countdown = reader.int64().toString();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.relatedTabRankType = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.requestFirstShowType = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.supportedVersion = reader.int64().toString();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.owneronrank = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastPollMessage() {
      return {
        common: void 0,
        messageType: 0,
        pollId: "0",
        startContent: void 0,
        endContent: void 0,
        updateContent: void 0,
        pollKind: 0,
        pollBasicInfo: void 0,
        templateContent: void 0
      };
    }
    exports2.WebcastPollMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.messageType !== 0) {
          writer.uint32(16).int32(message.messageType);
        }
        if (message.pollId !== "0") {
          writer.uint32(24).int64(message.pollId);
        }
        if (message.startContent !== void 0) {
          exports2.PollStartContent.encode(message.startContent, writer.uint32(34).fork()).join();
        }
        if (message.endContent !== void 0) {
          exports2.PollEndContent.encode(message.endContent, writer.uint32(42).fork()).join();
        }
        if (message.updateContent !== void 0) {
          exports2.PollUpdateVotesContent.encode(message.updateContent, writer.uint32(50).fork()).join();
        }
        if (message.pollKind !== 0) {
          writer.uint32(56).int32(message.pollKind);
        }
        if (message.pollBasicInfo !== void 0) {
          exports2.WebcastPollMessage_PollBasicInfo.encode(message.pollBasicInfo, writer.uint32(66).fork()).join();
        }
        if (message.templateContent !== void 0) {
          exports2.WebcastPollMessage_TemplateContent.encode(message.templateContent, writer.uint32(74).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastPollMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.messageType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.pollId = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.startContent = exports2.PollStartContent.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.endContent = exports2.PollEndContent.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.updateContent = exports2.PollUpdateVotesContent.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.pollKind = reader.int32();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.pollBasicInfo = exports2.WebcastPollMessage_PollBasicInfo.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.templateContent = exports2.WebcastPollMessage_TemplateContent.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastPollMessage_TemplateContent() {
      return { templateId: "0", templateIdStr: "", status: 0, pollKind: 0, appealStatus: 0, violationIdStr: "" };
    }
    exports2.WebcastPollMessage_TemplateContent = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.templateId !== "0") {
          writer.uint32(8).int64(message.templateId);
        }
        if (message.templateIdStr !== "") {
          writer.uint32(18).string(message.templateIdStr);
        }
        if (message.status !== 0) {
          writer.uint32(24).int32(message.status);
        }
        if (message.pollKind !== 0) {
          writer.uint32(32).int32(message.pollKind);
        }
        if (message.appealStatus !== 0) {
          writer.uint32(40).int32(message.appealStatus);
        }
        if (message.violationIdStr !== "") {
          writer.uint32(50).string(message.violationIdStr);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastPollMessage_TemplateContent();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.templateId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.templateIdStr = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.status = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.pollKind = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.appealStatus = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.violationIdStr = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastPollMessage_PollBasicInfo() {
      return {
        pollSponsor: "",
        giftId: "0",
        title: "",
        isSuggestedQuestion: false,
        userCnt: "0",
        gift: void 0,
        pollIdStr: "",
        suggestedQuestionKey: "",
        pollDuration: "0",
        timeRemain: "0",
        pollIndex: "0",
        templateId: "0"
      };
    }
    exports2.WebcastPollMessage_PollBasicInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.pollSponsor !== "") {
          writer.uint32(10).string(message.pollSponsor);
        }
        if (message.giftId !== "0") {
          writer.uint32(16).int64(message.giftId);
        }
        if (message.title !== "") {
          writer.uint32(26).string(message.title);
        }
        if (message.isSuggestedQuestion !== false) {
          writer.uint32(32).bool(message.isSuggestedQuestion);
        }
        if (message.userCnt !== "0") {
          writer.uint32(40).int64(message.userCnt);
        }
        if (message.gift !== void 0) {
          exports2.Gift.encode(message.gift, writer.uint32(50).fork()).join();
        }
        if (message.pollIdStr !== "") {
          writer.uint32(58).string(message.pollIdStr);
        }
        if (message.suggestedQuestionKey !== "") {
          writer.uint32(66).string(message.suggestedQuestionKey);
        }
        if (message.pollDuration !== "0") {
          writer.uint32(72).int64(message.pollDuration);
        }
        if (message.timeRemain !== "0") {
          writer.uint32(80).int64(message.timeRemain);
        }
        if (message.pollIndex !== "0") {
          writer.uint32(88).int64(message.pollIndex);
        }
        if (message.templateId !== "0") {
          writer.uint32(96).int64(message.templateId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastPollMessage_PollBasicInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.pollSponsor = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.giftId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.title = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.isSuggestedQuestion = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.userCnt = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.gift = exports2.Gift.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.pollIdStr = reader.string();
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.suggestedQuestionKey = reader.string();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.pollDuration = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.timeRemain = reader.int64().toString();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.pollIndex = reader.int64().toString();
              continue;
            }
            case 12: {
              if (tag !== 96) {
                break;
              }
              message.templateId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastRankTextMessage() {
      return {
        common: void 0,
        scene: 0,
        ownerIdxBeforeUpdate: "0",
        ownerIdxAfterUpdate: "0",
        selfGetBadgeMsg: void 0,
        otherGetBadgeMsg: void 0,
        curUserId: "0"
      };
    }
    exports2.WebcastRankTextMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.scene !== 0) {
          writer.uint32(16).int32(message.scene);
        }
        if (message.ownerIdxBeforeUpdate !== "0") {
          writer.uint32(24).int64(message.ownerIdxBeforeUpdate);
        }
        if (message.ownerIdxAfterUpdate !== "0") {
          writer.uint32(32).int64(message.ownerIdxAfterUpdate);
        }
        if (message.selfGetBadgeMsg !== void 0) {
          exports2.Text.encode(message.selfGetBadgeMsg, writer.uint32(42).fork()).join();
        }
        if (message.otherGetBadgeMsg !== void 0) {
          exports2.Text.encode(message.otherGetBadgeMsg, writer.uint32(50).fork()).join();
        }
        if (message.curUserId !== "0") {
          writer.uint32(56).int64(message.curUserId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastRankTextMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.scene = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.ownerIdxBeforeUpdate = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.ownerIdxAfterUpdate = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.selfGetBadgeMsg = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.otherGetBadgeMsg = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.curUserId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicBattlePunishFinish() {
      return { common: void 0, channelId: "0", opUid: "0", reason: 0, battleId: "0", battleSettings: void 0 };
    }
    exports2.WebcastLinkMicBattlePunishFinish = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.channelId !== "0") {
          writer.uint32(16).int64(message.channelId);
        }
        if (message.opUid !== "0") {
          writer.uint32(24).int64(message.opUid);
        }
        if (message.reason !== 0) {
          writer.uint32(32).int32(message.reason);
        }
        if (message.battleId !== "0") {
          writer.uint32(40).int64(message.battleId);
        }
        if (message.battleSettings !== void 0) {
          exports2.BattleSetting.encode(message.battleSettings, writer.uint32(50).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicBattlePunishFinish();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.channelId = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.opUid = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.reason = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.battleId = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.battleSettings = exports2.BattleSetting.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkmicBattleTaskMessage() {
      return {
        common: void 0,
        battleTaskMessageType: 0,
        taskStart: void 0,
        taskUpdate: void 0,
        taskSettle: void 0,
        rewardSettle: void 0,
        battleId: "0"
      };
    }
    exports2.WebcastLinkmicBattleTaskMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.battleTaskMessageType !== 0) {
          writer.uint32(16).int32(message.battleTaskMessageType);
        }
        if (message.taskStart !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart.encode(message.taskStart, writer.uint32(26).fork()).join();
        }
        if (message.taskUpdate !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattleTaskUpdate.encode(message.taskUpdate, writer.uint32(34).fork()).join();
        }
        if (message.taskSettle !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattleTaskSettle.encode(message.taskSettle, writer.uint32(42).fork()).join();
        }
        if (message.rewardSettle !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattleRewardSettle.encode(message.rewardSettle, writer.uint32(50).fork()).join();
        }
        if (message.battleId !== "0") {
          writer.uint32(160).int64(message.battleId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkmicBattleTaskMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.battleTaskMessageType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.taskStart = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.taskUpdate = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskUpdate.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.taskSettle = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskSettle.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.rewardSettle = exports2.WebcastLinkmicBattleTaskMessage_BattleRewardSettle.decode(reader, reader.uint32());
              continue;
            }
            case 20: {
              if (tag !== 160) {
                break;
              }
              message.battleId = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkmicBattleTaskMessage_BattlePrompt() {
      return { promptKey: "", promptElements: [] };
    }
    exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.promptKey !== "") {
          writer.uint32(10).string(message.promptKey);
        }
        for (const v of message.promptElements) {
          exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem.encode(v, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkmicBattleTaskMessage_BattlePrompt();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.promptKey = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.promptElements.push(exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem() {
      return { promptFieldKey: "", promptFieldValue: "" };
    }
    exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.promptFieldKey !== "") {
          writer.uint32(10).string(message.promptFieldKey);
        }
        if (message.promptFieldValue !== "") {
          writer.uint32(18).string(message.promptFieldValue);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkmicBattleTaskMessage_BattlePrompt_BattlePromptElem();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.promptFieldKey = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.promptFieldValue = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart() {
      return { battleBonusConfig: void 0 };
    }
    exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.battleBonusConfig !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig.encode(message.battleBonusConfig, writer.uint32(10).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.battleBonusConfig = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig() {
      return {
        previewStartTime: "0",
        previewPeriodConfig: [],
        taskPeriodConfig: void 0,
        rewardPeriodConfig: void 0,
        taskGiftGuide: {},
        previewStartTimestamp: "0",
        previewClickActionSchemaUrl: ""
      };
    }
    exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.previewStartTime !== "0") {
          writer.uint32(8).int64(message.previewStartTime);
        }
        for (const v of message.previewPeriodConfig) {
          exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod.encode(v, writer.uint32(18).fork()).join();
        }
        if (message.taskPeriodConfig !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig.encode(message.taskPeriodConfig, writer.uint32(26).fork()).join();
        }
        if (message.rewardPeriodConfig !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig.encode(message.rewardPeriodConfig, writer.uint32(34).fork()).join();
        }
        Object.entries(message.taskGiftGuide).forEach(([key, value]) => {
          exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry.encode({
            key,
            value
          }, writer.uint32(42).fork()).join();
        });
        if (message.previewStartTimestamp !== "0") {
          writer.uint32(48).int64(message.previewStartTimestamp);
        }
        if (message.previewClickActionSchemaUrl !== "") {
          writer.uint32(58).string(message.previewClickActionSchemaUrl);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.previewStartTime = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.previewPeriodConfig.push(exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod.decode(reader, reader.uint32()));
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.taskPeriodConfig = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.rewardPeriodConfig = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              const entry5 = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry.decode(reader, reader.uint32());
              if (entry5.value !== void 0) {
                message.taskGiftGuide[entry5.key] = entry5.value;
              }
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.previewStartTimestamp = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.previewClickActionSchemaUrl = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry() {
      return { key: "0", value: void 0 };
    }
    exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "0") {
          writer.uint32(8).int64(message.key);
        }
        if (message.value !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskGiftGuideEntry();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.key = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.value = exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod() {
      return { duration: "0", promot: void 0, icon: void 0 };
    }
    exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.duration !== "0") {
          writer.uint32(8).int64(message.duration);
        }
        if (message.promot !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.promot, writer.uint32(18).fork()).join();
        }
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(202).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_PreviewPeriod();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.duration = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.promot = exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
              continue;
            }
            case 25: {
              if (tag !== 202) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig() {
      return {
        taskStartTime: "0",
        duration: "0",
        targetStartTimestamp: "0",
        clickAction: 0,
        clickToastPrompt: void 0,
        promptType: 0,
        taskStaticPrompt: void 0,
        progressTarget: "0",
        targetType: 0,
        icon: void 0,
        clickActionSchemaUrl: ""
      };
    }
    exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.taskStartTime !== "0") {
          writer.uint32(8).int64(message.taskStartTime);
        }
        if (message.duration !== "0") {
          writer.uint32(16).int64(message.duration);
        }
        if (message.targetStartTimestamp !== "0") {
          writer.uint32(24).int64(message.targetStartTimestamp);
        }
        if (message.clickAction !== 0) {
          writer.uint32(88).int32(message.clickAction);
        }
        if (message.clickToastPrompt !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.clickToastPrompt, writer.uint32(98).fork()).join();
        }
        if (message.promptType !== 0) {
          writer.uint32(168).int32(message.promptType);
        }
        if (message.taskStaticPrompt !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.taskStaticPrompt, writer.uint32(178).fork()).join();
        }
        if (message.progressTarget !== "0") {
          writer.uint32(184).int64(message.progressTarget);
        }
        if (message.targetType !== 0) {
          writer.uint32(192).int32(message.targetType);
        }
        if (message.icon !== void 0) {
          exports2.Image.encode(message.icon, writer.uint32(202).fork()).join();
        }
        if (message.clickActionSchemaUrl !== "") {
          writer.uint32(210).string(message.clickActionSchemaUrl);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_TaskPeriodConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.taskStartTime = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.duration = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.targetStartTimestamp = reader.int64().toString();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.clickAction = reader.int32();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.clickToastPrompt = exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
              continue;
            }
            case 21: {
              if (tag !== 168) {
                break;
              }
              message.promptType = reader.int32();
              continue;
            }
            case 22: {
              if (tag !== 178) {
                break;
              }
              message.taskStaticPrompt = exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
              continue;
            }
            case 23: {
              if (tag !== 184) {
                break;
              }
              message.progressTarget = reader.int64().toString();
              continue;
            }
            case 24: {
              if (tag !== 192) {
                break;
              }
              message.targetType = reader.int32();
              continue;
            }
            case 25: {
              if (tag !== 202) {
                break;
              }
              message.icon = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 26: {
              if (tag !== 210) {
                break;
              }
              message.clickActionSchemaUrl = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig() {
      return {
        rewardStartTime: "0",
        duration: "0",
        rewardMultiple: 0,
        rewardStartTimestamp: "0",
        rewardPraparePrompt: void 0,
        rewardingPrompt: void 0,
        clickPrompt: void 0
      };
    }
    exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.rewardStartTime !== "0") {
          writer.uint32(8).int64(message.rewardStartTime);
        }
        if (message.duration !== "0") {
          writer.uint32(16).int64(message.duration);
        }
        if (message.rewardMultiple !== 0) {
          writer.uint32(24).int32(message.rewardMultiple);
        }
        if (message.rewardStartTimestamp !== "0") {
          writer.uint32(32).int64(message.rewardStartTimestamp);
        }
        if (message.rewardPraparePrompt !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.rewardPraparePrompt, writer.uint32(90).fork()).join();
        }
        if (message.rewardingPrompt !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.rewardingPrompt, writer.uint32(98).fork()).join();
        }
        if (message.clickPrompt !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.clickPrompt, writer.uint32(106).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_RewardPeriodConfig();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.rewardStartTime = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.duration = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.rewardMultiple = reader.int32();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.rewardStartTimestamp = reader.int64().toString();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.rewardPraparePrompt = exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.rewardingPrompt = exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.clickPrompt = exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide() {
      return {
        guidePrompt: void 0,
        promptType: 0,
        disappearDuration: 0,
        iconImage: void 0,
        giftImage: void 0,
        recommendGiftId: "0",
        recommendGiftCount: 0,
        guideContent: void 0
      };
    }
    exports2.WebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.guidePrompt !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.guidePrompt, writer.uint32(10).fork()).join();
        }
        if (message.promptType !== 0) {
          writer.uint32(16).int32(message.promptType);
        }
        if (message.disappearDuration !== 0) {
          writer.uint32(24).int32(message.disappearDuration);
        }
        if (message.iconImage !== void 0) {
          exports2.Image.encode(message.iconImage, writer.uint32(90).fork()).join();
        }
        if (message.giftImage !== void 0) {
          exports2.Image.encode(message.giftImage, writer.uint32(98).fork()).join();
        }
        if (message.recommendGiftId !== "0") {
          writer.uint32(168).int64(message.recommendGiftId);
        }
        if (message.recommendGiftCount !== 0) {
          writer.uint32(176).int32(message.recommendGiftCount);
        }
        if (message.guideContent !== void 0) {
          exports2.Text.encode(message.guideContent, writer.uint32(186).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskStart_BattleBonusConfig_BattleTaskGiftAmountGuide();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.guidePrompt = exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.promptType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.disappearDuration = reader.int32();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.iconImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.giftImage = exports2.Image.decode(reader, reader.uint32());
              continue;
            }
            case 21: {
              if (tag !== 168) {
                break;
              }
              message.recommendGiftId = reader.int64().toString();
              continue;
            }
            case 22: {
              if (tag !== 176) {
                break;
              }
              message.recommendGiftCount = reader.int32();
              continue;
            }
            case 23: {
              if (tag !== 186) {
                break;
              }
              message.guideContent = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskUpdate() {
      return { taskProgress: "0", fromUserUid: "0", promptKey: "", logId: "" };
    }
    exports2.WebcastLinkmicBattleTaskMessage_BattleTaskUpdate = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.taskProgress !== "0") {
          writer.uint32(8).int64(message.taskProgress);
        }
        if (message.fromUserUid !== "0") {
          writer.uint32(16).int64(message.fromUserUid);
        }
        if (message.promptKey !== "") {
          writer.uint32(26).string(message.promptKey);
        }
        if (message.logId !== "") {
          writer.uint32(170).string(message.logId);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskUpdate();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.taskProgress = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.fromUserUid = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.promptKey = reader.string();
              continue;
            }
            case 21: {
              if (tag !== 170) {
                break;
              }
              message.logId = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkmicBattleTaskMessage_BattleTaskSettle() {
      return { taskResult: 0, rewardStartTime: "0", rewardStartTimestamp: "0" };
    }
    exports2.WebcastLinkmicBattleTaskMessage_BattleTaskSettle = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.taskResult !== 0) {
          writer.uint32(8).int32(message.taskResult);
        }
        if (message.rewardStartTime !== "0") {
          writer.uint32(16).int64(message.rewardStartTime);
        }
        if (message.rewardStartTimestamp !== "0") {
          writer.uint32(24).int64(message.rewardStartTimestamp);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkmicBattleTaskMessage_BattleTaskSettle();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.taskResult = reader.int32();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.rewardStartTime = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.rewardStartTimestamp = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkmicBattleTaskMessage_BattleRewardSettle() {
      return { rewardSettlePrompt: void 0, status: 0 };
    }
    exports2.WebcastLinkmicBattleTaskMessage_BattleRewardSettle = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.rewardSettlePrompt !== void 0) {
          exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.encode(message.rewardSettlePrompt, writer.uint32(10).fork()).join();
        }
        if (message.status !== 0) {
          writer.uint32(16).int32(message.status);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkmicBattleTaskMessage_BattleRewardSettle();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.rewardSettlePrompt = exports2.WebcastLinkmicBattleTaskMessage_BattlePrompt.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.status = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicFanTicketMethod() {
      return { common: void 0, FanTicketRoomNotice: void 0 };
    }
    exports2.WebcastLinkMicFanTicketMethod = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.FanTicketRoomNotice !== void 0) {
          exports2.FanTicketRoomNoticeContent.encode(message.FanTicketRoomNotice, writer.uint32(18).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicFanTicketMethod();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.FanTicketRoomNotice = exports2.FanTicketRoomNoticeContent.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMicMethod() {
      return {
        common: void 0,
        messageType: 0,
        accessKey: "",
        anchorLinkmicId: "0",
        userId: "0",
        fanTicket: "0",
        totalLinkMicFanTicket: "0",
        channelId: "0",
        layout: "0",
        vendor: "0",
        dimension: "0",
        theme: "",
        inviteUid: "0",
        reply: 0,
        duration: 0,
        matchType: 0,
        win: false,
        prompts: "",
        toUserId: "0",
        tips: "",
        startTimeMs: "0",
        confluenceType: 0,
        fromRoomId: "0",
        inviteType: 0,
        subType: "0",
        rtcExtInfo: "",
        appId: "",
        appSign: "",
        anchorLinkMicIdStr: "",
        rivalAnchorId: "0",
        rivalLinkmicId: 0,
        rivalLinkmicIdStr: "",
        shouldShowPopup: false,
        rtcJoinChannel: false,
        fanTicketType: 0
      };
    }
    exports2.WebcastLinkMicMethod = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.messageType !== 0) {
          writer.uint32(16).int32(message.messageType);
        }
        if (message.accessKey !== "") {
          writer.uint32(26).string(message.accessKey);
        }
        if (message.anchorLinkmicId !== "0") {
          writer.uint32(32).int64(message.anchorLinkmicId);
        }
        if (message.userId !== "0") {
          writer.uint32(40).int64(message.userId);
        }
        if (message.fanTicket !== "0") {
          writer.uint32(48).int64(message.fanTicket);
        }
        if (message.totalLinkMicFanTicket !== "0") {
          writer.uint32(56).int64(message.totalLinkMicFanTicket);
        }
        if (message.channelId !== "0") {
          writer.uint32(64).int64(message.channelId);
        }
        if (message.layout !== "0") {
          writer.uint32(72).int64(message.layout);
        }
        if (message.vendor !== "0") {
          writer.uint32(80).int64(message.vendor);
        }
        if (message.dimension !== "0") {
          writer.uint32(88).int64(message.dimension);
        }
        if (message.theme !== "") {
          writer.uint32(98).string(message.theme);
        }
        if (message.inviteUid !== "0") {
          writer.uint32(104).int64(message.inviteUid);
        }
        if (message.reply !== 0) {
          writer.uint32(112).int32(message.reply);
        }
        if (message.duration !== 0) {
          writer.uint32(128).int32(message.duration);
        }
        if (message.matchType !== 0) {
          writer.uint32(144).int32(message.matchType);
        }
        if (message.win !== false) {
          writer.uint32(152).bool(message.win);
        }
        if (message.prompts !== "") {
          writer.uint32(162).string(message.prompts);
        }
        if (message.toUserId !== "0") {
          writer.uint32(168).int64(message.toUserId);
        }
        if (message.tips !== "") {
          writer.uint32(202).string(message.tips);
        }
        if (message.startTimeMs !== "0") {
          writer.uint32(208).int64(message.startTimeMs);
        }
        if (message.confluenceType !== 0) {
          writer.uint32(216).int32(message.confluenceType);
        }
        if (message.fromRoomId !== "0") {
          writer.uint32(224).int64(message.fromRoomId);
        }
        if (message.inviteType !== 0) {
          writer.uint32(232).int32(message.inviteType);
        }
        if (message.subType !== "0") {
          writer.uint32(240).int64(message.subType);
        }
        if (message.rtcExtInfo !== "") {
          writer.uint32(258).string(message.rtcExtInfo);
        }
        if (message.appId !== "") {
          writer.uint32(274).string(message.appId);
        }
        if (message.appSign !== "") {
          writer.uint32(282).string(message.appSign);
        }
        if (message.anchorLinkMicIdStr !== "") {
          writer.uint32(298).string(message.anchorLinkMicIdStr);
        }
        if (message.rivalAnchorId !== "0") {
          writer.uint32(304).int64(message.rivalAnchorId);
        }
        if (message.rivalLinkmicId !== 0) {
          writer.uint32(312).int32(message.rivalLinkmicId);
        }
        if (message.rivalLinkmicIdStr !== "") {
          writer.uint32(322).string(message.rivalLinkmicIdStr);
        }
        if (message.shouldShowPopup !== false) {
          writer.uint32(328).bool(message.shouldShowPopup);
        }
        if (message.rtcJoinChannel !== false) {
          writer.uint32(408).bool(message.rtcJoinChannel);
        }
        if (message.fanTicketType !== 0) {
          writer.uint32(416).int32(message.fanTicketType);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMicMethod();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.messageType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.accessKey = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.anchorLinkmicId = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.userId = reader.int64().toString();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.fanTicket = reader.int64().toString();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.totalLinkMicFanTicket = reader.int64().toString();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.channelId = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 72) {
                break;
              }
              message.layout = reader.int64().toString();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.vendor = reader.int64().toString();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.dimension = reader.int64().toString();
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.theme = reader.string();
              continue;
            }
            case 13: {
              if (tag !== 104) {
                break;
              }
              message.inviteUid = reader.int64().toString();
              continue;
            }
            case 14: {
              if (tag !== 112) {
                break;
              }
              message.reply = reader.int32();
              continue;
            }
            case 16: {
              if (tag !== 128) {
                break;
              }
              message.duration = reader.int32();
              continue;
            }
            case 18: {
              if (tag !== 144) {
                break;
              }
              message.matchType = reader.int32();
              continue;
            }
            case 19: {
              if (tag !== 152) {
                break;
              }
              message.win = reader.bool();
              continue;
            }
            case 20: {
              if (tag !== 162) {
                break;
              }
              message.prompts = reader.string();
              continue;
            }
            case 21: {
              if (tag !== 168) {
                break;
              }
              message.toUserId = reader.int64().toString();
              continue;
            }
            case 25: {
              if (tag !== 202) {
                break;
              }
              message.tips = reader.string();
              continue;
            }
            case 26: {
              if (tag !== 208) {
                break;
              }
              message.startTimeMs = reader.int64().toString();
              continue;
            }
            case 27: {
              if (tag !== 216) {
                break;
              }
              message.confluenceType = reader.int32();
              continue;
            }
            case 28: {
              if (tag !== 224) {
                break;
              }
              message.fromRoomId = reader.int64().toString();
              continue;
            }
            case 29: {
              if (tag !== 232) {
                break;
              }
              message.inviteType = reader.int32();
              continue;
            }
            case 30: {
              if (tag !== 240) {
                break;
              }
              message.subType = reader.int64().toString();
              continue;
            }
            case 32: {
              if (tag !== 258) {
                break;
              }
              message.rtcExtInfo = reader.string();
              continue;
            }
            case 34: {
              if (tag !== 274) {
                break;
              }
              message.appId = reader.string();
              continue;
            }
            case 35: {
              if (tag !== 282) {
                break;
              }
              message.appSign = reader.string();
              continue;
            }
            case 37: {
              if (tag !== 298) {
                break;
              }
              message.anchorLinkMicIdStr = reader.string();
              continue;
            }
            case 38: {
              if (tag !== 304) {
                break;
              }
              message.rivalAnchorId = reader.int64().toString();
              continue;
            }
            case 39: {
              if (tag !== 312) {
                break;
              }
              message.rivalLinkmicId = reader.int32();
              continue;
            }
            case 40: {
              if (tag !== 322) {
                break;
              }
              message.rivalLinkmicIdStr = reader.string();
              continue;
            }
            case 41: {
              if (tag !== 328) {
                break;
              }
              message.shouldShowPopup = reader.bool();
              continue;
            }
            case 51: {
              if (tag !== 408) {
                break;
              }
              message.rtcJoinChannel = reader.bool();
              continue;
            }
            case 52: {
              if (tag !== 416) {
                break;
              }
              message.fanTicketType = reader.int32();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastUnauthorizedMemberMessage() {
      return {
        common: void 0,
        action: 0,
        nickNamePrefix: void 0,
        nickName: "",
        enterText: void 0,
        publicAreaCommon: void 0
      };
    }
    exports2.WebcastUnauthorizedMemberMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.action !== 0) {
          writer.uint32(16).int32(message.action);
        }
        if (message.nickNamePrefix !== void 0) {
          exports2.Text.encode(message.nickNamePrefix, writer.uint32(26).fork()).join();
        }
        if (message.nickName !== "") {
          writer.uint32(34).string(message.nickName);
        }
        if (message.enterText !== void 0) {
          exports2.Text.encode(message.enterText, writer.uint32(42).fork()).join();
        }
        if (message.publicAreaCommon !== void 0) {
          exports2.PublicAreaMessageCommon.encode(message.publicAreaCommon, writer.uint32(50).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastUnauthorizedMemberMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.action = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.nickNamePrefix = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.nickName = reader.string();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.enterText = exports2.Text.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.publicAreaCommon = exports2.PublicAreaMessageCommon.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastMsgDetectMessage() {
      return {
        common: void 0,
        detectType: 0,
        triggerCondition: void 0,
        timeInfo: void 0,
        triggerBy: 0,
        fromRegion: ""
      };
    }
    exports2.WebcastMsgDetectMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.detectType !== 0) {
          writer.uint32(16).int32(message.detectType);
        }
        if (message.triggerCondition !== void 0) {
          exports2.WebcastMsgDetectMessage_TriggerCondition.encode(message.triggerCondition, writer.uint32(26).fork()).join();
        }
        if (message.timeInfo !== void 0) {
          exports2.WebcastMsgDetectMessage_TimeInfo.encode(message.timeInfo, writer.uint32(34).fork()).join();
        }
        if (message.triggerBy !== 0) {
          writer.uint32(40).int32(message.triggerBy);
        }
        if (message.fromRegion !== "") {
          writer.uint32(50).string(message.fromRegion);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastMsgDetectMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.detectType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.triggerCondition = exports2.WebcastMsgDetectMessage_TriggerCondition.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.timeInfo = exports2.WebcastMsgDetectMessage_TimeInfo.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.triggerBy = reader.int32();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.fromRegion = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastMsgDetectMessage_TimeInfo() {
      return { clientStartMs: "0", apiRecvTimeMs: "0", apiSendToGoimMs: "0" };
    }
    exports2.WebcastMsgDetectMessage_TimeInfo = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.clientStartMs !== "0") {
          writer.uint32(8).int64(message.clientStartMs);
        }
        if (message.apiRecvTimeMs !== "0") {
          writer.uint32(16).int64(message.apiRecvTimeMs);
        }
        if (message.apiSendToGoimMs !== "0") {
          writer.uint32(24).int64(message.apiSendToGoimMs);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastMsgDetectMessage_TimeInfo();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.clientStartMs = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.apiRecvTimeMs = reader.int64().toString();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.apiSendToGoimMs = reader.int64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastMsgDetectMessage_TriggerCondition() {
      return {
        uplinkDetectHttp: false,
        uplinkDetectWebSocket: false,
        detectP2PMsg: false,
        detectRoomMsg: false,
        httpOptimize: false
      };
    }
    exports2.WebcastMsgDetectMessage_TriggerCondition = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.uplinkDetectHttp !== false) {
          writer.uint32(8).bool(message.uplinkDetectHttp);
        }
        if (message.uplinkDetectWebSocket !== false) {
          writer.uint32(16).bool(message.uplinkDetectWebSocket);
        }
        if (message.detectP2PMsg !== false) {
          writer.uint32(24).bool(message.detectP2PMsg);
        }
        if (message.detectRoomMsg !== false) {
          writer.uint32(32).bool(message.detectRoomMsg);
        }
        if (message.httpOptimize !== false) {
          writer.uint32(40).bool(message.httpOptimize);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastMsgDetectMessage_TriggerCondition();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.uplinkDetectHttp = reader.bool();
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.uplinkDetectWebSocket = reader.bool();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.detectP2PMsg = reader.bool();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.detectRoomMsg = reader.bool();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.httpOptimize = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastOecLiveShoppingMessage() {
      return { common: void 0, data1: 0, shopData: void 0, shopTimings: void 0, details: void 0 };
    }
    exports2.WebcastOecLiveShoppingMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.data1 !== 0) {
          writer.uint32(16).uint32(message.data1);
        }
        if (message.shopData !== void 0) {
          exports2.WebcastOecLiveShoppingMessage_LiveShoppingData.encode(message.shopData, writer.uint32(34).fork()).join();
        }
        if (message.shopTimings !== void 0) {
          exports2.TimeStampContainer.encode(message.shopTimings, writer.uint32(42).fork()).join();
        }
        if (message.details !== void 0) {
          exports2.WebcastOecLiveShoppingMessage_LiveShoppingDetails.encode(message.details, writer.uint32(74).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastOecLiveShoppingMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.data1 = reader.uint32();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.shopData = exports2.WebcastOecLiveShoppingMessage_LiveShoppingData.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.shopTimings = exports2.TimeStampContainer.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.details = exports2.WebcastOecLiveShoppingMessage_LiveShoppingDetails.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastOecLiveShoppingMessage_LiveShoppingData() {
      return {
        title: "",
        priceString: "",
        imageUrl: "",
        shopUrl: "",
        data1: "0",
        shopName: "",
        data2: "0",
        shopUrl2: "",
        data3: "0",
        data4: "0"
      };
    }
    exports2.WebcastOecLiveShoppingMessage_LiveShoppingData = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.title !== "") {
          writer.uint32(10).string(message.title);
        }
        if (message.priceString !== "") {
          writer.uint32(18).string(message.priceString);
        }
        if (message.imageUrl !== "") {
          writer.uint32(26).string(message.imageUrl);
        }
        if (message.shopUrl !== "") {
          writer.uint32(34).string(message.shopUrl);
        }
        if (message.data1 !== "0") {
          writer.uint32(48).uint64(message.data1);
        }
        if (message.shopName !== "") {
          writer.uint32(58).string(message.shopName);
        }
        if (message.data2 !== "0") {
          writer.uint32(64).uint64(message.data2);
        }
        if (message.shopUrl2 !== "") {
          writer.uint32(74).string(message.shopUrl2);
        }
        if (message.data3 !== "0") {
          writer.uint32(80).uint64(message.data3);
        }
        if (message.data4 !== "0") {
          writer.uint32(88).uint64(message.data4);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastOecLiveShoppingMessage_LiveShoppingData();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.title = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.priceString = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.imageUrl = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.shopUrl = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 48) {
                break;
              }
              message.data1 = reader.uint64().toString();
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.shopName = reader.string();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.data2 = reader.uint64().toString();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.shopUrl2 = reader.string();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.data3 = reader.uint64().toString();
              continue;
            }
            case 11: {
              if (tag !== 88) {
                break;
              }
              message.data4 = reader.uint64().toString();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastOecLiveShoppingMessage_LiveShoppingDetails() {
      return { id1: "", data1: "", data2: 0, timestamp: "0", data: void 0 };
    }
    exports2.WebcastOecLiveShoppingMessage_LiveShoppingDetails = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.id1 !== "") {
          writer.uint32(10).string(message.id1);
        }
        if (message.data1 !== "") {
          writer.uint32(26).string(message.data1);
        }
        if (message.data2 !== 0) {
          writer.uint32(32).uint32(message.data2);
        }
        if (message.timestamp !== "0") {
          writer.uint32(40).uint64(message.timestamp);
        }
        if (message.data !== void 0) {
          exports2.ValueLabel.encode(message.data, writer.uint32(50).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastOecLiveShoppingMessage_LiveShoppingDetails();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.id1 = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.data1 = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.data2 = reader.uint32();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.timestamp = reader.uint64().toString();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.data = exports2.ValueLabel.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastRoomPinMessage() {
      return {
        common: void 0,
        chatMessage: void 0,
        socialMessage: void 0,
        giftMessage: void 0,
        memberMessage: void 0,
        likeMessage: void 0,
        method: "",
        pinTime: "0",
        operator: void 0,
        action: 0,
        displayDuration: "0",
        pinId: "0",
        ecStreamerKey: ""
      };
    }
    exports2.WebcastRoomPinMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.chatMessage !== void 0) {
          exports2.WebcastChatMessage.encode(message.chatMessage, writer.uint32(18).fork()).join();
        }
        if (message.socialMessage !== void 0) {
          exports2.WebcastSocialMessage.encode(message.socialMessage, writer.uint32(26).fork()).join();
        }
        if (message.giftMessage !== void 0) {
          exports2.WebcastGiftMessage.encode(message.giftMessage, writer.uint32(34).fork()).join();
        }
        if (message.memberMessage !== void 0) {
          exports2.WebcastMemberMessage.encode(message.memberMessage, writer.uint32(42).fork()).join();
        }
        if (message.likeMessage !== void 0) {
          exports2.WebcastLikeMessage.encode(message.likeMessage, writer.uint32(50).fork()).join();
        }
        if (message.method !== "") {
          writer.uint32(242).string(message.method);
        }
        if (message.pinTime !== "0") {
          writer.uint32(248).int64(message.pinTime);
        }
        if (message.operator !== void 0) {
          exports2.User.encode(message.operator, writer.uint32(258).fork()).join();
        }
        if (message.action !== 0) {
          writer.uint32(264).int32(message.action);
        }
        if (message.displayDuration !== "0") {
          writer.uint32(272).int64(message.displayDuration);
        }
        if (message.pinId !== "0") {
          writer.uint32(280).int64(message.pinId);
        }
        if (message.ecStreamerKey !== "") {
          writer.uint32(290).string(message.ecStreamerKey);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastRoomPinMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.chatMessage = exports2.WebcastChatMessage.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.socialMessage = exports2.WebcastSocialMessage.decode(reader, reader.uint32());
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.giftMessage = exports2.WebcastGiftMessage.decode(reader, reader.uint32());
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.memberMessage = exports2.WebcastMemberMessage.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.likeMessage = exports2.WebcastLikeMessage.decode(reader, reader.uint32());
              continue;
            }
            case 30: {
              if (tag !== 242) {
                break;
              }
              message.method = reader.string();
              continue;
            }
            case 31: {
              if (tag !== 248) {
                break;
              }
              message.pinTime = reader.int64().toString();
              continue;
            }
            case 32: {
              if (tag !== 258) {
                break;
              }
              message.operator = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 33: {
              if (tag !== 264) {
                break;
              }
              message.action = reader.int32();
              continue;
            }
            case 34: {
              if (tag !== 272) {
                break;
              }
              message.displayDuration = reader.int64().toString();
              continue;
            }
            case 35: {
              if (tag !== 280) {
                break;
              }
              message.pinId = reader.int64().toString();
              continue;
            }
            case 36: {
              if (tag !== 290) {
                break;
              }
              message.ecStreamerKey = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkMessage() {
      return {
        common: void 0,
        MessageType: 0,
        LinkerId: "0",
        Scene: 0,
        InviteContent: void 0,
        ReplyContent: void 0,
        CreateContent: void 0,
        CloseContent: void 0,
        EnterContent: void 0,
        LeaveContent: void 0,
        CancelContent: void 0,
        KickOutContent: void 0,
        LinkedListChangeContent: void 0,
        UpdateUserContent: void 0,
        WaitingListChangeContent: void 0,
        MuteContent: void 0,
        RandomMatchContent: void 0,
        UpdateUserSettingContent: void 0,
        MicIdxUpdateContent: void 0,
        ListChangeContent: void 0,
        CohostListChangeContent: void 0,
        MediaChangeContent: void 0,
        AcceptNoticeContent: void 0,
        SysKickOutContent: void 0,
        UserToastContent: void 0,
        extra: "",
        expireTimestamp: "0",
        transferExtra: ""
      };
    }
    exports2.WebcastLinkMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.MessageType !== 0) {
          writer.uint32(16).int32(message.MessageType);
        }
        if (message.LinkerId !== "0") {
          writer.uint32(24).int64(message.LinkerId);
        }
        if (message.Scene !== 0) {
          writer.uint32(32).int32(message.Scene);
        }
        if (message.InviteContent !== void 0) {
          exports2.LinkerInviteContent.encode(message.InviteContent, writer.uint32(42).fork()).join();
        }
        if (message.ReplyContent !== void 0) {
          exports2.LinkerReplyContent.encode(message.ReplyContent, writer.uint32(50).fork()).join();
        }
        if (message.CreateContent !== void 0) {
          exports2.LinkerCreateContent.encode(message.CreateContent, writer.uint32(58).fork()).join();
        }
        if (message.CloseContent !== void 0) {
          exports2.LinkerCloseContent.encode(message.CloseContent, writer.uint32(66).fork()).join();
        }
        if (message.EnterContent !== void 0) {
          exports2.LinkerEnterContent.encode(message.EnterContent, writer.uint32(74).fork()).join();
        }
        if (message.LeaveContent !== void 0) {
          exports2.LinkerLeaveContent.encode(message.LeaveContent, writer.uint32(82).fork()).join();
        }
        if (message.CancelContent !== void 0) {
          exports2.LinkerCancelContent.encode(message.CancelContent, writer.uint32(90).fork()).join();
        }
        if (message.KickOutContent !== void 0) {
          exports2.LinkerKickOutContent.encode(message.KickOutContent, writer.uint32(98).fork()).join();
        }
        if (message.LinkedListChangeContent !== void 0) {
          exports2.LinkerLinkedListChangeContent.encode(message.LinkedListChangeContent, writer.uint32(106).fork()).join();
        }
        if (message.UpdateUserContent !== void 0) {
          exports2.LinkerUpdateUserContent.encode(message.UpdateUserContent, writer.uint32(114).fork()).join();
        }
        if (message.WaitingListChangeContent !== void 0) {
          exports2.LinkerWaitingListChangeContent.encode(message.WaitingListChangeContent, writer.uint32(122).fork()).join();
        }
        if (message.MuteContent !== void 0) {
          exports2.LinkerMuteContent.encode(message.MuteContent, writer.uint32(130).fork()).join();
        }
        if (message.RandomMatchContent !== void 0) {
          exports2.LinkerRandomMatchContent.encode(message.RandomMatchContent, writer.uint32(138).fork()).join();
        }
        if (message.UpdateUserSettingContent !== void 0) {
          exports2.LinkerUpdateUserSettingContent.encode(message.UpdateUserSettingContent, writer.uint32(146).fork()).join();
        }
        if (message.MicIdxUpdateContent !== void 0) {
          exports2.LinkerMicIdxUpdateContent.encode(message.MicIdxUpdateContent, writer.uint32(154).fork()).join();
        }
        if (message.ListChangeContent !== void 0) {
          exports2.LinkerListChangeContent.encode(message.ListChangeContent, writer.uint32(162).fork()).join();
        }
        if (message.CohostListChangeContent !== void 0) {
          exports2.CohostListChangeContent.encode(message.CohostListChangeContent, writer.uint32(170).fork()).join();
        }
        if (message.MediaChangeContent !== void 0) {
          exports2.LinkerMediaChangeContent.encode(message.MediaChangeContent, writer.uint32(178).fork()).join();
        }
        if (message.AcceptNoticeContent !== void 0) {
          exports2.LinkerAcceptNoticeContent.encode(message.AcceptNoticeContent, writer.uint32(186).fork()).join();
        }
        if (message.SysKickOutContent !== void 0) {
          exports2.LinkerSysKickOutContent.encode(message.SysKickOutContent, writer.uint32(810).fork()).join();
        }
        if (message.UserToastContent !== void 0) {
          exports2.LinkmicUserToastContent.encode(message.UserToastContent, writer.uint32(818).fork()).join();
        }
        if (message.extra !== "") {
          writer.uint32(1602).string(message.extra);
        }
        if (message.expireTimestamp !== "0") {
          writer.uint32(1608).int64(message.expireTimestamp);
        }
        if (message.transferExtra !== "") {
          writer.uint32(1618).string(message.transferExtra);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.MessageType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.LinkerId = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.Scene = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.InviteContent = exports2.LinkerInviteContent.decode(reader, reader.uint32());
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.ReplyContent = exports2.LinkerReplyContent.decode(reader, reader.uint32());
              continue;
            }
            case 7: {
              if (tag !== 58) {
                break;
              }
              message.CreateContent = exports2.LinkerCreateContent.decode(reader, reader.uint32());
              continue;
            }
            case 8: {
              if (tag !== 66) {
                break;
              }
              message.CloseContent = exports2.LinkerCloseContent.decode(reader, reader.uint32());
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.EnterContent = exports2.LinkerEnterContent.decode(reader, reader.uint32());
              continue;
            }
            case 10: {
              if (tag !== 82) {
                break;
              }
              message.LeaveContent = exports2.LinkerLeaveContent.decode(reader, reader.uint32());
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.CancelContent = exports2.LinkerCancelContent.decode(reader, reader.uint32());
              continue;
            }
            case 12: {
              if (tag !== 98) {
                break;
              }
              message.KickOutContent = exports2.LinkerKickOutContent.decode(reader, reader.uint32());
              continue;
            }
            case 13: {
              if (tag !== 106) {
                break;
              }
              message.LinkedListChangeContent = exports2.LinkerLinkedListChangeContent.decode(reader, reader.uint32());
              continue;
            }
            case 14: {
              if (tag !== 114) {
                break;
              }
              message.UpdateUserContent = exports2.LinkerUpdateUserContent.decode(reader, reader.uint32());
              continue;
            }
            case 15: {
              if (tag !== 122) {
                break;
              }
              message.WaitingListChangeContent = exports2.LinkerWaitingListChangeContent.decode(reader, reader.uint32());
              continue;
            }
            case 16: {
              if (tag !== 130) {
                break;
              }
              message.MuteContent = exports2.LinkerMuteContent.decode(reader, reader.uint32());
              continue;
            }
            case 17: {
              if (tag !== 138) {
                break;
              }
              message.RandomMatchContent = exports2.LinkerRandomMatchContent.decode(reader, reader.uint32());
              continue;
            }
            case 18: {
              if (tag !== 146) {
                break;
              }
              message.UpdateUserSettingContent = exports2.LinkerUpdateUserSettingContent.decode(reader, reader.uint32());
              continue;
            }
            case 19: {
              if (tag !== 154) {
                break;
              }
              message.MicIdxUpdateContent = exports2.LinkerMicIdxUpdateContent.decode(reader, reader.uint32());
              continue;
            }
            case 20: {
              if (tag !== 162) {
                break;
              }
              message.ListChangeContent = exports2.LinkerListChangeContent.decode(reader, reader.uint32());
              continue;
            }
            case 21: {
              if (tag !== 170) {
                break;
              }
              message.CohostListChangeContent = exports2.CohostListChangeContent.decode(reader, reader.uint32());
              continue;
            }
            case 22: {
              if (tag !== 178) {
                break;
              }
              message.MediaChangeContent = exports2.LinkerMediaChangeContent.decode(reader, reader.uint32());
              continue;
            }
            case 23: {
              if (tag !== 186) {
                break;
              }
              message.AcceptNoticeContent = exports2.LinkerAcceptNoticeContent.decode(reader, reader.uint32());
              continue;
            }
            case 101: {
              if (tag !== 810) {
                break;
              }
              message.SysKickOutContent = exports2.LinkerSysKickOutContent.decode(reader, reader.uint32());
              continue;
            }
            case 102: {
              if (tag !== 818) {
                break;
              }
              message.UserToastContent = exports2.LinkmicUserToastContent.decode(reader, reader.uint32());
              continue;
            }
            case 200: {
              if (tag !== 1602) {
                break;
              }
              message.extra = reader.string();
              continue;
            }
            case 201: {
              if (tag !== 1608) {
                break;
              }
              message.expireTimestamp = reader.int64().toString();
              continue;
            }
            case 202: {
              if (tag !== 1618) {
                break;
              }
              message.transferExtra = reader.string();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastLinkLayerMessage() {
      return {
        common: void 0,
        messageType: 0,
        channelId: "0",
        scene: 0,
        source: "",
        centerizedIdc: "",
        rtcRoomId: "0",
        createChannelContent: void 0,
        listChangeContent: void 0,
        inviteContent: void 0,
        applyContent: void 0,
        permitApplyContent: void 0,
        replyInviteContent: void 0,
        kickOutContent: void 0,
        cancelApplyContent: void 0,
        cancelInviteContent: void 0,
        leaveContent: void 0,
        finishContent: void 0,
        joinDirectContent: void 0,
        joinGroupContent: void 0,
        permitGroupContent: void 0,
        cancelGroupContent: void 0,
        leaveGroupContent: void 0,
        p2pGroupChangeContent: void 0,
        groupChangeContent: void 0,
        businessContent: void 0
      };
    }
    exports2.WebcastLinkLayerMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.messageType !== 0) {
          writer.uint32(16).int32(message.messageType);
        }
        if (message.channelId !== "0") {
          writer.uint32(24).int64(message.channelId);
        }
        if (message.scene !== 0) {
          writer.uint32(32).int32(message.scene);
        }
        if (message.source !== "") {
          writer.uint32(42).string(message.source);
        }
        if (message.centerizedIdc !== "") {
          writer.uint32(50).string(message.centerizedIdc);
        }
        if (message.rtcRoomId !== "0") {
          writer.uint32(56).int64(message.rtcRoomId);
        }
        if (message.createChannelContent !== void 0) {
          exports2.CreateChannelContent.encode(message.createChannelContent, writer.uint32(802).fork()).join();
        }
        if (message.listChangeContent !== void 0) {
          exports2.ListChangeContent.encode(message.listChangeContent, writer.uint32(818).fork()).join();
        }
        if (message.inviteContent !== void 0) {
          exports2.InviteContent.encode(message.inviteContent, writer.uint32(826).fork()).join();
        }
        if (message.applyContent !== void 0) {
          exports2.ApplyContent.encode(message.applyContent, writer.uint32(834).fork()).join();
        }
        if (message.permitApplyContent !== void 0) {
          exports2.PermitApplyContent.encode(message.permitApplyContent, writer.uint32(842).fork()).join();
        }
        if (message.replyInviteContent !== void 0) {
          exports2.ReplyInviteContent.encode(message.replyInviteContent, writer.uint32(850).fork()).join();
        }
        if (message.kickOutContent !== void 0) {
          exports2.KickOutContent.encode(message.kickOutContent, writer.uint32(858).fork()).join();
        }
        if (message.cancelApplyContent !== void 0) {
          exports2.CancelApplyContent.encode(message.cancelApplyContent, writer.uint32(866).fork()).join();
        }
        if (message.cancelInviteContent !== void 0) {
          exports2.CancelInviteContent.encode(message.cancelInviteContent, writer.uint32(874).fork()).join();
        }
        if (message.leaveContent !== void 0) {
          exports2.LeaveContent.encode(message.leaveContent, writer.uint32(882).fork()).join();
        }
        if (message.finishContent !== void 0) {
          exports2.FinishChannelContent.encode(message.finishContent, writer.uint32(890).fork()).join();
        }
        if (message.joinDirectContent !== void 0) {
          exports2.JoinDirectContent.encode(message.joinDirectContent, writer.uint32(898).fork()).join();
        }
        if (message.joinGroupContent !== void 0) {
          exports2.JoinGroupContent.encode(message.joinGroupContent, writer.uint32(906).fork()).join();
        }
        if (message.permitGroupContent !== void 0) {
          exports2.PermitJoinGroupContent.encode(message.permitGroupContent, writer.uint32(914).fork()).join();
        }
        if (message.cancelGroupContent !== void 0) {
          exports2.CancelJoinGroupContent.encode(message.cancelGroupContent, writer.uint32(922).fork()).join();
        }
        if (message.leaveGroupContent !== void 0) {
          exports2.LeaveJoinGroupContent.encode(message.leaveGroupContent, writer.uint32(930).fork()).join();
        }
        if (message.p2pGroupChangeContent !== void 0) {
          exports2.P2PGroupChangeContent.encode(message.p2pGroupChangeContent, writer.uint32(938).fork()).join();
        }
        if (message.groupChangeContent !== void 0) {
          exports2.GroupChangeContent.encode(message.groupChangeContent, writer.uint32(946).fork()).join();
        }
        if (message.businessContent !== void 0) {
          exports2.BusinessContent.encode(message.businessContent, writer.uint32(1602).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastLinkLayerMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.messageType = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.channelId = reader.int64().toString();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.scene = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.source = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.centerizedIdc = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.rtcRoomId = reader.int64().toString();
              continue;
            }
            case 100: {
              if (tag !== 802) {
                break;
              }
              message.createChannelContent = exports2.CreateChannelContent.decode(reader, reader.uint32());
              continue;
            }
            case 102: {
              if (tag !== 818) {
                break;
              }
              message.listChangeContent = exports2.ListChangeContent.decode(reader, reader.uint32());
              continue;
            }
            case 103: {
              if (tag !== 826) {
                break;
              }
              message.inviteContent = exports2.InviteContent.decode(reader, reader.uint32());
              continue;
            }
            case 104: {
              if (tag !== 834) {
                break;
              }
              message.applyContent = exports2.ApplyContent.decode(reader, reader.uint32());
              continue;
            }
            case 105: {
              if (tag !== 842) {
                break;
              }
              message.permitApplyContent = exports2.PermitApplyContent.decode(reader, reader.uint32());
              continue;
            }
            case 106: {
              if (tag !== 850) {
                break;
              }
              message.replyInviteContent = exports2.ReplyInviteContent.decode(reader, reader.uint32());
              continue;
            }
            case 107: {
              if (tag !== 858) {
                break;
              }
              message.kickOutContent = exports2.KickOutContent.decode(reader, reader.uint32());
              continue;
            }
            case 108: {
              if (tag !== 866) {
                break;
              }
              message.cancelApplyContent = exports2.CancelApplyContent.decode(reader, reader.uint32());
              continue;
            }
            case 109: {
              if (tag !== 874) {
                break;
              }
              message.cancelInviteContent = exports2.CancelInviteContent.decode(reader, reader.uint32());
              continue;
            }
            case 110: {
              if (tag !== 882) {
                break;
              }
              message.leaveContent = exports2.LeaveContent.decode(reader, reader.uint32());
              continue;
            }
            case 111: {
              if (tag !== 890) {
                break;
              }
              message.finishContent = exports2.FinishChannelContent.decode(reader, reader.uint32());
              continue;
            }
            case 112: {
              if (tag !== 898) {
                break;
              }
              message.joinDirectContent = exports2.JoinDirectContent.decode(reader, reader.uint32());
              continue;
            }
            case 113: {
              if (tag !== 906) {
                break;
              }
              message.joinGroupContent = exports2.JoinGroupContent.decode(reader, reader.uint32());
              continue;
            }
            case 114: {
              if (tag !== 914) {
                break;
              }
              message.permitGroupContent = exports2.PermitJoinGroupContent.decode(reader, reader.uint32());
              continue;
            }
            case 115: {
              if (tag !== 922) {
                break;
              }
              message.cancelGroupContent = exports2.CancelJoinGroupContent.decode(reader, reader.uint32());
              continue;
            }
            case 116: {
              if (tag !== 930) {
                break;
              }
              message.leaveGroupContent = exports2.LeaveJoinGroupContent.decode(reader, reader.uint32());
              continue;
            }
            case 117: {
              if (tag !== 938) {
                break;
              }
              message.p2pGroupChangeContent = exports2.P2PGroupChangeContent.decode(reader, reader.uint32());
              continue;
            }
            case 118: {
              if (tag !== 946) {
                break;
              }
              message.groupChangeContent = exports2.GroupChangeContent.decode(reader, reader.uint32());
              continue;
            }
            case 200: {
              if (tag !== 1602) {
                break;
              }
              message.businessContent = exports2.BusinessContent.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseRoomVerifyMessage() {
      return { common: void 0, action: 0, content: "", noticeType: "0", closeRoom: false };
    }
    exports2.RoomVerifyMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.common !== void 0) {
          exports2.CommonMessageData.encode(message.common, writer.uint32(10).fork()).join();
        }
        if (message.action !== 0) {
          writer.uint32(16).int32(message.action);
        }
        if (message.content !== "") {
          writer.uint32(26).string(message.content);
        }
        if (message.noticeType !== "0") {
          writer.uint32(32).int64(message.noticeType);
        }
        if (message.closeRoom !== false) {
          writer.uint32(40).bool(message.closeRoom);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseRoomVerifyMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.common = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.action = reader.int32();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.content = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.noticeType = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 40) {
                break;
              }
              message.closeRoom = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessageOld() {
      return { event: void 0, msgType: 0, content: void 0 };
    }
    exports2.WebcastBarrageMessageOld = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.event !== void 0) {
          exports2.CommonMessageData.encode(message.event, writer.uint32(10).fork()).join();
        }
        if (message.msgType !== 0) {
          writer.uint32(24).int32(message.msgType);
        }
        if (message.content !== void 0) {
          exports2.WebcastBarrageMessageOld_Text.encode(message.content, writer.uint32(42).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessageOld();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.event = exports2.CommonMessageData.decode(reader, reader.uint32());
              continue;
            }
            case 3: {
              if (tag !== 24) {
                break;
              }
              message.msgType = reader.int32();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.content = exports2.WebcastBarrageMessageOld_Text.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessageOld_Text() {
      return { key: "", defaultPattern: "", pieces: [] };
    }
    exports2.WebcastBarrageMessageOld_Text = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.key !== "") {
          writer.uint32(10).string(message.key);
        }
        if (message.defaultPattern !== "") {
          writer.uint32(18).string(message.defaultPattern);
        }
        for (const v of message.pieces) {
          exports2.WebcastBarrageMessageOld_TextPiece.encode(v, writer.uint32(34).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessageOld_Text();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.key = reader.string();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.defaultPattern = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 34) {
                break;
              }
              message.pieces.push(exports2.WebcastBarrageMessageOld_TextPiece.decode(reader, reader.uint32()));
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessageOld_TextPiece() {
      return { type: 0, stringValue: "", userValue: void 0 };
    }
    exports2.WebcastBarrageMessageOld_TextPiece = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.type !== 0) {
          writer.uint32(8).int32(message.type);
        }
        if (message.stringValue !== "") {
          writer.uint32(90).string(message.stringValue);
        }
        if (message.userValue !== void 0) {
          exports2.WebcastBarrageMessageOld_TextPieceUser.encode(message.userValue, writer.uint32(170).fork()).join();
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessageOld_TextPiece();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.type = reader.int32();
              continue;
            }
            case 11: {
              if (tag !== 90) {
                break;
              }
              message.stringValue = reader.string();
              continue;
            }
            case 21: {
              if (tag !== 170) {
                break;
              }
              message.userValue = exports2.WebcastBarrageMessageOld_TextPieceUser.decode(reader, reader.uint32());
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastBarrageMessageOld_TextPieceUser() {
      return { user: void 0, withColon: false };
    }
    exports2.WebcastBarrageMessageOld_TextPieceUser = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.user !== void 0) {
          exports2.User.encode(message.user, writer.uint32(10).fork()).join();
        }
        if (message.withColon !== false) {
          writer.uint32(16).bool(message.withColon);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastBarrageMessageOld_TextPieceUser();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 10) {
                break;
              }
              message.user = exports2.User.decode(reader, reader.uint32());
              continue;
            }
            case 2: {
              if (tag !== 16) {
                break;
              }
              message.withColon = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
    function createBaseWebcastImEnterRoomMessage() {
      return {
        roomId: "0",
        roomTag: "",
        liveRegion: "",
        liveId: "0",
        identity: "",
        cursor: "",
        accountType: "0",
        enterUniqueId: "0",
        filterWelcomeMsg: "",
        isAnchorContinueKeepMsg: false
      };
    }
    exports2.WebcastImEnterRoomMessage = {
      encode(message, writer = new wire_1.BinaryWriter()) {
        if (message.roomId !== "0") {
          writer.uint32(8).int64(message.roomId);
        }
        if (message.roomTag !== "") {
          writer.uint32(18).string(message.roomTag);
        }
        if (message.liveRegion !== "") {
          writer.uint32(26).string(message.liveRegion);
        }
        if (message.liveId !== "0") {
          writer.uint32(32).int64(message.liveId);
        }
        if (message.identity !== "") {
          writer.uint32(42).string(message.identity);
        }
        if (message.cursor !== "") {
          writer.uint32(50).string(message.cursor);
        }
        if (message.accountType !== "0") {
          writer.uint32(56).int64(message.accountType);
        }
        if (message.enterUniqueId !== "0") {
          writer.uint32(64).int64(message.enterUniqueId);
        }
        if (message.filterWelcomeMsg !== "") {
          writer.uint32(74).string(message.filterWelcomeMsg);
        }
        if (message.isAnchorContinueKeepMsg !== false) {
          writer.uint32(80).bool(message.isAnchorContinueKeepMsg);
        }
        return writer;
      },
      decode(input, length) {
        const reader = input instanceof wire_1.BinaryReader ? input : new wire_1.BinaryReader(input);
        let end = length === void 0 ? reader.len : reader.pos + length;
        const message = createBaseWebcastImEnterRoomMessage();
        while (reader.pos < end) {
          const tag = reader.uint32();
          switch (tag >>> 3) {
            case 1: {
              if (tag !== 8) {
                break;
              }
              message.roomId = reader.int64().toString();
              continue;
            }
            case 2: {
              if (tag !== 18) {
                break;
              }
              message.roomTag = reader.string();
              continue;
            }
            case 3: {
              if (tag !== 26) {
                break;
              }
              message.liveRegion = reader.string();
              continue;
            }
            case 4: {
              if (tag !== 32) {
                break;
              }
              message.liveId = reader.int64().toString();
              continue;
            }
            case 5: {
              if (tag !== 42) {
                break;
              }
              message.identity = reader.string();
              continue;
            }
            case 6: {
              if (tag !== 50) {
                break;
              }
              message.cursor = reader.string();
              continue;
            }
            case 7: {
              if (tag !== 56) {
                break;
              }
              message.accountType = reader.int64().toString();
              continue;
            }
            case 8: {
              if (tag !== 64) {
                break;
              }
              message.enterUniqueId = reader.int64().toString();
              continue;
            }
            case 9: {
              if (tag !== 74) {
                break;
              }
              message.filterWelcomeMsg = reader.string();
              continue;
            }
            case 10: {
              if (tag !== 80) {
                break;
              }
              message.isAnchorContinueKeepMsg = reader.bool();
              continue;
            }
          }
          if ((tag & 7) === 4 || tag === 0) {
            break;
          }
          reader.skip(tag & 7);
        }
        return message;
      }
    };
  }
});

// node_modules/tiktok-live-connector/dist/lib/utilities.js
var require_utilities = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/utilities.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createBaseWebcastPushFrame = exports2.generateDeviceId = exports2.userAgentToDevicePreset = exports2.validateAndNormalizeUniqueId = exports2.deserializeWebSocketMessage = exports2.deserializeMessage = exports2.WebcastDeserializeConfig = void 0;
    var tikTokSchema = __importStar(require_tiktok_schema());
    var tiktok_schema_1 = require_tiktok_schema();
    var zlib = __importStar(require("node:zlib"));
    var util = __importStar(require("node:util"));
    var errors_1 = require_errors();
    var wire_1 = require_wire();
    var unzip = util.promisify(zlib.unzip);
    function hasProtoName(protoName) {
      return !!tikTokSchema[protoName];
    }
    exports2.WebcastDeserializeConfig = {
      skipMessageTypes: []
    };
    function deserializeMessage(protoName, binaryMessage) {
      const messageFn = tikTokSchema[protoName];
      if (!messageFn)
        throw new errors_1.InvalidSchemaNameError(`Invalid schema name: ${protoName}`);
      let deserializedMessage;
      try {
        deserializedMessage = messageFn.decode(binaryMessage);
      } catch (ex) {
        throw new errors_1.SchemaDecodeError(`Failed to decode message type: ${protoName}: ` + ex.stack);
      }
      if (protoName === "ProtoMessageFetchResult") {
        for (const message of deserializedMessage.messages || []) {
          if (exports2.WebcastDeserializeConfig.skipMessageTypes.includes(message.type)) {
            continue;
          }
          if (!hasProtoName(message.type)) {
            if (process.env.DEBUG_DESERIALIZE_XD) {
              console.log("---------------");
              console.log(message.type, (0, wire_1.base64Encode)(Buffer.from(message.payload)));
              console.log("---------------");
            }
            continue;
          }
          message.decodedData = {
            type: message.type,
            data: deserializeMessage(message.type, Buffer.from(message.payload))
          };
        }
      }
      return deserializedMessage;
    }
    exports2.deserializeMessage = deserializeMessage;
    async function deserializeWebSocketMessage(binaryMessage) {
      const rawWebcastWebSocketMessage = tiktok_schema_1.WebcastPushFrame.decode(binaryMessage);
      let protoMessageFetchResult = void 0;
      if (rawWebcastWebSocketMessage.payloadEncoding === "pb" && rawWebcastWebSocketMessage.payload) {
        let binary = rawWebcastWebSocketMessage.payload;
        if (binary && binary.length > 2 && binary[0] === 31 && binary[1] === 139 && binary[2] === 8) {
          rawWebcastWebSocketMessage.payload = await unzip(binary);
        }
        protoMessageFetchResult = deserializeMessage("ProtoMessageFetchResult", Buffer.from(rawWebcastWebSocketMessage.payload));
      }
      const decodedContainer = rawWebcastWebSocketMessage;
      decodedContainer.protoMessageFetchResult = protoMessageFetchResult;
      return decodedContainer;
    }
    exports2.deserializeWebSocketMessage = deserializeWebSocketMessage;
    function validateAndNormalizeUniqueId(uniqueId) {
      if (typeof uniqueId !== "string") {
        throw new errors_1.InvalidUniqueIdError("Missing or invalid value for 'uniqueId'. Please provide the username from TikTok URL.");
      }
      uniqueId = uniqueId.replace("https://www.tiktok.com/", "");
      uniqueId = uniqueId.replace("/live", "");
      uniqueId = uniqueId.replace("@", "");
      uniqueId = uniqueId.trim();
      return uniqueId;
    }
    exports2.validateAndNormalizeUniqueId = validateAndNormalizeUniqueId;
    function userAgentToDevicePreset(userAgent) {
      const firstSlash = userAgent.indexOf("/");
      const browserName = userAgent.substring(0, firstSlash);
      const browserVersion = userAgent.substring(firstSlash + 1);
      return {
        user_agent: userAgent,
        browser_name: browserName,
        browser_version: browserVersion,
        browser_platform: userAgent.includes("Macintosh") ? "MacIntel" : "Win32",
        os: userAgent.includes("Macintosh") ? "mac" : "windows"
      };
    }
    exports2.userAgentToDevicePreset = userAgentToDevicePreset;
    function generateDeviceId() {
      let digits = "";
      for (let i = 0; i < 19; i++) {
        digits += Math.floor(Math.random() * 10);
      }
      return digits;
    }
    exports2.generateDeviceId = generateDeviceId;
    function createBaseWebcastPushFrame(overrides) {
      const undefinedNum = "0";
      overrides = Object.fromEntries(Object.entries(overrides).filter(([_, value]) => value !== void 0));
      return tiktok_schema_1.WebcastPushFrame.encode({
        seqId: undefinedNum,
        logId: undefinedNum,
        payloadEncoding: "pb",
        payloadType: "msg",
        payload: new Uint8Array(),
        service: undefinedNum,
        method: undefinedNum,
        headers: {},
        ...overrides
      });
    }
    exports2.createBaseWebcastPushFrame = createBaseWebcastPushFrame;
  }
});

// node_modules/tiktok-live-connector/dist/version.js
var require_version = __commonJS({
  "node_modules/tiktok-live-connector/dist/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERSION = void 0;
    exports2.VERSION = "2.1.0";
  }
});

// node_modules/tiktok-live-connector/dist/lib/config.js
var require_config = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SignConfig = exports2.Screen = exports2.Location = exports2.Device = exports2.Devices = exports2.UserAgents = exports2.Screens = exports2.Locations = void 0;
    var utilities_1 = require_utilities();
    var version_1 = require_version();
    exports2.Locations = [
      {
        "lang_country": "en-GB",
        "lang": "en",
        "country": "GB",
        "tz_name": "Europe/London"
      },
      {
        "lang_country": "en-CA",
        "lang": "en",
        "country": "CA",
        "tz_name": "America/Toronto"
      },
      {
        "lang_country": "en-AU",
        "lang": "en",
        "country": "AU",
        "tz_name": "Australia/Sydney"
      },
      {
        "lang_country": "en-NZ",
        "lang": "en",
        "country": "NZ",
        "tz_name": "Pacific/Auckland"
      },
      {
        "lang_country": "en-ZA",
        "lang": "en",
        "country": "ZA",
        "tz_name": "Africa/Johannesburg"
      },
      {
        "lang_country": "en-IE",
        "lang": "en",
        "country": "IE",
        "tz_name": "Europe/Dublin"
      },
      {
        "lang_country": "en-JM",
        "lang": "en",
        "country": "JM",
        "tz_name": "America/Jamaica"
      },
      {
        "lang_country": "en-BZ",
        "lang": "en",
        "country": "BZ",
        "tz_name": "America/Belize"
      },
      {
        "lang_country": "en-TT",
        "lang": "en",
        "country": "TT",
        "tz_name": "America/Port_of_Spain"
      }
    ];
    exports2.Screens = [
      {
        "screen_width": 1920,
        "screen_height": 1080
      },
      {
        "screen_width": 2560,
        "screen_height": 1440
      },
      {
        "screen_width": 3840,
        "screen_height": 2160
      },
      {
        "screen_width": 4096,
        "screen_height": 2160
      },
      {
        "screen_width": 5120,
        "screen_height": 2880
      },
      {
        "screen_width": 7680,
        "screen_height": 4320
      },
      {
        "screen_width": 1152,
        "screen_height": 2048
      },
      {
        "screen_width": 1440,
        "screen_height": 2560
      },
      {
        "screen_width": 2160,
        "screen_height": 3840
      },
      {
        "screen_width": 4320,
        "screen_height": 7680
      }
    ];
    exports2.UserAgents = [
      // Latest Chrome UA's -> https://www.whatismybrowser.com/guides/the-latest-user-agent/chrome
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36",
      "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36",
      // Latest Safari UA's -> https://www.whatismybrowser.com/guides/the-latest-user-agent/safari
      "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.6 Safari/605.1.15",
      // Latest Firefox UA's -> https://www.whatismybrowser.com/guides/the-latest-user-agent/firefox
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:130.0) Gecko/20100101 Firefox/130.0",
      "Mozilla/5.0 (Macintosh; Intel Mac OS X 14.7; rv:130.0) Gecko/20100101 Firefox/130.0",
      // Latest Edge UA's -> https://www.whatismybrowser.com/guides/the-latest-user-agent/edge
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/128.0.2739.79",
      "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 Edg/128.0.2739.79",
      // Latest Opera UA's -> https://www.whatismybrowser.com/guides/the-latest-user-agent/opera
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 OPR/113.0.0.0",
      "Mozilla/5.0 (Macintosh; Intel Mac OS X 14_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/129.0.0.0 Safari/537.36 OPR/113.0.0.0"
    ];
    exports2.Devices = exports2.UserAgents.map((userAgent) => (0, utilities_1.userAgentToDevicePreset)(userAgent));
    exports2.Device = process.env.RANDOMIZE_TIKTOK_DEVICE?.toLowerCase() === "true" ? exports2.Devices[Math.floor(Math.random() * exports2.Devices.length)] : exports2.Devices[6];
    exports2.Location = process.env.RANDOMIZE_TIKTOK_LOCATION?.toLowerCase() === "true" ? exports2.Locations[Math.floor(Math.random() * exports2.Locations.length)] : {
      lang_country: "en-DE",
      lang: "en",
      country: "DE",
      tz_name: "Europe/Berlin"
    };
    exports2.Screen = process.env.RANDOMIZE_TIKTOK_SCREEN?.toLowerCase() === "true" ? exports2.Screens[Math.floor(Math.random() * exports2.Screens.length)] : {
      screen_width: 1920,
      screen_height: 1080
    };
    var Config = {
      TIKTOK_HOST_WEB: "www.tiktok.com",
      TIKTOK_HOST_WEBCAST: "webcast.tiktok.com",
      TIKTOK_HTTP_ORIGIN: "https://www.tiktok.com",
      DEFAULT_HTTP_CLIENT_COOKIES: { "tt-target-idc": "useast1a" },
      DEFAULT_HTTP_CLIENT_OPTIONS: {},
      DEFAULT_HTTP_CLIENT_PARAMS: {
        "aid": 1988 .toString(),
        "app_language": exports2.Location["lang"],
        "app_name": "tiktok_web",
        "browser_language": exports2.Location["lang_country"],
        "browser_name": exports2.Device["browser_name"],
        "browser_online": "true",
        "browser_platform": exports2.Device["browser_platform"],
        "browser_version": exports2.Device["browser_version"],
        "cookie_enabled": "true",
        "device_platform": "web_pc",
        "focus_state": "true",
        "from_page": "user",
        "history_len": "10",
        "is_fullscreen": "false",
        "is_page_visible": "true",
        "screen_height": exports2.Screen["screen_height"].toString(),
        "screen_width": exports2.Screen["screen_width"].toString(),
        "tz_name": exports2.Location["tz_name"],
        "referer": "https://www.tiktok.com/",
        "root_referer": "https://www.tiktok.com/",
        "channel": "tiktok_web",
        "data_collection_enabled": "true",
        "os": exports2.Device["os"],
        "priority_region": exports2.Location["country"],
        "region": exports2.Location["country"],
        "user_is_login": "true",
        "webcast_language": exports2.Location["lang"],
        "device_id": (0, utilities_1.generateDeviceId)()
      },
      DEFAULT_WS_CLIENT_PARAMS: {
        "version_code": "180800",
        "aid": 1988 .toString(),
        "app_language": exports2.Location["lang"],
        "app_name": "tiktok_web",
        "browser_platform": exports2.Device["browser_platform"],
        "browser_language": exports2.Location["lang_country"],
        "browser_name": exports2.Device["browser_name"],
        "browser_version": exports2.Device["browser_version"],
        "browser_online": "true",
        "cookie_enabled": "true",
        "tz_name": exports2.Location["tz_name"],
        "device_platform": "web",
        "identity": "audience",
        "live_id": "12",
        "webcast_language": exports2.Location["lang"],
        "ws_direct": "0",
        "sup_ws_ds_opt": "1",
        "update_version_code": "2.0.0",
        "did_rule": "3",
        "screen_height": exports2.Screen["screen_height"].toString(),
        "screen_width": exports2.Screen["screen_width"].toString(),
        "heartbeat_duration": "0",
        "resp_content_type": "protobuf",
        "history_comment_count": "6",
        "client_enter": "1",
        "last_rtt": (Math.random() * 100 + 100).toString()
      },
      DEFAULT_WS_CLIENT_PARAMS_APPEND_PARAMETER: "&version_code=270000",
      DEFAULT_HTTP_CLIENT_HEADERS: {
        "Connection": "keep-alive",
        "Cache-Control": "max-age=0",
        "User-Agent": exports2.Device["user_agent"],
        "Accept": "text/html,application/json,application/protobuf",
        "Referer": "https://www.tiktok.com/",
        "Origin": "https://www.tiktok.com",
        "Accept-Language": "en-US,en;q=0.9",
        "Accept-Encoding": "gzip, deflate",
        "Sec-Fetch-Site": "same-site",
        "Sec-Fetch-Mode": "cors",
        "Sec-Fetch-Dest": "empty",
        "Sec-Fetch-Ua-Mobile": "?0"
      },
      DEFAULT_WS_CLIENT_HEADERS: {
        "User-Agent": exports2.Device["user_agent"]
      }
    };
    exports2.SignConfig = {
      basePath: process.env.SIGN_API_URL || "https://tiktok.eulerstream.com",
      apiKey: process.env.SIGN_API_KEY,
      baseOptions: {
        headers: { "User-Agent": `tiktok-live-connector/${version_1.VERSION} ${process.platform}` },
        validateStatus: () => true
      }
    };
    exports2.default = Config;
  }
});

// node_modules/tiktok-live-connector/dist/types/client.js
var require_client = __commonJS({
  "node_modules/tiktok-live-connector/dist/types/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/tiktok-live-connector/dist/types/events.js
var require_events = __commonJS({
  "node_modules/tiktok-live-connector/dist/types/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebcastEventMap = exports2.ConnectState = exports2.WebcastEvent = exports2.ControlEvent = void 0;
    var ControlEvent;
    (function(ControlEvent2) {
      ControlEvent2["CONNECTED"] = "connected";
      ControlEvent2["DISCONNECTED"] = "disconnected";
      ControlEvent2["ERROR"] = "error";
      ControlEvent2["RAW_DATA"] = "rawData";
      ControlEvent2["DECODED_DATA"] = "decodedData";
      ControlEvent2["WEBSOCKET_CONNECTED"] = "websocketConnected";
      ControlEvent2["WEBSOCKET_DATA"] = "websocketData";
      ControlEvent2["ENTER_ROOM"] = "enterRoom";
    })(ControlEvent = exports2.ControlEvent || (exports2.ControlEvent = {}));
    var WebcastEvent;
    (function(WebcastEvent2) {
      WebcastEvent2["CHAT"] = "chat";
      WebcastEvent2["MEMBER"] = "member";
      WebcastEvent2["GIFT"] = "gift";
      WebcastEvent2["ROOM_USER"] = "roomUser";
      WebcastEvent2["SOCIAL"] = "social";
      WebcastEvent2["LIKE"] = "like";
      WebcastEvent2["QUESTION_NEW"] = "questionNew";
      WebcastEvent2["LINK_MIC_BATTLE"] = "linkMicBattle";
      WebcastEvent2["LINK_MIC_ARMIES"] = "linkMicArmies";
      WebcastEvent2["LIVE_INTRO"] = "liveIntro";
      WebcastEvent2["EMOTE"] = "emote";
      WebcastEvent2["ENVELOPE"] = "envelope";
      WebcastEvent2["FOLLOW"] = "follow";
      WebcastEvent2["SHARE"] = "share";
      WebcastEvent2["STREAM_END"] = "streamEnd";
      WebcastEvent2["CONTROL_MESSAGE"] = "controlMessage";
      WebcastEvent2["BARRAGE"] = "barrage";
      WebcastEvent2["HOURLY_RANK"] = "hourlyRank";
      WebcastEvent2["GOAL_UPDATE"] = "goalUpdate";
      WebcastEvent2["ROOM_MESSAGE"] = "roomMessage";
      WebcastEvent2["CAPTION_MESSAGE"] = "captionMessage";
      WebcastEvent2["IM_DELETE"] = "imDelete";
      WebcastEvent2["IN_ROOM_BANNER"] = "inRoomBanner";
      WebcastEvent2["RANK_UPDATE"] = "rankUpdate";
      WebcastEvent2["POLL_MESSAGE"] = "pollMessage";
      WebcastEvent2["RANK_TEXT"] = "rankText";
      WebcastEvent2["LINK_MIC_BATTLE_PUNISH_FINISH"] = "linkMicBattlePunishFinish";
      WebcastEvent2["LINK_MIC_BATTLE_TASK"] = "linkMicBattleTask";
      WebcastEvent2["LINK_MIC_FAN_TICKET_METHOD"] = "linkMicFanTicketMethod";
      WebcastEvent2["LINK_MIC_METHOD"] = "linkMicMethod";
      WebcastEvent2["UNAUTHORIZED_MEMBER"] = "unauthorizedMember";
      WebcastEvent2["OEC_LIVE_SHOPPING"] = "oecLiveShopping";
      WebcastEvent2["MSG_DETECT"] = "msgDetect";
      WebcastEvent2["LINK_MESSAGE"] = "linkMessage";
      WebcastEvent2["ROOM_VERIFY"] = "roomVerify";
      WebcastEvent2["LINK_LAYER"] = "linkLayer";
      WebcastEvent2["ROOM_PIN"] = "roomPin";
      WebcastEvent2["SUPER_FAN"] = "superFan";
    })(WebcastEvent = exports2.WebcastEvent || (exports2.WebcastEvent = {}));
    var ConnectState;
    (function(ConnectState2) {
      ConnectState2["DISCONNECTED"] = "DISCONNECTED";
      ConnectState2["CONNECTING"] = "CONNECTING";
      ConnectState2["CONNECTED"] = "CONNECTED";
    })(ConnectState = exports2.ConnectState || (exports2.ConnectState = {}));
    exports2.WebcastEventMap = {
      // Old Events - Added 1.X.X
      "WebcastChatMessage": WebcastEvent.CHAT,
      "WebcastMemberMessage": WebcastEvent.MEMBER,
      "WebcastRoomUserSeqMessage": WebcastEvent.ROOM_USER,
      "WebcastSocialMessage": WebcastEvent.SOCIAL,
      "WebcastLikeMessage": WebcastEvent.LIKE,
      "WebcastQuestionNewMessage": WebcastEvent.QUESTION_NEW,
      "WebcastLinkMicBattle": WebcastEvent.LINK_MIC_BATTLE,
      "WebcastLinkMicArmies": WebcastEvent.LINK_MIC_ARMIES,
      "WebcastLiveIntroMessage": WebcastEvent.LIVE_INTRO,
      "WebcastEmoteChatMessage": WebcastEvent.EMOTE,
      "WebcastEnvelopeMessage": WebcastEvent.ENVELOPE,
      "WebcastBarrageMessage": WebcastEvent.BARRAGE,
      // New Events - Added 2.0.4
      "WebcastHourlyRankMessage": WebcastEvent.HOURLY_RANK,
      "WebcastGoalUpdateMessage": WebcastEvent.GOAL_UPDATE,
      "WebcastRoomMessage": WebcastEvent.ROOM_MESSAGE,
      "WebcastCaptionMessage": WebcastEvent.CAPTION_MESSAGE,
      "WebcastControlMessage": WebcastEvent.CONTROL_MESSAGE,
      "WebcastImDeleteMessage": WebcastEvent.IM_DELETE,
      "WebcastInRoomBannerMessage": WebcastEvent.IN_ROOM_BANNER,
      "WebcastRankUpdateMessage": WebcastEvent.RANK_UPDATE,
      "WebcastPollMessage": WebcastEvent.POLL_MESSAGE,
      "WebcastRankTextMessage": WebcastEvent.RANK_TEXT,
      "WebcastLinkMicBattlePunishFinish": WebcastEvent.LINK_MIC_BATTLE_PUNISH_FINISH,
      "WebcastLinkmicBattleTaskMessage": WebcastEvent.LINK_MIC_BATTLE_TASK,
      "WebcastLinkMicFanTicketMethod": WebcastEvent.LINK_MIC_FAN_TICKET_METHOD,
      "WebcastLinkMicMethod": WebcastEvent.LINK_MIC_METHOD,
      "WebcastUnauthorizedMemberMessage": WebcastEvent.UNAUTHORIZED_MEMBER,
      "WebcastOecLiveShoppingMessage": WebcastEvent.OEC_LIVE_SHOPPING,
      "WebcastMsgDetectMessage": WebcastEvent.MSG_DETECT,
      "WebcastLinkMessage": WebcastEvent.LINK_MESSAGE,
      "RoomVerifyMessage": WebcastEvent.ROOM_VERIFY,
      "WebcastLinkLayerMessage": WebcastEvent.LINK_LAYER,
      "WebcastRoomPinMessage": WebcastEvent.ROOM_PIN
    };
  }
});

// node_modules/callable-instance/index.js
var require_callable_instance = __commonJS({
  "node_modules/callable-instance/index.js"(exports2, module2) {
    function CallableInstance(property) {
      var func = this.constructor.prototype[property];
      var apply = function() {
        return func.apply(apply, arguments);
      };
      Object.setPrototypeOf(apply, this.constructor.prototype);
      Object.getOwnPropertyNames(func).forEach(function(p) {
        Object.defineProperty(apply, p, Object.getOwnPropertyDescriptor(func, p));
      });
      return apply;
    }
    CallableInstance.prototype = Object.create(Function.prototype);
    module2.exports = CallableInstance;
  }
});

// node_modules/tiktok-live-connector/dist/types/route.js
var require_route = __commonJS({
  "node_modules/tiktok-live-connector/dist/types/route.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Route = void 0;
    var callable_instance_1 = __importDefault(require_callable_instance());
    var Route = class extends callable_instance_1.default {
      webClient;
      constructor(webClient) {
        super("call");
        this.webClient = webClient;
      }
    };
    exports2.Route = Route;
  }
});

// node_modules/tiktok-live-connector/dist/types/index.js
var require_types = __commonJS({
  "node_modules/tiktok-live-connector/dist/types/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_client(), exports2);
    __exportStar(require_errors(), exports2);
    __exportStar(require_events(), exports2);
    __exportStar(require_route(), exports2);
    __exportStar(require_tiktok_schema(), exports2);
  }
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
    var hasBlob = typeof Blob !== "undefined";
    if (hasBlob) BINARY_TYPES.push("blob");
    module2.exports = {
      BINARY_TYPES,
      CLOSE_TIMEOUT: 3e4,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob,
      kForOnEventAttribute: /* @__PURE__ */ Symbol("kIsForOnEventAttribute"),
      kListener: /* @__PURE__ */ Symbol("kListener"),
      kStatusCode: /* @__PURE__ */ Symbol("status-code"),
      kWebSocket: /* @__PURE__ */ Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48) _mask(source, mask, output, offset, length);
          else bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = /* @__PURE__ */ Symbol("kDone");
    var kRun = /* @__PURE__ */ Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = /* @__PURE__ */ Symbol("permessage-deflate");
    var kTotalLength = /* @__PURE__ */ Symbol("total-length");
    var kCallback = /* @__PURE__ */ Symbol("callback");
    var kBuffers = /* @__PURE__ */ Symbol("buffers");
    var kError = /* @__PURE__ */ Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      if (this[kError]) {
        this[kCallback](this[kError]);
        return;
      }
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var { hasBlob } = require_constants();
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob(value) {
      return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
    }
    module2.exports = {
      isBlob,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n,
            buf.length - n
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n,
              buf.length - n
            );
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
    var { isBlob, isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = /* @__PURE__ */ Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP;
        this[kWebSocket] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while the blob was being read"
            );
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          const data = toBuffer(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(_Sender.frame(data, options), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {(Buffer | String)[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === "function") cb(err);
      for (let i = 0; i < sender._queue.length; i++) {
        const params = sender._queue[i];
        const callback = params[params.length - 1];
        if (typeof callback === "function") callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = /* @__PURE__ */ Symbol("kCode");
    var kData = /* @__PURE__ */ Symbol("kData");
    var kError = /* @__PURE__ */ Symbol("kError");
    var kMessage = /* @__PURE__ */ Symbol("kMessage");
    var kReason = /* @__PURE__ */ Symbol("kReason");
    var kTarget = /* @__PURE__ */ Symbol("kTarget");
    var kType = /* @__PURE__ */ Symbol("kType");
    var kWasClean = /* @__PURE__ */ Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [elem];
      else dest[name].push(elem);
    }
    function parse(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1) start = i;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values)) values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var { isBlob } = require_validation();
    var {
      BINARY_TYPES,
      CLOSE_TIMEOUT,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var kAborted = /* @__PURE__ */ Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class _WebSocket extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._closeTimeout = options.closeTimeout;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        const sender = new Sender(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        closeTimeout: CLOSE_TIMEOUT,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      websocket._closeTimeout = opts.closeTimeout;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = isBlob(data) ? data.size : toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket2.CLOSED) return;
      if (websocket.readyState === WebSocket2.OPEN) {
        websocket._readyState = WebSocket2.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(
        websocket._socket.destroy.bind(websocket._socket),
        websocket._closeTimeout
      );
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && this._readableState.length !== 0) {
        const chunk = this.read(this._readableState.length);
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1) end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var { Duplex } = require("stream");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { CLOSE_TIMEOUT, GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Number} [options.closeTimeout=30000] Duration in milliseconds to
       *     wait for the closing handshake to finish after `websocket.close()` is
       *     called
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          closeTimeout: CLOSE_TIMEOUT,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version !== 13 && version !== 8) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
            "Sec-WebSocket-Version": "13, 8"
          });
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map)) server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message, headers);
      }
    }
  }
});

// node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    WebSocket2.createWebSocketStream = require_stream();
    WebSocket2.Server = require_websocket_server();
    WebSocket2.Receiver = require_receiver();
    WebSocket2.Sender = require_sender();
    WebSocket2.WebSocket = WebSocket2;
    WebSocket2.WebSocketServer = WebSocket2.Server;
    module2.exports = WebSocket2;
  }
});

// node_modules/tiktok-live-connector/dist/lib/ws/lib/ws-client.js
var require_ws_client = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/ws/lib/ws-client.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utilities_1 = require_utilities();
    var config_1 = __importDefault(require_config());
    var types_1 = require_types();
    var ws_1 = require_ws();
    var textEncoder = new TextEncoder();
    var TikTokWsClient = class extends ws_1.WebSocket {
      webSocketParams;
      webSocketPingIntervalMs;
      pingInterval;
      // Incremental sequence ID for messages, goes up for each heartbeat sent, starts at 1
      // Important for mobile compatibility
      seqId = 1;
      constructor(wsUrl, cookieJar, webSocketParams, webSocketHeaders = {}, webSocketOptions, webSocketPingIntervalMs = 1e4) {
        const wsHeaders = { ...webSocketHeaders, Cookie: cookieJar.getCookieString(webSocketHeaders) };
        const wsUrlWithParams = `${wsUrl}?${new URLSearchParams(webSocketParams)}${config_1.default.DEFAULT_WS_CLIENT_PARAMS_APPEND_PARAMETER}`;
        super(wsUrlWithParams, {
          headers: wsHeaders,
          host: `https://${config_1.default.TIKTOK_HOST_WEB}`,
          ...webSocketOptions,
          autoPong: false
        });
        this.webSocketParams = webSocketParams;
        this.webSocketPingIntervalMs = webSocketPingIntervalMs;
        this.pingInterval = null;
        this.on("message", this.onMessage.bind(this));
        this.on("close", this.onDisconnect.bind(this));
      }
      get open() {
        return this.readyState === ws_1.WebSocket.OPEN;
      }
      /**
       * Send a message to the WebSocket server
       * @param data The message to send
       * @returns True if the message was sent, false otherwise
       */
      sendBytes(data) {
        if (this.open) {
          super.send(Buffer.from(data));
          return true;
        }
        return false;
      }
      onDisconnect() {
        clearInterval(this.pingInterval);
        this.pingInterval = null;
        this.seqId = 1;
      }
      /**
       * Handle incoming messages
       * @param message The incoming WebSocket message (type => Buffer)
       * @protected
       */
      async onMessage(message) {
        this.emit("webSocketData", message);
        try {
          const decodedContainer = await (0, utilities_1.deserializeWebSocketMessage)(message);
          if (decodedContainer.protoMessageFetchResult) {
            if (decodedContainer.protoMessageFetchResult.needsAck) {
              this.sendAck(decodedContainer);
            }
            this.emit("protoMessageFetchResult", decodedContainer.protoMessageFetchResult);
          }
          if (decodedContainer.payloadType === "im_enter_room_resp") {
            this.emit("imEnteredRoom", decodedContainer);
          }
        } catch (err) {
          this.emit("messageDecodingFailed", err);
        }
      }
      /**
       * Static Keep-Alive ping
       */
      sendHeartbeat() {
        const { room_id } = this.webSocketParams;
        const hb = types_1.HeartbeatMessage.encode({ roomId: room_id, sendPacketSeqId: "1" });
        const webcastPushFrame = (0, utilities_1.createBaseWebcastPushFrame)({
          payloadEncoding: "pb",
          payloadType: "hb",
          payload: hb.finish(),
          service: void 0,
          method: void 0,
          headers: {}
        });
        this.sendBytes(Buffer.from(webcastPushFrame.finish()));
        this.seqId++;
      }
      /**
       * EXPERIMENTAL: Switch to a different TikTok LIVE room while connected to the WebSocket
       * @param roomId The room ID to switch to
       */
      switchRooms(roomId) {
        this.seqId = 1;
        const imEnterRoomMessage = types_1.WebcastImEnterRoomMessage.encode({
          roomId,
          roomTag: "",
          liveRegion: "",
          liveId: "12",
          identity: "audience",
          cursor: "",
          accountType: "0",
          enterUniqueId: "",
          filterWelcomeMsg: "0",
          isAnchorContinueKeepMsg: false
        });
        const webcastPushFrame = (0, utilities_1.createBaseWebcastPushFrame)({
          payloadEncoding: "pb",
          payloadType: "im_enter_room",
          payload: imEnterRoomMessage.finish()
        });
        this.sendBytes(Buffer.from(webcastPushFrame.finish()));
        clearInterval(this.pingInterval);
        this.pingInterval = setInterval(() => this.sendHeartbeat(), this.webSocketPingIntervalMs);
      }
      /**
       * Acknowledge the message was received
       */
      sendAck({ logId, protoMessageFetchResult: { internalExt } }) {
        if (!logId) {
          return;
        }
        const webcastPushFrame = (0, utilities_1.createBaseWebcastPushFrame)({
          logId,
          payloadEncoding: "pb",
          payloadType: "ack",
          payload: textEncoder.encode(internalExt)
        });
        this.sendBytes(Buffer.from(webcastPushFrame.finish()));
      }
    };
    exports2.default = TikTokWsClient;
  }
});

// node_modules/delayed-stream/lib/delayed_stream.js
var require_delayed_stream = __commonJS({
  "node_modules/delayed-stream/lib/delayed_stream.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var util = require("util");
    module2.exports = DelayedStream;
    function DelayedStream() {
      this.source = null;
      this.dataSize = 0;
      this.maxDataSize = 1024 * 1024;
      this.pauseStream = true;
      this._maxDataSizeExceeded = false;
      this._released = false;
      this._bufferedEvents = [];
    }
    util.inherits(DelayedStream, Stream);
    DelayedStream.create = function(source, options) {
      var delayedStream = new this();
      options = options || {};
      for (var option in options) {
        delayedStream[option] = options[option];
      }
      delayedStream.source = source;
      var realEmit = source.emit;
      source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
      };
      source.on("error", function() {
      });
      if (delayedStream.pauseStream) {
        source.pause();
      }
      return delayedStream;
    };
    Object.defineProperty(DelayedStream.prototype, "readable", {
      configurable: true,
      enumerable: true,
      get: function() {
        return this.source.readable;
      }
    });
    DelayedStream.prototype.setEncoding = function() {
      return this.source.setEncoding.apply(this.source, arguments);
    };
    DelayedStream.prototype.resume = function() {
      if (!this._released) {
        this.release();
      }
      this.source.resume();
    };
    DelayedStream.prototype.pause = function() {
      this.source.pause();
    };
    DelayedStream.prototype.release = function() {
      this._released = true;
      this._bufferedEvents.forEach(function(args) {
        this.emit.apply(this, args);
      }.bind(this));
      this._bufferedEvents = [];
    };
    DelayedStream.prototype.pipe = function() {
      var r = Stream.prototype.pipe.apply(this, arguments);
      this.resume();
      return r;
    };
    DelayedStream.prototype._handleEmit = function(args) {
      if (this._released) {
        this.emit.apply(this, args);
        return;
      }
      if (args[0] === "data") {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
      }
      this._bufferedEvents.push(args);
    };
    DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
      if (this._maxDataSizeExceeded) {
        return;
      }
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      this._maxDataSizeExceeded = true;
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this.emit("error", new Error(message));
    };
  }
});

// node_modules/combined-stream/lib/combined_stream.js
var require_combined_stream = __commonJS({
  "node_modules/combined-stream/lib/combined_stream.js"(exports2, module2) {
    var util = require("util");
    var Stream = require("stream").Stream;
    var DelayedStream = require_delayed_stream();
    module2.exports = CombinedStream;
    function CombinedStream() {
      this.writable = false;
      this.readable = true;
      this.dataSize = 0;
      this.maxDataSize = 2 * 1024 * 1024;
      this.pauseStreams = true;
      this._released = false;
      this._streams = [];
      this._currentStream = null;
      this._insideLoop = false;
      this._pendingNext = false;
    }
    util.inherits(CombinedStream, Stream);
    CombinedStream.create = function(options) {
      var combinedStream = new this();
      options = options || {};
      for (var option in options) {
        combinedStream[option] = options[option];
      }
      return combinedStream;
    };
    CombinedStream.isStreamLike = function(stream) {
      return typeof stream !== "function" && typeof stream !== "string" && typeof stream !== "boolean" && typeof stream !== "number" && !Buffer.isBuffer(stream);
    };
    CombinedStream.prototype.append = function(stream) {
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
          var newStream = DelayedStream.create(stream, {
            maxDataSize: Infinity,
            pauseStream: this.pauseStreams
          });
          stream.on("data", this._checkDataSize.bind(this));
          stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
          stream.pause();
        }
      }
      this._streams.push(stream);
      return this;
    };
    CombinedStream.prototype.pipe = function(dest, options) {
      Stream.prototype.pipe.call(this, dest, options);
      this.resume();
      return dest;
    };
    CombinedStream.prototype._getNext = function() {
      this._currentStream = null;
      if (this._insideLoop) {
        this._pendingNext = true;
        return;
      }
      this._insideLoop = true;
      try {
        do {
          this._pendingNext = false;
          this._realGetNext();
        } while (this._pendingNext);
      } finally {
        this._insideLoop = false;
      }
    };
    CombinedStream.prototype._realGetNext = function() {
      var stream = this._streams.shift();
      if (typeof stream == "undefined") {
        this.end();
        return;
      }
      if (typeof stream !== "function") {
        this._pipeNext(stream);
        return;
      }
      var getStream = stream;
      getStream(function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("data", this._checkDataSize.bind(this));
          this._handleErrors(stream2);
        }
        this._pipeNext(stream2);
      }.bind(this));
    };
    CombinedStream.prototype._pipeNext = function(stream) {
      this._currentStream = stream;
      var isStreamLike = CombinedStream.isStreamLike(stream);
      if (isStreamLike) {
        stream.on("end", this._getNext.bind(this));
        stream.pipe(this, { end: false });
        return;
      }
      var value = stream;
      this.write(value);
      this._getNext();
    };
    CombinedStream.prototype._handleErrors = function(stream) {
      var self2 = this;
      stream.on("error", function(err) {
        self2._emitError(err);
      });
    };
    CombinedStream.prototype.write = function(data) {
      this.emit("data", data);
    };
    CombinedStream.prototype.pause = function() {
      if (!this.pauseStreams) {
        return;
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
      this.emit("pause");
    };
    CombinedStream.prototype.resume = function() {
      if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
      }
      if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
      this.emit("resume");
    };
    CombinedStream.prototype.end = function() {
      this._reset();
      this.emit("end");
    };
    CombinedStream.prototype.destroy = function() {
      this._reset();
      this.emit("close");
    };
    CombinedStream.prototype._reset = function() {
      this.writable = false;
      this._streams = [];
      this._currentStream = null;
    };
    CombinedStream.prototype._checkDataSize = function() {
      this._updateDataSize();
      if (this.dataSize <= this.maxDataSize) {
        return;
      }
      var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
      this._emitError(new Error(message));
    };
    CombinedStream.prototype._updateDataSize = function() {
      this.dataSize = 0;
      var self2 = this;
      this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
          return;
        }
        self2.dataSize += stream.dataSize;
      });
      if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
      }
    };
    CombinedStream.prototype._emitError = function(err) {
      this._reset();
      this.emit("error", err);
    };
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports2) {
    "use strict";
    var db = require_mime_db();
    var extname = require("path").extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports2.charset = charset;
    exports2.charsets = { lookup: charset };
    exports2.contentType = contentType;
    exports2.extension = extension;
    exports2.extensions = /* @__PURE__ */ Object.create(null);
    exports2.lookup = lookup;
    exports2.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports2.extensions, exports2.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports2.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports2.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports2.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports2.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/asynckit/lib/defer.js
var require_defer = __commonJS({
  "node_modules/asynckit/lib/defer.js"(exports2, module2) {
    module2.exports = defer;
    function defer(fn) {
      var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
      if (nextTick) {
        nextTick(fn);
      } else {
        setTimeout(fn, 0);
      }
    }
  }
});

// node_modules/asynckit/lib/async.js
var require_async = __commonJS({
  "node_modules/asynckit/lib/async.js"(exports2, module2) {
    var defer = require_defer();
    module2.exports = async;
    function async(callback) {
      var isAsync = false;
      defer(function() {
        isAsync = true;
      });
      return function async_callback(err, result) {
        if (isAsync) {
          callback(err, result);
        } else {
          defer(function nextTick_callback() {
            callback(err, result);
          });
        }
      };
    }
  }
});

// node_modules/asynckit/lib/abort.js
var require_abort = __commonJS({
  "node_modules/asynckit/lib/abort.js"(exports2, module2) {
    module2.exports = abort;
    function abort(state) {
      Object.keys(state.jobs).forEach(clean.bind(state));
      state.jobs = {};
    }
    function clean(key) {
      if (typeof this.jobs[key] == "function") {
        this.jobs[key]();
      }
    }
  }
});

// node_modules/asynckit/lib/iterate.js
var require_iterate = __commonJS({
  "node_modules/asynckit/lib/iterate.js"(exports2, module2) {
    var async = require_async();
    var abort = require_abort();
    module2.exports = iterate;
    function iterate(list, iterator, state, callback) {
      var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
      state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        if (!(key in state.jobs)) {
          return;
        }
        delete state.jobs[key];
        if (error) {
          abort(state);
        } else {
          state.results[key] = output;
        }
        callback(error, state.results);
      });
    }
    function runJob(iterator, key, item, callback) {
      var aborter;
      if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
      } else {
        aborter = iterator(item, key, async(callback));
      }
      return aborter;
    }
  }
});

// node_modules/asynckit/lib/state.js
var require_state = __commonJS({
  "node_modules/asynckit/lib/state.js"(exports2, module2) {
    module2.exports = state;
    function state(list, sortMethod) {
      var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
      };
      if (sortMethod) {
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
          return sortMethod(list[a], list[b]);
        });
      }
      return initState;
    }
  }
});

// node_modules/asynckit/lib/terminator.js
var require_terminator = __commonJS({
  "node_modules/asynckit/lib/terminator.js"(exports2, module2) {
    var abort = require_abort();
    var async = require_async();
    module2.exports = terminator;
    function terminator(callback) {
      if (!Object.keys(this.jobs).length) {
        return;
      }
      this.index = this.size;
      abort(this);
      async(callback)(null, this.results);
    }
  }
});

// node_modules/asynckit/parallel.js
var require_parallel = __commonJS({
  "node_modules/asynckit/parallel.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = parallel;
    function parallel(list, iterator, callback) {
      var state = initState(list);
      while (state.index < (state["keyedList"] || list).length) {
        iterate(list, iterator, state, function(error, result) {
          if (error) {
            callback(error, result);
            return;
          }
          if (Object.keys(state.jobs).length === 0) {
            callback(null, state.results);
            return;
          }
        });
        state.index++;
      }
      return terminator.bind(state, callback);
    }
  }
});

// node_modules/asynckit/serialOrdered.js
var require_serialOrdered = __commonJS({
  "node_modules/asynckit/serialOrdered.js"(exports2, module2) {
    var iterate = require_iterate();
    var initState = require_state();
    var terminator = require_terminator();
    module2.exports = serialOrdered;
    module2.exports.ascending = ascending;
    module2.exports.descending = descending;
    function serialOrdered(list, iterator, sortMethod, callback) {
      var state = initState(list, sortMethod);
      iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
          callback(error, result);
          return;
        }
        state.index++;
        if (state.index < (state["keyedList"] || list).length) {
          iterate(list, iterator, state, iteratorHandler);
          return;
        }
        callback(null, state.results);
      });
      return terminator.bind(state, callback);
    }
    function ascending(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }
    function descending(a, b) {
      return -1 * ascending(a, b);
    }
  }
});

// node_modules/asynckit/serial.js
var require_serial = __commonJS({
  "node_modules/asynckit/serial.js"(exports2, module2) {
    var serialOrdered = require_serialOrdered();
    module2.exports = serial;
    function serial(list, iterator, callback) {
      return serialOrdered(list, iterator, null, callback);
    }
  }
});

// node_modules/asynckit/index.js
var require_asynckit = __commonJS({
  "node_modules/asynckit/index.js"(exports2, module2) {
    module2.exports = {
      parallel: require_parallel(),
      serial: require_serial(),
      serialOrdered: require_serialOrdered()
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports2, module2) {
    "use strict";
    module2.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports2, module2) {
    "use strict";
    module2.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports2, module2) {
    "use strict";
    var $isNaN = require_isNaN();
    module2.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports2, module2) {
    "use strict";
    module2.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = /* @__PURE__ */ Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof /* @__PURE__ */ Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports2, module2) {
    "use strict";
    var $Object = require_es_object_atoms();
    module2.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports2, module2) {
    "use strict";
    module2.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module2.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module2.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports2, module2) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module2.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports2, module2) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module2.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? (function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    })() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/es-set-tostringtag/index.js
var require_es_set_tostringtag = __commonJS({
  "node_modules/es-set-tostringtag/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var $TypeError = require_type();
    var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
    module2.exports = function setToStringTag(object, value) {
      var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
      var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
      if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
        throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
      }
      if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
          $defineProperty(object, toStringTag, {
            configurable: !nonConfigurable,
            enumerable: false,
            value,
            writable: false
          });
        } else {
          object[toStringTag] = value;
        }
      }
    };
  }
});

// node_modules/form-data/lib/populate.js
var require_populate = __commonJS({
  "node_modules/form-data/lib/populate.js"(exports2, module2) {
    "use strict";
    module2.exports = function(dst, src) {
      Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
      });
      return dst;
    };
  }
});

// node_modules/form-data/lib/form_data.js
var require_form_data = __commonJS({
  "node_modules/form-data/lib/form_data.js"(exports2, module2) {
    "use strict";
    var CombinedStream = require_combined_stream();
    var util = require("util");
    var path = require("path");
    var http = require("http");
    var https = require("https");
    var parseUrl = require("url").parse;
    var fs = require("fs");
    var Stream = require("stream").Stream;
    var crypto = require("crypto");
    var mime = require_mime_types();
    var asynckit = require_asynckit();
    var setToStringTag = require_es_set_tostringtag();
    var hasOwn = require_hasown();
    var populate = require_populate();
    function FormData2(options) {
      if (!(this instanceof FormData2)) {
        return new FormData2(options);
      }
      this._overheadLength = 0;
      this._valueLength = 0;
      this._valuesToMeasure = [];
      CombinedStream.call(this);
      options = options || {};
      for (var option in options) {
        this[option] = options[option];
      }
    }
    util.inherits(FormData2, CombinedStream);
    FormData2.LINE_BREAK = "\r\n";
    FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
    FormData2.prototype.append = function(field, value, options) {
      options = options || {};
      if (typeof options === "string") {
        options = { filename: options };
      }
      var append = CombinedStream.prototype.append.bind(this);
      if (typeof value === "number" || value == null) {
        value = String(value);
      }
      if (Array.isArray(value)) {
        this._error(new Error("Arrays are not supported."));
        return;
      }
      var header = this._multiPartHeader(field, value, options);
      var footer = this._multiPartFooter();
      append(header);
      append(value);
      append(footer);
      this._trackLength(header, value, options);
    };
    FormData2.prototype._trackLength = function(header, value, options) {
      var valueLength = 0;
      if (options.knownLength != null) {
        valueLength += Number(options.knownLength);
      } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
      } else if (typeof value === "string") {
        valueLength = Buffer.byteLength(value);
      }
      this._valueLength += valueLength;
      this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
      if (!value || !value.path && !(value.readable && hasOwn(value, "httpVersion")) && !(value instanceof Stream)) {
        return;
      }
      if (!options.knownLength) {
        this._valuesToMeasure.push(value);
      }
    };
    FormData2.prototype._lengthRetriever = function(value, callback) {
      if (hasOwn(value, "fd")) {
        if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
          callback(null, value.end + 1 - (value.start ? value.start : 0));
        } else {
          fs.stat(value.path, function(err, stat) {
            if (err) {
              callback(err);
              return;
            }
            var fileSize = stat.size - (value.start ? value.start : 0);
            callback(null, fileSize);
          });
        }
      } else if (hasOwn(value, "httpVersion")) {
        callback(null, Number(value.headers["content-length"]));
      } else if (hasOwn(value, "httpModule")) {
        value.on("response", function(response) {
          value.pause();
          callback(null, Number(response.headers["content-length"]));
        });
        value.resume();
      } else {
        callback("Unknown stream");
      }
    };
    FormData2.prototype._multiPartHeader = function(field, value, options) {
      if (typeof options.header === "string") {
        return options.header;
      }
      var contentDisposition = this._getContentDisposition(value, options);
      var contentType = this._getContentType(value, options);
      var contents = "";
      var headers = {
        // add custom disposition as third element or keep it two elements if not
        "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        "Content-Type": [].concat(contentType || [])
      };
      if (typeof options.header === "object") {
        populate(headers, options.header);
      }
      var header;
      for (var prop in headers) {
        if (hasOwn(headers, prop)) {
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
          }
        }
      }
      return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
    };
    FormData2.prototype._getContentDisposition = function(value, options) {
      var filename;
      if (typeof options.filepath === "string") {
        filename = path.normalize(options.filepath).replace(/\\/g, "/");
      } else if (options.filename || value && (value.name || value.path)) {
        filename = path.basename(options.filename || value && (value.name || value.path));
      } else if (value && value.readable && hasOwn(value, "httpVersion")) {
        filename = path.basename(value.client._httpMessage.path || "");
      }
      if (filename) {
        return 'filename="' + filename + '"';
      }
    };
    FormData2.prototype._getContentType = function(value, options) {
      var contentType = options.contentType;
      if (!contentType && value && value.name) {
        contentType = mime.lookup(value.name);
      }
      if (!contentType && value && value.path) {
        contentType = mime.lookup(value.path);
      }
      if (!contentType && value && value.readable && hasOwn(value, "httpVersion")) {
        contentType = value.headers["content-type"];
      }
      if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
      }
      if (!contentType && value && typeof value === "object") {
        contentType = FormData2.DEFAULT_CONTENT_TYPE;
      }
      return contentType;
    };
    FormData2.prototype._multiPartFooter = function() {
      return function(next) {
        var footer = FormData2.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
          footer += this._lastBoundary();
        }
        next(footer);
      }.bind(this);
    };
    FormData2.prototype._lastBoundary = function() {
      return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
    };
    FormData2.prototype.getHeaders = function(userHeaders) {
      var header;
      var formHeaders = {
        "content-type": "multipart/form-data; boundary=" + this.getBoundary()
      };
      for (header in userHeaders) {
        if (hasOwn(userHeaders, header)) {
          formHeaders[header.toLowerCase()] = userHeaders[header];
        }
      }
      return formHeaders;
    };
    FormData2.prototype.setBoundary = function(boundary) {
      if (typeof boundary !== "string") {
        throw new TypeError("FormData boundary must be a string");
      }
      this._boundary = boundary;
    };
    FormData2.prototype.getBoundary = function() {
      if (!this._boundary) {
        this._generateBoundary();
      }
      return this._boundary;
    };
    FormData2.prototype.getBuffer = function() {
      var dataBuffer = new Buffer.alloc(0);
      var boundary = this.getBoundary();
      for (var i = 0, len = this._streams.length; i < len; i++) {
        if (typeof this._streams[i] !== "function") {
          if (Buffer.isBuffer(this._streams[i])) {
            dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
          } else {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
          }
          if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
            dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
          }
        }
      }
      return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
    };
    FormData2.prototype._generateBoundary = function() {
      this._boundary = "--------------------------" + crypto.randomBytes(12).toString("hex");
    };
    FormData2.prototype.getLengthSync = function() {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this.hasKnownLength()) {
        this._error(new Error("Cannot calculate proper length in synchronous way."));
      }
      return knownLength;
    };
    FormData2.prototype.hasKnownLength = function() {
      var hasKnownLength = true;
      if (this._valuesToMeasure.length) {
        hasKnownLength = false;
      }
      return hasKnownLength;
    };
    FormData2.prototype.getLength = function(cb) {
      var knownLength = this._overheadLength + this._valueLength;
      if (this._streams.length) {
        knownLength += this._lastBoundary().length;
      }
      if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
      }
      asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
          cb(err);
          return;
        }
        values.forEach(function(length) {
          knownLength += length;
        });
        cb(null, knownLength);
      });
    };
    FormData2.prototype.submit = function(params, cb) {
      var request;
      var options;
      var defaults = { method: "post" };
      if (typeof params === "string") {
        params = parseUrl(params);
        options = populate({
          port: params.port,
          path: params.pathname,
          host: params.hostname,
          protocol: params.protocol
        }, defaults);
      } else {
        options = populate(params, defaults);
        if (!options.port) {
          options.port = options.protocol === "https:" ? 443 : 80;
        }
      }
      options.headers = this.getHeaders(params.headers);
      if (options.protocol === "https:") {
        request = https.request(options);
      } else {
        request = http.request(options);
      }
      this.getLength(function(err, length) {
        if (err && err !== "Unknown stream") {
          this._error(err);
          return;
        }
        if (length) {
          request.setHeader("Content-Length", length);
        }
        this.pipe(request);
        if (cb) {
          var onResponse;
          var callback = function(error, responce) {
            request.removeListener("error", callback);
            request.removeListener("response", onResponse);
            return cb.call(this, error, responce);
          };
          onResponse = callback.bind(this, null);
          request.on("error", callback);
          request.on("response", onResponse);
        }
      }.bind(this));
      return request;
    };
    FormData2.prototype._error = function(err) {
      if (!this.error) {
        this.error = err;
        this.pause();
        this.emit("error", err);
      }
    };
    FormData2.prototype.toString = function() {
      return "[object FormData]";
    };
    setToStringTag(FormData2.prototype, "FormData");
    module2.exports = FormData2;
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl;
  }
});

// node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require("debug")("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    (function detectUnsupportedEnvironment() {
      var looksLikeNode = typeof process !== "undefined";
      var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
      var looksLikeV8 = isFunction(Error.captureStackTrace);
      if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
      }
    })();
    var useNativeURL = false;
    try {
      assert(new URL2(""));
    } catch (error) {
      useNativeURL = error.code === "ERR_INVALID_URL";
    }
    var preservedUrlFields = [
      "auth",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "hash"
    ];
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = /* @__PURE__ */ Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var InvalidUrlError = createErrorType(
      "ERR_INVALID_URL",
      "Invalid URL",
      TypeError
    );
    var RedirectionError = createErrorType(
      "ERR_FR_REDIRECTION_FAILURE",
      "Redirected request failed"
    );
    var TooManyRedirectsError = createErrorType(
      "ERR_FR_TOO_MANY_REDIRECTS",
      "Maximum number of redirects exceeded",
      RedirectionError
    );
    var MaxBodyLengthExceededError = createErrorType(
      "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
      "Request body larger than maxBodyLength limit"
    );
    var WriteAfterEndError = createErrorType(
      "ERR_STREAM_WRITE_AFTER_END",
      "write after end"
    );
    var destroy = Writable.prototype.destroy || noop;
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        try {
          self2._processResponse(response);
        } catch (cause) {
          self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
        }
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      destroyRequest(this._currentRequest);
      this._currentRequest.abort();
      this.emit("abort");
    };
    RedirectableRequest.prototype.destroy = function(error) {
      destroyRequest(this._currentRequest, error);
      destroy.call(this, error);
      return this;
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (isFunction(data)) {
        callback = data;
        data = encoding = null;
      } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        self2.removeListener("close", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      this.on("close", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
      }
      if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      request._redirectable = this;
      for (var event of events) {
        request.on(event, eventHandlers[event]);
      }
      this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
        // When making a request to a proxy, []
        // a client MUST send the target URI in absolute-form [].
        this._options.path
      );
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
        return;
      }
      destroyRequest(this._currentRequest);
      response.destroy();
      if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
      }
      var requestHeaders;
      var beforeRedirect = this._options.beforeRedirect;
      if (beforeRedirect) {
        requestHeaders = Object.assign({
          // The Host header was set by nativeProtocol.request
          Host: response.req.getHeader("host")
        }, this._options.headers);
      }
      var method = this._options.method;
      if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
      }
      var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
      var currentUrlParts = parseUrl(this._currentUrl);
      var currentHost = currentHostHeader || currentUrlParts.host;
      var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
      var redirectUrl = resolveUrl(location, currentUrl);
      debug("redirecting to", redirectUrl.href);
      this._isRedirect = true;
      spreadUrlObject(redirectUrl, this._options);
      if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
      }
      if (isFunction(beforeRedirect)) {
        var responseDetails = {
          headers: response.headers,
          statusCode
        };
        var requestDetails = {
          url: currentUrl,
          method,
          headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
      }
      this._performRequest();
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (isURL(input)) {
            input = spreadUrlObject(input);
          } else if (isString(input)) {
            input = spreadUrlObject(parseUrl(input));
          } else {
            callback = options;
            options = validateUrl(input);
            input = { protocol };
          }
          if (isFunction(options)) {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          if (!isString(options.host) && !isString(options.hostname)) {
            options.hostname = "::1";
          }
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function parseUrl(input) {
      var parsed;
      if (useNativeURL) {
        parsed = new URL2(input);
      } else {
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
          throw new InvalidUrlError({ input });
        }
      }
      return parsed;
    }
    function resolveUrl(relative, base) {
      return useNativeURL ? new URL2(relative, base) : parseUrl(url.resolve(base, relative));
    }
    function validateUrl(input) {
      if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({ input: input.href || input });
      }
      return input;
    }
    function spreadUrlObject(urlObject, target) {
      var spread = target || {};
      for (var key of preservedUrlFields) {
        spread[key] = urlObject[key];
      }
      if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
      }
      if (spread.port !== "") {
        spread.port = Number(spread.port);
      }
      spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
      return spread;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header];
          delete headers[header];
        }
      }
      return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
    }
    function createErrorType(code, message, baseClass) {
      function CustomError(properties) {
        if (isFunction(Error.captureStackTrace)) {
          Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
      }
      CustomError.prototype = new (baseClass || Error)();
      Object.defineProperties(CustomError.prototype, {
        constructor: {
          value: CustomError,
          enumerable: false
        },
        name: {
          value: "Error [" + code + "]",
          enumerable: false
        }
      });
      return CustomError;
    }
    function destroyRequest(request, error) {
      for (var event of events) {
        request.removeListener(event, eventHandlers[event]);
      }
      request.on("error", noop);
      request.destroy(error);
    }
    function isSubdomain(subdomain, domain) {
      assert(isString(subdomain) && isString(domain));
      var dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isBuffer(value) {
      return typeof value === "object" && "length" in value;
    }
    function isURL(value) {
      return URL2 && value instanceof URL2;
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// node_modules/axios/dist/node/axios.cjs
var require_axios = __commonJS({
  "node_modules/axios/dist/node/axios.cjs"(exports2, module2) {
    "use strict";
    var FormData$1 = require_form_data();
    var crypto = require("crypto");
    var url = require("url");
    var proxyFromEnv = require_proxy_from_env();
    var http = require("http");
    var https = require("https");
    var http2 = require("http2");
    var util = require("util");
    var followRedirects = require_follow_redirects();
    var zlib = require("zlib");
    var stream = require("stream");
    var events = require("events");
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData$1);
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto);
    var url__default = /* @__PURE__ */ _interopDefaultLegacy(url);
    var proxyFromEnv__default = /* @__PURE__ */ _interopDefaultLegacy(proxyFromEnv);
    var http__default = /* @__PURE__ */ _interopDefaultLegacy(http);
    var https__default = /* @__PURE__ */ _interopDefaultLegacy(https);
    var http2__default = /* @__PURE__ */ _interopDefaultLegacy(http2);
    var util__default = /* @__PURE__ */ _interopDefaultLegacy(util);
    var followRedirects__default = /* @__PURE__ */ _interopDefaultLegacy(followRedirects);
    var zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
    var stream__default = /* @__PURE__ */ _interopDefaultLegacy(stream);
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var { iterator, toStringTag } = Symbol;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction$1 = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
    };
    var isEmptyObject = (val) => {
      if (!isObject(val) || isBuffer(val)) {
        return false;
      }
      try {
        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
      } catch (e) {
        return false;
      }
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction$1(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        if (isBuffer(obj)) {
          return;
        }
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      if (isBuffer(obj)) {
        return null;
      }
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined") return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless, skipUndefined } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else if (!skipUndefined || !isUndefined(val)) {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction$1(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      let i = thing.length;
      if (!isNumber(i)) return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction$1(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (isBuffer(source)) {
            return source;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
    var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({ source, data }) => {
          if (source === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction$1(_global.postMessage)
    );
    var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    var isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isEmptyObject,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      if (response) {
        this.response = response;
        this.status = response.status ? response.status : null;
      }
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      const msg = error && error.message ? error.message : "Error";
      const errCode = code == null && error ? error.code : code;
      AxiosError.call(axiosError, msg, errCode, config, request, response);
      if (error && axiosError.cause == null) {
        Object.defineProperty(axiosError, "cause", { value: error, configurable: true });
      }
      axiosError.name = error && error.name || "Error";
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path) return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (FormData__default["default"] || FormData)();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null) return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (utils$1.isBoolean(value)) {
          return value.toString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
    }
    function buildURL(url2, params, options) {
      if (!params) {
        return url2;
      }
      const _encode = options && options.encode || encode;
      if (utils$1.isFunction(options)) {
        options = {
          serialize: options
        };
      }
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url2.indexOf("#");
        if (hashmarkIndex !== -1) {
          url2 = url2.slice(0, hashmarkIndex);
        }
        url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url2;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {void}
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams2 = url__default["default"].URLSearchParams;
    var ALPHA = "abcdefghijklmnopqrstuvwxyz";
    var DIGIT = "0123456789";
    var ALPHABET = {
      DIGIT,
      ALPHA,
      ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
    };
    var generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
      let str = "";
      const { length } = alphabet;
      const randomValues = new Uint32Array(size);
      crypto__default["default"].randomFillSync(randomValues);
      for (let i = 0; i < size; i++) {
        str += alphabet[randomValues[i] % length];
      }
      return str;
    };
    var platform$1 = {
      isNode: true,
      classes: {
        URLSearchParams: URLSearchParams2,
        FormData: FormData__default["default"],
        Blob: typeof Blob !== "undefined" && Blob || null
      },
      ALPHABET,
      generateString,
      protocols: ["http", "https", "file", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var _navigator = typeof navigator === "object" && navigator || void 0;
    var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var origin = hasBrowserEnv && window.location.href || "http://localhost";
    var utils = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv,
      navigator: _navigator,
      origin
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), {
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        },
        ...options
      });
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__") return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data, this.parseReviver);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = /* @__PURE__ */ Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value)) return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
          let obj = {}, dest, key;
          for (const entry of header) {
            if (!utils$1.isArray(entry)) {
              throw TypeError("Object iterator must return a key-value pair");
            }
            obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      getSetCookie() {
        return this.get("set-cookie") || [];
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function isAbsoluteURL(url2) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
      let isRelativeUrl = !isAbsoluteURL(requestedURL);
      if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var VERSION = "1.13.2";
    function parseProtocol(url2) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
      return match && match[1] || "";
    }
    var DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
    function fromDataURI(uri, asBlob, options) {
      const _Blob = options && options.Blob || platform.classes.Blob;
      const protocol = parseProtocol(uri);
      if (asBlob === void 0 && _Blob) {
        asBlob = true;
      }
      if (protocol === "data") {
        uri = protocol.length ? uri.slice(protocol.length + 1) : uri;
        const match = DATA_URL_PATTERN.exec(uri);
        if (!match) {
          throw new AxiosError("Invalid URL", AxiosError.ERR_INVALID_URL);
        }
        const mime = match[1];
        const isBase64 = match[2];
        const body = match[3];
        const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
        if (asBlob) {
          if (!_Blob) {
            throw new AxiosError("Blob is not supported", AxiosError.ERR_NOT_SUPPORT);
          }
          return new _Blob([buffer], { type: mime });
        }
        return buffer;
      }
      throw new AxiosError("Unsupported protocol " + protocol, AxiosError.ERR_NOT_SUPPORT);
    }
    var kInternals = /* @__PURE__ */ Symbol("internals");
    var AxiosTransformStream = class extends stream__default["default"].Transform {
      constructor(options) {
        options = utils$1.toFlatObject(options, {
          maxRate: 0,
          chunkSize: 64 * 1024,
          minChunkSize: 100,
          timeWindow: 500,
          ticksRate: 2,
          samplesCount: 15
        }, null, (prop, source) => {
          return !utils$1.isUndefined(source[prop]);
        });
        super({
          readableHighWaterMark: options.chunkSize
        });
        const internals = this[kInternals] = {
          timeWindow: options.timeWindow,
          chunkSize: options.chunkSize,
          maxRate: options.maxRate,
          minChunkSize: options.minChunkSize,
          bytesSeen: 0,
          isCaptured: false,
          notifiedBytesLoaded: 0,
          ts: Date.now(),
          bytes: 0,
          onReadCallback: null
        };
        this.on("newListener", (event) => {
          if (event === "progress") {
            if (!internals.isCaptured) {
              internals.isCaptured = true;
            }
          }
        });
      }
      _read(size) {
        const internals = this[kInternals];
        if (internals.onReadCallback) {
          internals.onReadCallback();
        }
        return super._read(size);
      }
      _transform(chunk, encoding, callback) {
        const internals = this[kInternals];
        const maxRate = internals.maxRate;
        const readableHighWaterMark = this.readableHighWaterMark;
        const timeWindow = internals.timeWindow;
        const divider = 1e3 / timeWindow;
        const bytesThreshold = maxRate / divider;
        const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
        const pushChunk = (_chunk, _callback) => {
          const bytes = Buffer.byteLength(_chunk);
          internals.bytesSeen += bytes;
          internals.bytes += bytes;
          internals.isCaptured && this.emit("progress", internals.bytesSeen);
          if (this.push(_chunk)) {
            process.nextTick(_callback);
          } else {
            internals.onReadCallback = () => {
              internals.onReadCallback = null;
              process.nextTick(_callback);
            };
          }
        };
        const transformChunk = (_chunk, _callback) => {
          const chunkSize = Buffer.byteLength(_chunk);
          let chunkRemainder = null;
          let maxChunkSize = readableHighWaterMark;
          let bytesLeft;
          let passed = 0;
          if (maxRate) {
            const now = Date.now();
            if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
              internals.ts = now;
              bytesLeft = bytesThreshold - internals.bytes;
              internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
              passed = 0;
            }
            bytesLeft = bytesThreshold - internals.bytes;
          }
          if (maxRate) {
            if (bytesLeft <= 0) {
              return setTimeout(() => {
                _callback(null, _chunk);
              }, timeWindow - passed);
            }
            if (bytesLeft < maxChunkSize) {
              maxChunkSize = bytesLeft;
            }
          }
          if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
            chunkRemainder = _chunk.subarray(maxChunkSize);
            _chunk = _chunk.subarray(0, maxChunkSize);
          }
          pushChunk(_chunk, chunkRemainder ? () => {
            process.nextTick(_callback, null, chunkRemainder);
          } : _callback);
        };
        transformChunk(chunk, function transformNextChunk(err, _chunk) {
          if (err) {
            return callback(err);
          }
          if (_chunk) {
            transformChunk(_chunk, transformNextChunk);
          } else {
            callback(null);
          }
        });
      }
    };
    var AxiosTransformStream$1 = AxiosTransformStream;
    var { asyncIterator } = Symbol;
    var readBlob = async function* (blob) {
      if (blob.stream) {
        yield* blob.stream();
      } else if (blob.arrayBuffer) {
        yield await blob.arrayBuffer();
      } else if (blob[asyncIterator]) {
        yield* blob[asyncIterator]();
      } else {
        yield blob;
      }
    };
    var readBlob$1 = readBlob;
    var BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + "-_";
    var textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new util__default["default"].TextEncoder();
    var CRLF = "\r\n";
    var CRLF_BYTES = textEncoder.encode(CRLF);
    var CRLF_BYTES_COUNT = 2;
    var FormDataPart = class {
      constructor(name, value) {
        const { escapeName } = this.constructor;
        const isStringValue = utils$1.isString(value);
        let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
        if (isStringValue) {
          value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
        } else {
          headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
        }
        this.headers = textEncoder.encode(headers + CRLF);
        this.contentLength = isStringValue ? value.byteLength : value.size;
        this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
        this.name = name;
        this.value = value;
      }
      async *encode() {
        yield this.headers;
        const { value } = this;
        if (utils$1.isTypedArray(value)) {
          yield value;
        } else {
          yield* readBlob$1(value);
        }
        yield CRLF_BYTES;
      }
      static escapeName(name) {
        return String(name).replace(/[\r\n"]/g, (match) => ({
          "\r": "%0D",
          "\n": "%0A",
          '"': "%22"
        })[match]);
      }
    };
    var formDataToStream = (form, headersHandler, options) => {
      const {
        tag = "form-data-boundary",
        size = 25,
        boundary = tag + "-" + platform.generateString(size, BOUNDARY_ALPHABET)
      } = options || {};
      if (!utils$1.isFormData(form)) {
        throw TypeError("FormData instance required");
      }
      if (boundary.length < 1 || boundary.length > 70) {
        throw Error("boundary must be 10-70 characters long");
      }
      const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
      const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
      let contentLength = footerBytes.byteLength;
      const parts = Array.from(form.entries()).map(([name, value]) => {
        const part = new FormDataPart(name, value);
        contentLength += part.size;
        return part;
      });
      contentLength += boundaryBytes.byteLength * parts.length;
      contentLength = utils$1.toFiniteNumber(contentLength);
      const computedHeaders = {
        "Content-Type": `multipart/form-data; boundary=${boundary}`
      };
      if (Number.isFinite(contentLength)) {
        computedHeaders["Content-Length"] = contentLength;
      }
      headersHandler && headersHandler(computedHeaders);
      return stream.Readable.from((async function* () {
        for (const part of parts) {
          yield boundaryBytes;
          yield* part.encode();
        }
        yield footerBytes;
      })());
    };
    var formDataToStream$1 = formDataToStream;
    var ZlibHeaderTransformStream = class extends stream__default["default"].Transform {
      __transform(chunk, encoding, callback) {
        this.push(chunk);
        callback();
      }
      _transform(chunk, encoding, callback) {
        if (chunk.length !== 0) {
          this._transform = this.__transform;
          if (chunk[0] !== 120) {
            const header = Buffer.alloc(2);
            header[0] = 120;
            header[1] = 156;
            this.push(header, encoding);
          }
        }
        this.__transform(chunk, encoding, callback);
      }
    };
    var ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
    var callbackify = (fn, reducer) => {
      return utils$1.isAsyncFn(fn) ? function(...args) {
        const cb = args.pop();
        fn.apply(this, args).then((value) => {
          try {
            reducer ? cb(null, ...reducer(value)) : cb(null, value);
          } catch (err) {
            cb(err);
          }
        }, cb);
      } : fn;
    };
    var callbackify$1 = callbackify;
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle(fn, freq) {
      let timestamp = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now = Date.now()) => {
        timestamp = now;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn(...args);
      };
      const throttled = (...args) => {
        const now = Date.now();
        const passed = now - timestamp;
        if (passed >= threshold) {
          invoke(args, now);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush = () => lastArgs && invoke(lastArgs);
      return [throttled, flush];
    }
    var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    var progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    var asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
    function estimateDataURLDecodedBytes(url2) {
      if (!url2 || typeof url2 !== "string") return 0;
      if (!url2.startsWith("data:")) return 0;
      const comma = url2.indexOf(",");
      if (comma < 0) return 0;
      const meta = url2.slice(5, comma);
      const body = url2.slice(comma + 1);
      const isBase64 = /;base64/i.test(meta);
      if (isBase64) {
        let effectiveLen = body.length;
        const len = body.length;
        for (let i = 0; i < len; i++) {
          if (body.charCodeAt(i) === 37 && i + 2 < len) {
            const a = body.charCodeAt(i + 1);
            const b = body.charCodeAt(i + 2);
            const isHex = (a >= 48 && a <= 57 || a >= 65 && a <= 70 || a >= 97 && a <= 102) && (b >= 48 && b <= 57 || b >= 65 && b <= 70 || b >= 97 && b <= 102);
            if (isHex) {
              effectiveLen -= 2;
              i += 2;
            }
          }
        }
        let pad = 0;
        let idx = len - 1;
        const tailIsPct3D = (j) => j >= 2 && body.charCodeAt(j - 2) === 37 && // '%'
        body.charCodeAt(j - 1) === 51 && // '3'
        (body.charCodeAt(j) === 68 || body.charCodeAt(j) === 100);
        if (idx >= 0) {
          if (body.charCodeAt(idx) === 61) {
            pad++;
            idx--;
          } else if (tailIsPct3D(idx)) {
            pad++;
            idx -= 3;
          }
        }
        if (pad === 1 && idx >= 0) {
          if (body.charCodeAt(idx) === 61) {
            pad++;
          } else if (tailIsPct3D(idx)) {
            pad++;
          }
        }
        const groups = Math.floor(effectiveLen / 4);
        const bytes = groups * 3 - (pad || 0);
        return bytes > 0 ? bytes : 0;
      }
      return Buffer.byteLength(body, "utf8");
    }
    var zlibOptions = {
      flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
      finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
    };
    var brotliOptions = {
      flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
      finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
    };
    var isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);
    var { http: httpFollow, https: httpsFollow } = followRedirects__default["default"];
    var isHttps = /https:?/;
    var supportedProtocols = platform.protocols.map((protocol) => {
      return protocol + ":";
    });
    var flushOnFinish = (stream2, [throttled, flush]) => {
      stream2.on("end", flush).on("error", flush);
      return throttled;
    };
    var Http2Sessions = class {
      constructor() {
        this.sessions = /* @__PURE__ */ Object.create(null);
      }
      getSession(authority, options) {
        options = Object.assign({
          sessionTimeout: 1e3
        }, options);
        let authoritySessions = this.sessions[authority];
        if (authoritySessions) {
          let len = authoritySessions.length;
          for (let i = 0; i < len; i++) {
            const [sessionHandle, sessionOptions] = authoritySessions[i];
            if (!sessionHandle.destroyed && !sessionHandle.closed && util__default["default"].isDeepStrictEqual(sessionOptions, options)) {
              return sessionHandle;
            }
          }
        }
        const session = http2__default["default"].connect(authority, options);
        let removed;
        const removeSession = () => {
          if (removed) {
            return;
          }
          removed = true;
          let entries = authoritySessions, len = entries.length, i = len;
          while (i--) {
            if (entries[i][0] === session) {
              if (len === 1) {
                delete this.sessions[authority];
              } else {
                entries.splice(i, 1);
              }
              return;
            }
          }
        };
        const originalRequestFn = session.request;
        const { sessionTimeout } = options;
        if (sessionTimeout != null) {
          let timer;
          let streamsCount = 0;
          session.request = function() {
            const stream2 = originalRequestFn.apply(this, arguments);
            streamsCount++;
            if (timer) {
              clearTimeout(timer);
              timer = null;
            }
            stream2.once("close", () => {
              if (!--streamsCount) {
                timer = setTimeout(() => {
                  timer = null;
                  removeSession();
                }, sessionTimeout);
              }
            });
            return stream2;
          };
        }
        session.once("close", removeSession);
        let entry = [
          session,
          options
        ];
        authoritySessions ? authoritySessions.push(entry) : authoritySessions = this.sessions[authority] = [entry];
        return session;
      }
    };
    var http2Sessions = new Http2Sessions();
    function dispatchBeforeRedirect(options, responseDetails) {
      if (options.beforeRedirects.proxy) {
        options.beforeRedirects.proxy(options);
      }
      if (options.beforeRedirects.config) {
        options.beforeRedirects.config(options, responseDetails);
      }
    }
    function setProxy(options, configProxy, location) {
      let proxy = configProxy;
      if (!proxy && proxy !== false) {
        const proxyUrl = proxyFromEnv__default["default"].getProxyForUrl(location);
        if (proxyUrl) {
          proxy = new URL(proxyUrl);
        }
      }
      if (proxy) {
        if (proxy.username) {
          proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
        }
        if (proxy.auth) {
          if (proxy.auth.username || proxy.auth.password) {
            proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
          }
          const base64 = Buffer.from(proxy.auth, "utf8").toString("base64");
          options.headers["Proxy-Authorization"] = "Basic " + base64;
        }
        options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
        const proxyHost = proxy.hostname || proxy.host;
        options.hostname = proxyHost;
        options.host = proxyHost;
        options.port = proxy.port;
        options.path = location;
        if (proxy.protocol) {
          options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
        }
      }
      options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
        setProxy(redirectOptions, configProxy, redirectOptions.href);
      };
    }
    var isHttpAdapterSupported = typeof process !== "undefined" && utils$1.kindOf(process) === "process";
    var wrapAsync = (asyncExecutor) => {
      return new Promise((resolve, reject) => {
        let onDone;
        let isDone;
        const done = (value, isRejected) => {
          if (isDone) return;
          isDone = true;
          onDone && onDone(value, isRejected);
        };
        const _resolve = (value) => {
          done(value);
          resolve(value);
        };
        const _reject = (reason) => {
          done(reason, true);
          reject(reason);
        };
        asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
      });
    };
    var resolveFamily = ({ address, family }) => {
      if (!utils$1.isString(address)) {
        throw TypeError("address must be a string");
      }
      return {
        address,
        family: family || (address.indexOf(".") < 0 ? 6 : 4)
      };
    };
    var buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : { address, family });
    var http2Transport = {
      request(options, cb) {
        const authority = options.protocol + "//" + options.hostname + ":" + (options.port || 80);
        const { http2Options, headers } = options;
        const session = http2Sessions.getSession(authority, http2Options);
        const {
          HTTP2_HEADER_SCHEME,
          HTTP2_HEADER_METHOD,
          HTTP2_HEADER_PATH,
          HTTP2_HEADER_STATUS
        } = http2__default["default"].constants;
        const http2Headers = {
          [HTTP2_HEADER_SCHEME]: options.protocol.replace(":", ""),
          [HTTP2_HEADER_METHOD]: options.method,
          [HTTP2_HEADER_PATH]: options.path
        };
        utils$1.forEach(headers, (header, name) => {
          name.charAt(0) !== ":" && (http2Headers[name] = header);
        });
        const req = session.request(http2Headers);
        req.once("response", (responseHeaders) => {
          const response = req;
          responseHeaders = Object.assign({}, responseHeaders);
          const status = responseHeaders[HTTP2_HEADER_STATUS];
          delete responseHeaders[HTTP2_HEADER_STATUS];
          response.headers = responseHeaders;
          response.statusCode = +status;
          cb(response);
        });
        return req;
      }
    };
    var httpAdapter = isHttpAdapterSupported && function httpAdapter2(config) {
      return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
        let { data, lookup, family, httpVersion = 1, http2Options } = config;
        const { responseType, responseEncoding } = config;
        const method = config.method.toUpperCase();
        let isDone;
        let rejected = false;
        let req;
        httpVersion = +httpVersion;
        if (Number.isNaN(httpVersion)) {
          throw TypeError(`Invalid protocol version: '${config.httpVersion}' is not a number`);
        }
        if (httpVersion !== 1 && httpVersion !== 2) {
          throw TypeError(`Unsupported protocol version '${httpVersion}'`);
        }
        const isHttp2 = httpVersion === 2;
        if (lookup) {
          const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
          lookup = (hostname, opt, cb) => {
            _lookup(hostname, opt, (err, arg0, arg1) => {
              if (err) {
                return cb(err);
              }
              const addresses = utils$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
              opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
            });
          };
        }
        const abortEmitter = new events.EventEmitter();
        function abort(reason) {
          try {
            abortEmitter.emit("abort", !reason || reason.type ? new CanceledError(null, config, req) : reason);
          } catch (err) {
            console.warn("emit error", err);
          }
        }
        abortEmitter.once("abort", reject);
        const onFinished = () => {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(abort);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", abort);
          }
          abortEmitter.removeAllListeners();
        };
        if (config.cancelToken || config.signal) {
          config.cancelToken && config.cancelToken.subscribe(abort);
          if (config.signal) {
            config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
          }
        }
        onDone((response, isRejected) => {
          isDone = true;
          if (isRejected) {
            rejected = true;
            onFinished();
            return;
          }
          const { data: data2 } = response;
          if (data2 instanceof stream__default["default"].Readable || data2 instanceof stream__default["default"].Duplex) {
            const offListeners = stream__default["default"].finished(data2, () => {
              offListeners();
              onFinished();
            });
          } else {
            onFinished();
          }
        });
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : void 0);
        const protocol = parsed.protocol || supportedProtocols[0];
        if (protocol === "data:") {
          if (config.maxContentLength > -1) {
            const dataUrl = String(config.url || fullPath || "");
            const estimated = estimateDataURLDecodedBytes(dataUrl);
            if (estimated > config.maxContentLength) {
              return reject(new AxiosError(
                "maxContentLength size of " + config.maxContentLength + " exceeded",
                AxiosError.ERR_BAD_RESPONSE,
                config
              ));
            }
          }
          let convertedData;
          if (method !== "GET") {
            return settle(resolve, reject, {
              status: 405,
              statusText: "method not allowed",
              headers: {},
              config
            });
          }
          try {
            convertedData = fromDataURI(config.url, responseType === "blob", {
              Blob: config.env && config.env.Blob
            });
          } catch (err) {
            throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
          }
          if (responseType === "text") {
            convertedData = convertedData.toString(responseEncoding);
            if (!responseEncoding || responseEncoding === "utf8") {
              convertedData = utils$1.stripBOM(convertedData);
            }
          } else if (responseType === "stream") {
            convertedData = stream__default["default"].Readable.from(convertedData);
          }
          return settle(resolve, reject, {
            data: convertedData,
            status: 200,
            statusText: "OK",
            headers: new AxiosHeaders$1(),
            config
          });
        }
        if (supportedProtocols.indexOf(protocol) === -1) {
          return reject(new AxiosError(
            "Unsupported protocol " + protocol,
            AxiosError.ERR_BAD_REQUEST,
            config
          ));
        }
        const headers = AxiosHeaders$1.from(config.headers).normalize();
        headers.set("User-Agent", "axios/" + VERSION, false);
        const { onUploadProgress, onDownloadProgress } = config;
        const maxRate = config.maxRate;
        let maxUploadRate = void 0;
        let maxDownloadRate = void 0;
        if (utils$1.isSpecCompliantForm(data)) {
          const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
          data = formDataToStream$1(data, (formHeaders) => {
            headers.set(formHeaders);
          }, {
            tag: `axios-${VERSION}-boundary`,
            boundary: userBoundary && userBoundary[1] || void 0
          });
        } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
          headers.set(data.getHeaders());
          if (!headers.hasContentLength()) {
            try {
              const knownLength = await util__default["default"].promisify(data.getLength).call(data);
              Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
            } catch (e) {
            }
          }
        } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
          data.size && headers.setContentType(data.type || "application/octet-stream");
          headers.setContentLength(data.size || 0);
          data = stream__default["default"].Readable.from(readBlob$1(data));
        } else if (data && !utils$1.isStream(data)) {
          if (Buffer.isBuffer(data)) ;
          else if (utils$1.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils$1.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject(new AxiosError(
              "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
          headers.setContentLength(data.length, false);
          if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
            return reject(new AxiosError(
              "Request body larger than maxBodyLength limit",
              AxiosError.ERR_BAD_REQUEST,
              config
            ));
          }
        }
        const contentLength = utils$1.toFiniteNumber(headers.getContentLength());
        if (utils$1.isArray(maxRate)) {
          maxUploadRate = maxRate[0];
          maxDownloadRate = maxRate[1];
        } else {
          maxUploadRate = maxDownloadRate = maxRate;
        }
        if (data && (onUploadProgress || maxUploadRate)) {
          if (!utils$1.isStream(data)) {
            data = stream__default["default"].Readable.from(data, { objectMode: false });
          }
          data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
            maxRate: utils$1.toFiniteNumber(maxUploadRate)
          })], utils$1.noop);
          onUploadProgress && data.on("progress", flushOnFinish(
            data,
            progressEventDecorator(
              contentLength,
              progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
            )
          ));
        }
        let auth = void 0;
        if (config.auth) {
          const username = config.auth.username || "";
          const password = config.auth.password || "";
          auth = username + ":" + password;
        }
        if (!auth && parsed.username) {
          const urlUsername = parsed.username;
          const urlPassword = parsed.password;
          auth = urlUsername + ":" + urlPassword;
        }
        auth && headers.delete("authorization");
        let path;
        try {
          path = buildURL(
            parsed.pathname + parsed.search,
            config.params,
            config.paramsSerializer
          ).replace(/^\?/, "");
        } catch (err) {
          const customErr = new Error(err.message);
          customErr.config = config;
          customErr.url = config.url;
          customErr.exists = true;
          return reject(customErr);
        }
        headers.set(
          "Accept-Encoding",
          "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
          false
        );
        const options = {
          path,
          method,
          headers: headers.toJSON(),
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth,
          protocol,
          family,
          beforeRedirect: dispatchBeforeRedirect,
          beforeRedirects: {},
          http2Options
        };
        !utils$1.isUndefined(lookup) && (options.lookup = lookup);
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
          options.port = parsed.port;
          setProxy(options, config.proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        let transport;
        const isHttpsRequest = isHttps.test(options.protocol);
        options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        if (isHttp2) {
          transport = http2Transport;
        } else {
          if (config.transport) {
            transport = config.transport;
          } else if (config.maxRedirects === 0) {
            transport = isHttpsRequest ? https__default["default"] : http__default["default"];
          } else {
            if (config.maxRedirects) {
              options.maxRedirects = config.maxRedirects;
            }
            if (config.beforeRedirect) {
              options.beforeRedirects.config = config.beforeRedirect;
            }
            transport = isHttpsRequest ? httpsFollow : httpFollow;
          }
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        } else {
          options.maxBodyLength = Infinity;
        }
        if (config.insecureHTTPParser) {
          options.insecureHTTPParser = config.insecureHTTPParser;
        }
        req = transport.request(options, function handleResponse(res) {
          if (req.destroyed) return;
          const streams = [res];
          const responseLength = utils$1.toFiniteNumber(res.headers["content-length"]);
          if (onDownloadProgress || maxDownloadRate) {
            const transformStream = new AxiosTransformStream$1({
              maxRate: utils$1.toFiniteNumber(maxDownloadRate)
            });
            onDownloadProgress && transformStream.on("progress", flushOnFinish(
              transformStream,
              progressEventDecorator(
                responseLength,
                progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
              )
            ));
            streams.push(transformStream);
          }
          let responseStream = res;
          const lastRequest = res.req || req;
          if (config.decompress !== false && res.headers["content-encoding"]) {
            if (method === "HEAD" || res.statusCode === 204) {
              delete res.headers["content-encoding"];
            }
            switch ((res.headers["content-encoding"] || "").toLowerCase()) {
              /*eslint default-case:0*/
              case "gzip":
              case "x-gzip":
              case "compress":
              case "x-compress":
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "deflate":
                streams.push(new ZlibHeaderTransformStream$1());
                streams.push(zlib__default["default"].createUnzip(zlibOptions));
                delete res.headers["content-encoding"];
                break;
              case "br":
                if (isBrotliSupported) {
                  streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
                  delete res.headers["content-encoding"];
                }
            }
          }
          responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];
          const response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: new AxiosHeaders$1(res.headers),
            config,
            request: lastRequest
          };
          if (responseType === "stream") {
            response.data = responseStream;
            settle(resolve, reject, response);
          } else {
            const responseBuffer = [];
            let totalResponseBytes = 0;
            responseStream.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                rejected = true;
                responseStream.destroy();
                abort(new AxiosError(
                  "maxContentLength size of " + config.maxContentLength + " exceeded",
                  AxiosError.ERR_BAD_RESPONSE,
                  config,
                  lastRequest
                ));
              }
            });
            responseStream.on("aborted", function handlerStreamAborted() {
              if (rejected) {
                return;
              }
              const err = new AxiosError(
                "stream has been aborted",
                AxiosError.ERR_BAD_RESPONSE,
                config,
                lastRequest
              );
              responseStream.destroy(err);
              reject(err);
            });
            responseStream.on("error", function handleStreamError(err) {
              if (req.destroyed) return;
              reject(AxiosError.from(err, null, config, lastRequest));
            });
            responseStream.on("end", function handleStreamEnd() {
              try {
                let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
                if (responseType !== "arraybuffer") {
                  responseData = responseData.toString(responseEncoding);
                  if (!responseEncoding || responseEncoding === "utf8") {
                    responseData = utils$1.stripBOM(responseData);
                  }
                }
                response.data = responseData;
              } catch (err) {
                return reject(AxiosError.from(err, null, config, response.request, response));
              }
              settle(resolve, reject, response);
            });
          }
          abortEmitter.once("abort", (err) => {
            if (!responseStream.destroyed) {
              responseStream.emit("error", err);
              responseStream.destroy();
            }
          });
        });
        abortEmitter.once("abort", (err) => {
          if (req.close) {
            req.close();
          } else {
            req.destroy(err);
          }
        });
        req.on("error", function handleRequestError(err) {
          reject(AxiosError.from(err, null, config, req));
        });
        req.on("socket", function handleRequestSocket(socket) {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        if (config.timeout) {
          const timeout = parseInt(config.timeout, 10);
          if (Number.isNaN(timeout)) {
            abort(new AxiosError(
              "error trying to parse `config.timeout` to int",
              AxiosError.ERR_BAD_OPTION_VALUE,
              config,
              req
            ));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            if (isDone) return;
            let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
            const transitional = config.transitional || transitionalDefaults;
            if (config.timeoutErrorMessage) {
              timeoutErrorMessage = config.timeoutErrorMessage;
            }
            abort(new AxiosError(
              timeoutErrorMessage,
              transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
              config,
              req
            ));
          });
        } else {
          req.setTimeout(0);
        }
        if (utils$1.isStream(data)) {
          let ended = false;
          let errored = false;
          data.on("end", () => {
            ended = true;
          });
          data.once("error", (err) => {
            errored = true;
            req.destroy(err);
          });
          data.on("close", () => {
            if (!ended && !errored) {
              abort(new CanceledError("Request stream has been aborted", config, req));
            }
          });
          data.pipe(req);
        } else {
          data && req.write(data);
          req.end();
        }
      });
    };
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url2) => {
      url2 = new URL(url2, platform.origin);
      return origin2.protocol === url2.protocol && origin2.host === url2.host && (isMSIE || origin2.port === url2.port);
    })(
      new URL(platform.origin),
      platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
    ) : () => true;
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure, sameSite) {
          if (typeof document === "undefined") return;
          const cookie = [`${name}=${encodeURIComponent(value)}`];
          if (utils$1.isNumber(expires)) {
            cookie.push(`expires=${new Date(expires).toUTCString()}`);
          }
          if (utils$1.isString(path)) {
            cookie.push(`path=${path}`);
          }
          if (utils$1.isString(domain)) {
            cookie.push(`domain=${domain}`);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          if (utils$1.isString(sameSite)) {
            cookie.push(`SameSite=${sameSite}`);
          }
          document.cookie = cookie.join("; ");
        },
        read(name) {
          if (typeof document === "undefined") return null;
          const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
          return match ? decodeURIComponent(match[1]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5, "/");
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, prop, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, prop, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, prop, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, prop, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
      };
      utils$1.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var resolveConfig = (config) => {
      const newConfig = mergeConfig({}, config);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if (utils$1.isFunction(data.getHeaders)) {
          const formHeaders = data.getHeaders();
          const allowedHeaders = ["content-type", "content-length"];
          Object.entries(formHeaders).forEach(([key, val]) => {
            if (allowedHeaders.includes(key.toLowerCase())) {
              headers.set(key, val);
            }
          });
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig(config);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError(event) {
          const msg = event && event.message ? event.message : "Network Error";
          const err = new AxiosError(msg, AxiosError.ERR_NETWORK, config, request);
          err.event = event || null;
          reject(err);
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted;
        const onabort = function(reason) {
          if (!aborted) {
            aborted = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils$1.asap(unsubscribe);
        return signal;
      }
    };
    var composeSignals$1 = composeSignals;
    var streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    var readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };
    var readStream = async function* (stream2) {
      if (stream2[Symbol.asyncIterator]) {
        yield* stream2;
        return;
      }
      const reader = stream2.getReader();
      try {
        for (; ; ) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };
    var trackStream = (stream2, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream2, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator2.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator2.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    var DEFAULT_CHUNK_SIZE = 64 * 1024;
    var { isFunction } = utils$1;
    var globalFetchAPI = (({ Request, Response }) => ({
      Request,
      Response
    }))(utils$1.global);
    var {
      ReadableStream: ReadableStream$1,
      TextEncoder: TextEncoder$1
    } = utils$1.global;
    var test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    var factory = (env) => {
      env = utils$1.merge.call({
        skipUndefined: true
      }, globalFetchAPI, env);
      const { fetch: envFetch, Request, Response } = env;
      const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === "function";
      const isRequestSupported = isFunction(Request);
      const isResponseSupported = isFunction(Response);
      if (!isFetchSupported) {
        return false;
      }
      const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);
      const encodeText = isFetchSupported && (typeof TextEncoder$1 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder$1()) : async (str) => new Uint8Array(await new Request(str).arrayBuffer()));
      const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
        let duplexAccessed = false;
        const hasContentType = new Request(platform.origin, {
          body: new ReadableStream$1(),
          method: "POST",
          get duplex() {
            duplexAccessed = true;
            return "half";
          }
        }).headers.has("Content-Type");
        return duplexAccessed && !hasContentType;
      });
      const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
      const resolvers = {
        stream: supportsResponseStream && ((res) => res.body)
      };
      isFetchSupported && (() => {
        ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
          !resolvers[type] && (resolvers[type] = (res, config) => {
            let method = res && res[type];
            if (method) {
              return method.call(res);
            }
            throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
          });
        });
      })();
      const getBodyLength = async (body) => {
        if (body == null) {
          return 0;
        }
        if (utils$1.isBlob(body)) {
          return body.size;
        }
        if (utils$1.isSpecCompliantForm(body)) {
          const _request = new Request(platform.origin, {
            method: "POST",
            body
          });
          return (await _request.arrayBuffer()).byteLength;
        }
        if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
          return body.byteLength;
        }
        if (utils$1.isURLSearchParams(body)) {
          body = body + "";
        }
        if (utils$1.isString(body)) {
          return (await encodeText(body)).byteLength;
        }
      };
      const resolveBodyLength = async (headers, body) => {
        const length = utils$1.toFiniteNumber(headers.getContentLength());
        return length == null ? getBodyLength(body) : length;
      };
      return async (config) => {
        let {
          url: url2,
          method,
          data,
          signal,
          cancelToken,
          timeout,
          onDownloadProgress,
          onUploadProgress,
          responseType,
          headers,
          withCredentials = "same-origin",
          fetchOptions
        } = resolveConfig(config);
        let _fetch = envFetch || fetch;
        responseType = responseType ? (responseType + "").toLowerCase() : "text";
        let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
        let request = null;
        const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
          composedSignal.unsubscribe();
        });
        let requestContentLength;
        try {
          if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
            let _request = new Request(url2, {
              method: "POST",
              body: data,
              duplex: "half"
            });
            let contentTypeHeader;
            if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
              headers.setContentType(contentTypeHeader);
            }
            if (_request.body) {
              const [onProgress, flush] = progressEventDecorator(
                requestContentLength,
                progressEventReducer(asyncDecorator(onUploadProgress))
              );
              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          }
          if (!utils$1.isString(withCredentials)) {
            withCredentials = withCredentials ? "include" : "omit";
          }
          const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;
          const resolvedOptions = {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            credentials: isCredentialsSupported ? withCredentials : void 0
          };
          request = isRequestSupported && new Request(url2, resolvedOptions);
          let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url2, resolvedOptions));
          const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
          if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
            const options = {};
            ["status", "statusText", "headers"].forEach((prop) => {
              options[prop] = response[prop];
            });
            const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
              responseContentLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true)
            ) || [];
            response = new Response(
              trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                flush && flush();
                unsubscribe && unsubscribe();
              }),
              options
            );
          }
          responseType = responseType || "text";
          let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
          !isStreamResponse && unsubscribe && unsubscribe();
          return await new Promise((resolve, reject) => {
            settle(resolve, reject, {
              data: responseData,
              headers: AxiosHeaders$1.from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config,
              request
            });
          });
        } catch (err) {
          unsubscribe && unsubscribe();
          if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
            throw Object.assign(
              new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
              {
                cause: err.cause || err
              }
            );
          }
          throw AxiosError.from(err, err && err.code, config, request);
        }
      };
    };
    var seedCache = /* @__PURE__ */ new Map();
    var getFetch = (config) => {
      let env = config && config.env || {};
      const { fetch: fetch2, Request, Response } = env;
      const seeds = [
        Request,
        Response,
        fetch2
      ];
      let len = seeds.length, i = len, seed, target, map = seedCache;
      while (i--) {
        seed = seeds[i];
        target = map.get(seed);
        target === void 0 && map.set(seed, target = i ? /* @__PURE__ */ new Map() : factory(env));
        map = target;
      }
      return target;
    };
    getFetch();
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: {
        get: getFetch
      }
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    function getAdapter(adapters2, config) {
      adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
      const { length } = adapters2;
      let nameOrAdapter;
      let adapter;
      const rejectedReasons = {};
      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters2[i];
        let id;
        adapter = nameOrAdapter;
        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
          if (adapter === void 0) {
            throw new AxiosError(`Unknown adapter '${id}'`);
          }
        }
        if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config)))) {
          break;
        }
        rejectedReasons[id || "#" + i] = adapter;
      }
      if (!adapter) {
        const reasons = Object.entries(rejectedReasons).map(
          ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
        );
        let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
        throw new AxiosError(
          `There is no suitable adapter to dispatch the request ` + s,
          "ERR_NOT_SUPPORT"
        );
      }
      return adapter;
    }
    var adapters = {
      /**
       * Resolve an adapter from a list of adapter names or functions.
       * @type {Function}
       */
      getAdapter,
      /**
       * Exposes all known adapters
       * @type {Object<string, Function|Object>}
       */
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter, config);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    validators$1.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        if (config.allowAbsoluteUrls !== void 0) ;
        else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config.allowAbsoluteUrls = true;
        }
        validator.assertOptions(config, {
          baseUrl: validators.spelling("baseURL"),
          withXsrfToken: validators.spelling("withXSRFToken")
        }, true);
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift(...requestInterceptorChain);
          chain.push(...responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url2, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url: url2,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url2, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: url2,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners) return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
      WebServerIsDown: 521,
      ConnectionTimedOut: 522,
      OriginIsUnreachable: 523,
      TimeoutOccurred: 524,
      SslHandshakeFailed: 525,
      InvalidSslCertificate: 526
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module2.exports = axios;
  }
});

// node_modules/tiktok-live-connector/dist/lib/web/lib/cookie-jar.js
var require_cookie_jar = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/web/lib/cookie-jar.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var config_1 = __importDefault(require_config());
    var CookieJar = class {
      axiosInstance;
      cookies;
      /**
       * Constructor
       *
       * @param axiosInstance The axios instance to attach the cookie jar to
       * @param cookies The initial cookies to set
       */
      constructor(axiosInstance, cookies = config_1.default.DEFAULT_HTTP_CLIENT_COOKIES) {
        this.axiosInstance = axiosInstance;
        this.cookies = cookies;
        this.axiosInstance.interceptors.response.use((response) => {
          this.readCookies(response);
          return response;
        });
        this.axiosInstance.interceptors.request.use((request) => {
          this.appendCookies(request);
          return request;
        });
        return new Proxy(this, {
          get(target, p) {
            if (p in target) {
              return target[p];
            } else {
              return target.cookies[p];
            }
          },
          set(target, p, value) {
            if (value === null) {
              delete target.cookies[p];
              return true;
            }
            if (p in target) {
              target[p] = value;
            } else {
              target.cookies[p] = value;
            }
            return true;
          },
          deleteProperty(target, p) {
            delete target.cookies[p];
            return true;
          }
        });
      }
      /**
       * Set the session ID and tt-target-idc
       *
       * @param sessionId The session ID to set
       * @param ttTargetIdc The tt-target-idc to set
       */
      setSession(sessionId, ttTargetIdc) {
        if (sessionId && !ttTargetIdc) {
          throw new Error("tt-target-idc is required when sessionId is set");
        }
        this.cookies["sessionid"] = sessionId;
        this.cookies["sessionid_ss"] = sessionId;
        this.cookies["sid_tt"] = sessionId;
        this.cookies["sid_guard"] = sessionId;
        this.cookies["tt-target-idc"] = ttTargetIdc;
      }
      /**
       * Get the tt-target-idc cookie
       */
      get ttTargetIdc() {
        return this.cookies["tt-target-idc"] || null;
      }
      /**
       * Get the session ID
       */
      get sessionId() {
        return this.cookies["sessionid"] || this.cookies["sessionid_ss"] || this.cookies["sid_tt"] || this.cookies["sid_guard"] || null;
      }
      /**
       * Read cookies from response headers
       * @param response The axios response
       */
      readCookies(response) {
        const setCookieHeaders = response.headers["set-cookie"];
        if (Array.isArray(setCookieHeaders)) {
          setCookieHeaders.forEach((setCookieHeader) => this.processSetCookieHeader(setCookieHeader));
        } else if (typeof setCookieHeaders === "string") {
          this.processSetCookieHeader(setCookieHeaders);
        }
      }
      /**
       * Append cookies to request headers
       * @param request The axios request
       */
      appendCookies(request) {
        if (request.headers["cookie"]) {
          request.headers["Cookie"] = request.headers["cookie"];
          delete request.headers["cookie"];
        }
        const headerCookie = request.headers["Cookie"];
        if (typeof headerCookie === "string") {
          Object.assign(this.cookies, this.parseCookie(headerCookie), this.cookies);
        }
        request.headers["Cookie"] = this.getCookieString();
      }
      /**
       * Parse cookie string
       * @param str The cookie string
       */
      parseCookie(str) {
        const cookies = {};
        if (!str)
          return cookies;
        str.split("; ").forEach((v) => {
          if (!v)
            return;
          const parts = String(v).split("=");
          const cookieName = decodeURIComponent(parts.shift());
          cookies[cookieName] = parts.join("=");
        });
        return cookies;
      }
      /**
       * Process a single set-cookie header
       * @param setCookieHeader The set-cookie header
       */
      processSetCookieHeader(setCookieHeader) {
        const nameValuePart = setCookieHeader.split(";")[0];
        const parts = nameValuePart.split("=");
        const cookieName = parts.shift();
        const cookieValue = parts.join("=");
        if (typeof cookieName === "string" && cookieName !== "" && typeof cookieValue === "string") {
          this.cookies[decodeURIComponent(cookieName)] = cookieValue;
        }
      }
      /**
       * Get the cookie string
       * @param headers Optional existing headers to merge with
       */
      getCookieString(headers) {
        let cookies = { ...this.cookies };
        const cookieHeader = headers?.["Cookie"] || headers?.["cookie"];
        if (cookieHeader) {
          const parsedHeaderCookies = this.parseCookie(cookieHeader);
          cookies = { ...parsedHeaderCookies, ...cookies };
        }
        const cookieParams = [];
        for (const [cookieName, cookieValue] of Object.entries(cookies)) {
          if (!cookieValue)
            continue;
          cookieParams.push(`${cookieName}=${cookieValue}`);
        }
        return cookieParams.join("; ");
      }
    };
    exports2.default = CookieJar;
  }
});

// node_modules/@eulerstream/euler-api-sdk/dist/sdk/base.js
var require_base = __commonJS({
  "node_modules/@eulerstream/euler-api-sdk/dist/sdk/base.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.operationServerMap = exports2.RequiredError = exports2.BaseAPI = exports2.COLLECTION_FORMATS = exports2.BASE_PATH = void 0;
    var axios_1 = __importDefault(require_axios());
    exports2.BASE_PATH = "https://tiktok.eulerstream.com".replace(/\/+$/, "");
    exports2.COLLECTION_FORMATS = {
      csv: ",",
      ssv: " ",
      tsv: "	",
      pipes: "|"
    };
    var BaseAPI = class {
      basePath;
      axios;
      configuration;
      constructor(configuration, basePath = exports2.BASE_PATH, axios = axios_1.default) {
        this.basePath = basePath;
        this.axios = axios;
        if (configuration) {
          this.configuration = configuration;
          this.basePath = configuration.basePath ?? basePath;
        }
      }
    };
    exports2.BaseAPI = BaseAPI;
    var RequiredError = class extends Error {
      field;
      constructor(field, msg) {
        super(msg);
        this.field = field;
        this.name = "RequiredError";
      }
    };
    exports2.RequiredError = RequiredError;
    exports2.operationServerMap = {};
  }
});

// node_modules/@eulerstream/euler-api-sdk/dist/sdk/common.js
var require_common = __commonJS({
  "node_modules/@eulerstream/euler-api-sdk/dist/sdk/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createRequestFunction = exports2.toPathString = exports2.serializeDataIfNeeded = exports2.setSearchParams = exports2.setOAuthToObject = exports2.setBearerAuthToObject = exports2.setBasicAuthToObject = exports2.setApiKeyToObject = exports2.assertParamExists = exports2.DUMMY_BASE_URL = void 0;
    var base_1 = require_base();
    exports2.DUMMY_BASE_URL = "https://example.com";
    var assertParamExists = function(functionName, paramName, paramValue) {
      if (paramValue === null || paramValue === void 0) {
        throw new base_1.RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
      }
    };
    exports2.assertParamExists = assertParamExists;
    var setApiKeyToObject = async function(object, keyParamName, configuration) {
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue = typeof configuration.apiKey === "function" ? await configuration.apiKey(keyParamName) : await configuration.apiKey;
        object[keyParamName] = localVarApiKeyValue;
      }
    };
    exports2.setApiKeyToObject = setApiKeyToObject;
    var setBasicAuthToObject = function(object, configuration) {
      if (configuration && (configuration.username || configuration.password)) {
        object["auth"] = { username: configuration.username, password: configuration.password };
      }
    };
    exports2.setBasicAuthToObject = setBasicAuthToObject;
    var setBearerAuthToObject = async function(object, configuration) {
      if (configuration && configuration.accessToken) {
        const accessToken = typeof configuration.accessToken === "function" ? await configuration.accessToken() : await configuration.accessToken;
        object["Authorization"] = "Bearer " + accessToken;
      }
    };
    exports2.setBearerAuthToObject = setBearerAuthToObject;
    var setOAuthToObject = async function(object, name, scopes, configuration) {
      if (configuration && configuration.accessToken) {
        const localVarAccessTokenValue = typeof configuration.accessToken === "function" ? await configuration.accessToken(name, scopes) : await configuration.accessToken;
        object["Authorization"] = "Bearer " + localVarAccessTokenValue;
      }
    };
    exports2.setOAuthToObject = setOAuthToObject;
    function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
      if (parameter == null)
        return;
      if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
          parameter.forEach((item) => setFlattenedQueryParams(urlSearchParams, item, key));
        } else {
          Object.keys(parameter).forEach((currentKey) => setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== "" ? "." : ""}${currentKey}`));
        }
      } else {
        if (urlSearchParams.has(key)) {
          urlSearchParams.append(key, parameter);
        } else {
          urlSearchParams.set(key, parameter);
        }
      }
    }
    var setSearchParams = function(url, ...objects) {
      const searchParams = new URLSearchParams(url.search);
      setFlattenedQueryParams(searchParams, objects);
      url.search = searchParams.toString();
    };
    exports2.setSearchParams = setSearchParams;
    var serializeDataIfNeeded = function(value, requestOptions, configuration) {
      const nonString = typeof value !== "string";
      const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
      return needsSerialization ? JSON.stringify(value !== void 0 ? value : {}) : value || "";
    };
    exports2.serializeDataIfNeeded = serializeDataIfNeeded;
    var toPathString = function(url) {
      return url.pathname + url.search + url.hash;
    };
    exports2.toPathString = toPathString;
    var createRequestFunction = function(axiosArgs, globalAxios, BASE_PATH, configuration) {
      return (axios = globalAxios, basePath = BASE_PATH) => {
        const axiosRequestArgs = { ...axiosArgs.options, url: (axios.defaults.baseURL ? "" : configuration?.basePath ?? basePath) + axiosArgs.url };
        return axios.request(axiosRequestArgs);
      };
    };
    exports2.createRequestFunction = createRequestFunction;
  }
});

// node_modules/@eulerstream/euler-api-sdk/dist/sdk/api.js
var require_api = __commonJS({
  "node_modules/@eulerstream/euler-api-sdk/dist/sdk/api.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TikTokLIVEApi = exports2.TikTokLIVEApiFactory = exports2.TikTokLIVEApiFp = exports2.TikTokLIVEApiAxiosParamCreator = exports2.UpdateKeyUpdateByEnum = exports2.GetKeyRetrieveByEnum = exports2.DeleteKeyDeleteByEnum = exports2.AuthenticationApi = exports2.AuthenticationApiFactory = exports2.AuthenticationApiFp = exports2.AuthenticationApiAxiosParamCreator = exports2.AnalyticsApi = exports2.AnalyticsApiFactory = exports2.AnalyticsApiFp = exports2.AnalyticsApiAxiosParamCreator = exports2.AlertsApi = exports2.AlertsApiFactory = exports2.AlertsApiFp = exports2.AlertsApiAxiosParamCreator = exports2.AlertTargetsApi = exports2.AlertTargetsApiFactory = exports2.AlertTargetsApiFp = exports2.AlertTargetsApiAxiosParamCreator = exports2.RetrieveAggregateUsagePeriodEnum = exports2.AccountsApi = exports2.AccountsApiFactory = exports2.AccountsApiFp = exports2.AccountsApiAxiosParamCreator = exports2.WebcastFetchPlatform = exports2.StreamType = exports2.SignTikTokUrlBodyTypeEnum = exports2.SignTikTokUrlBodyMethodEnum = exports2.ProxyRegion = exports2.PeerRole = exports2.PeerPresenceTypeEnum = exports2.AlertTargetStatus = exports2.AlertTargetFormat = exports2.AccountScopes = void 0;
    var axios_1 = __importDefault(require_axios());
    var common_1 = require_common();
    var base_1 = require_base();
    exports2.AccountScopes = {
      NUMBER_MINUS_1: -1,
      NUMBER_0: 0,
      NUMBER_1: 1,
      NUMBER_3: 3,
      NUMBER_5: 5,
      NUMBER_6: 6,
      NUMBER_7: 7,
      NUMBER_8: 8,
      NUMBER_9: 9,
      NUMBER_10: 10,
      NUMBER_11: 11
    };
    exports2.AlertTargetFormat = {
      NUMBER_1: 1
    };
    exports2.AlertTargetStatus = {
      NUMBER_0: 0,
      NUMBER_1: 1,
      NUMBER_4: 4
    };
    exports2.PeerPresenceTypeEnum = {
      Api: "api",
      Agent: "agent"
    };
    exports2.PeerRole = {
      Public: "public",
      Enterprise: "enterprise",
      Staging: "staging"
    };
    exports2.ProxyRegion = {
      De: "DE",
      Es: "ES",
      Fr: "FR",
      Gb: "GB",
      Pl: "PL"
    };
    exports2.SignTikTokUrlBodyMethodEnum = {
      Get: "GET",
      Post: "POST",
      Options: "OPTIONS",
      Put: "PUT",
      Delete: "DELETE",
      Patch: "PATCH",
      Head: "HEAD"
    };
    exports2.SignTikTokUrlBodyTypeEnum = {
      Fetch: "fetch",
      Xhr: "xhr"
    };
    exports2.StreamType = {
      HlsLd: "hls_ld",
      HlsSd: "hls_sd",
      FlvLd: "flv_ld",
      FlvSd: "flv_sd"
    };
    exports2.WebcastFetchPlatform = {
      Mobile: "mobile",
      Web: "web"
    };
    var AccountsApiAxiosParamCreator = function(configuration) {
      return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countSignUsage: async (accountId, from, to, apiKeyId, options = {}) => {
          (0, common_1.assertParamExists)("countSignUsage", "accountId", accountId);
          (0, common_1.assertParamExists)("countSignUsage", "from", from);
          (0, common_1.assertParamExists)("countSignUsage", "to", to);
          const localVarPath = `/accounts/{account_id}/usage/sign_usage/page_count`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (from !== void 0) {
            localVarQueryParameter["from"] = from instanceof Date ? from.toISOString() : from;
          }
          if (to !== void 0) {
            localVarQueryParameter["to"] = to instanceof Date ? to.toISOString() : to;
          }
          if (apiKeyId !== void 0) {
            localVarQueryParameter["api_key_id"] = apiKeyId;
          }
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUsage: async (accountId, from, to, apiKeyId, page, options = {}) => {
          (0, common_1.assertParamExists)("getSignUsage", "accountId", accountId);
          (0, common_1.assertParamExists)("getSignUsage", "from", from);
          (0, common_1.assertParamExists)("getSignUsage", "to", to);
          const localVarPath = `/accounts/{account_id}/usage/sign_usage`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (from !== void 0) {
            localVarQueryParameter["from"] = from instanceof Date ? from.toISOString() : from;
          }
          if (to !== void 0) {
            localVarQueryParameter["to"] = to instanceof Date ? to.toISOString() : to;
          }
          if (apiKeyId !== void 0) {
            localVarQueryParameter["api_key_id"] = apiKeyId;
          }
          if (page !== void 0) {
            localVarQueryParameter["page"] = page;
          }
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountSelf: async (options = {}) => {
          const localVarPath = `/accounts/me`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAggregateUsage: async (accountId, period, value, options = {}) => {
          (0, common_1.assertParamExists)("retrieveAggregateUsage", "accountId", accountId);
          (0, common_1.assertParamExists)("retrieveAggregateUsage", "period", period);
          (0, common_1.assertParamExists)("retrieveAggregateUsage", "value", value);
          const localVarPath = `/accounts/{account_id}/usage/sign_usage/aggregate`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (period !== void 0) {
            localVarQueryParameter["period"] = period;
          }
          if (value !== void 0) {
            localVarQueryParameter["value"] = value;
          }
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        }
      };
    };
    exports2.AccountsApiAxiosParamCreator = AccountsApiAxiosParamCreator;
    var AccountsApiFp = function(configuration) {
      const localVarAxiosParamCreator = (0, exports2.AccountsApiAxiosParamCreator)(configuration);
      return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countSignUsage(accountId, from, to, apiKeyId, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.countSignUsage(accountId, from, to, apiKeyId, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AccountsApi.countSignUsage"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSignUsage(accountId, from, to, apiKeyId, page, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.getSignUsage(accountId, from, to, apiKeyId, page, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AccountsApi.getSignUsage"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAccountSelf(options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAccountSelf(options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AccountsApi.retrieveAccountSelf"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAggregateUsage(accountId, period, value, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAggregateUsage(accountId, period, value, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AccountsApi.retrieveAggregateUsage"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
      };
    };
    exports2.AccountsApiFp = AccountsApiFp;
    var AccountsApiFactory = function(configuration, basePath, axios) {
      const localVarFp = (0, exports2.AccountsApiFp)(configuration);
      return {
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countSignUsage(accountId, from, to, apiKeyId, options) {
          return localVarFp.countSignUsage(accountId, from, to, apiKeyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {string} from Start date for the logs
         * @param {string} to End date for the logs
         * @param {number} [apiKeyId] Optional API key ID to filter logs by
         * @param {number} [page] Page number to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSignUsage(accountId, from, to, apiKeyId, page, options) {
          return localVarFp.getSignUsage(accountId, from, to, apiKeyId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an account from the Sign API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccountSelf(options) {
          return localVarFp.retrieveAccountSelf(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the usage logs for a specific account
         * @param {number} accountId Account ID to retrieve usage logs for
         * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
         * @param {number} value The value for the period (either hours or numbers)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAggregateUsage(accountId, period, value, options) {
          return localVarFp.retrieveAggregateUsage(accountId, period, value, options).then((request) => request(axios, basePath));
        }
      };
    };
    exports2.AccountsApiFactory = AccountsApiFactory;
    var AccountsApi = class extends base_1.BaseAPI {
      /**
       * Retrieve the usage logs for a specific account
       * @param {number} accountId Account ID to retrieve usage logs for
       * @param {string} from Start date for the logs
       * @param {string} to End date for the logs
       * @param {number} [apiKeyId] Optional API key ID to filter logs by
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AccountsApi
       */
      countSignUsage(accountId, from, to, apiKeyId, options) {
        return (0, exports2.AccountsApiFp)(this.configuration).countSignUsage(accountId, from, to, apiKeyId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Retrieve the usage logs for a specific account
       * @param {number} accountId Account ID to retrieve usage logs for
       * @param {string} from Start date for the logs
       * @param {string} to End date for the logs
       * @param {number} [apiKeyId] Optional API key ID to filter logs by
       * @param {number} [page] Page number to retrieve
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AccountsApi
       */
      getSignUsage(accountId, from, to, apiKeyId, page, options) {
        return (0, exports2.AccountsApiFp)(this.configuration).getSignUsage(accountId, from, to, apiKeyId, page, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Retrieve an account from the Sign API
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AccountsApi
       */
      retrieveAccountSelf(options) {
        return (0, exports2.AccountsApiFp)(this.configuration).retrieveAccountSelf(options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Retrieve the usage logs for a specific account
       * @param {number} accountId Account ID to retrieve usage logs for
       * @param {RetrieveAggregateUsagePeriodEnum} period The period for aggregate statistics to check
       * @param {number} value The value for the period (either hours or numbers)
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AccountsApi
       */
      retrieveAggregateUsage(accountId, period, value, options) {
        return (0, exports2.AccountsApiFp)(this.configuration).retrieveAggregateUsage(accountId, period, value, options).then((request) => request(this.axios, this.basePath));
      }
    };
    exports2.AccountsApi = AccountsApi;
    exports2.RetrieveAggregateUsagePeriodEnum = {
      Hour: "hour",
      Day: "day"
    };
    var AlertTargetsApiAxiosParamCreator = function(configuration) {
      return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget: async (accountId, alertId, createAlertTargetPayload, options = {}) => {
          (0, common_1.assertParamExists)("createAlertTarget", "accountId", accountId);
          (0, common_1.assertParamExists)("createAlertTarget", "alertId", alertId);
          (0, common_1.assertParamExists)("createAlertTarget", "createAlertTargetPayload", createAlertTargetPayload);
          const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/create`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId))).replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          localVarHeaderParameter["Content-Type"] = "application/json";
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAlertTargetPayload, localVarRequestOptions, configuration);
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget: async (accountId, alertId, targetId, options = {}) => {
          (0, common_1.assertParamExists)("deleteAlertTarget", "accountId", accountId);
          (0, common_1.assertParamExists)("deleteAlertTarget", "alertId", alertId);
          (0, common_1.assertParamExists)("deleteAlertTarget", "targetId", targetId);
          const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/delete`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId))).replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId))).replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets: async (accountId, alertId, options = {}) => {
          (0, common_1.assertParamExists)("listAlertTargets", "accountId", accountId);
          (0, common_1.assertParamExists)("listAlertTargets", "alertId", alertId);
          const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/list`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId))).replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget: async (accountId, alertId, targetId, options = {}) => {
          (0, common_1.assertParamExists)("testAlertTarget", "accountId", accountId);
          (0, common_1.assertParamExists)("testAlertTarget", "alertId", alertId);
          (0, common_1.assertParamExists)("testAlertTarget", "targetId", targetId);
          const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/targets/{target_id}/test`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId))).replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId))).replace(`{${"target_id"}}`, encodeURIComponent(String(targetId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        }
      };
    };
    exports2.AlertTargetsApiAxiosParamCreator = AlertTargetsApiAxiosParamCreator;
    var AlertTargetsApiFp = function(configuration) {
      const localVarAxiosParamCreator = (0, exports2.AlertTargetsApiAxiosParamCreator)(configuration);
      return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlertTarget(accountId, alertId, createAlertTargetPayload, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.createAlertTarget(accountId, alertId, createAlertTargetPayload, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AlertTargetsApi.createAlertTarget"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlertTarget(accountId, alertId, targetId, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlertTarget(accountId, alertId, targetId, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AlertTargetsApi.deleteAlertTarget"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlertTargets(accountId, alertId, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.listAlertTargets(accountId, alertId, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AlertTargetsApi.listAlertTargets"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testAlertTarget(accountId, alertId, targetId, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.testAlertTarget(accountId, alertId, targetId, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AlertTargetsApi.testAlertTarget"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
      };
    };
    exports2.AlertTargetsApiFp = AlertTargetsApiFp;
    var AlertTargetsApiFactory = function(configuration, basePath, axios) {
      const localVarFp = (0, exports2.AlertTargetsApiFp)(configuration);
      return {
        /**
         * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
         * @param {number} accountId The ID of the account to create the alert target for
         * @param {number} alertId The ID of the alert to create the target for
         * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlertTarget(accountId, alertId, createAlertTargetPayload, options) {
          return localVarFp.createAlertTarget(accountId, alertId, createAlertTargetPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert target from the Sign API
         * @param {number} accountId The ID of the account to delete the alert target from
         * @param {number} alertId The ID of the alert to delete the target from
         * @param {number} targetId The ID of the target to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlertTarget(accountId, alertId, targetId, options) {
          return localVarFp.deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all alert targets for a specific alert
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert to list targets for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlertTargets(accountId, alertId, options) {
          return localVarFp.listAlertTargets(accountId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Test an alert target
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The alert that the target belongs to
         * @param {number} targetId The target to test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testAlertTarget(accountId, alertId, targetId, options) {
          return localVarFp.testAlertTarget(accountId, alertId, targetId, options).then((request) => request(axios, basePath));
        }
      };
    };
    exports2.AlertTargetsApiFactory = AlertTargetsApiFactory;
    var AlertTargetsApi = class extends base_1.BaseAPI {
      /**
       * Create a target for an alert. This is the HTTP endpoint that will be called when an alert is triggered.
       * @param {number} accountId The ID of the account to create the alert target for
       * @param {number} alertId The ID of the alert to create the target for
       * @param {CreateAlertTargetPayload} createAlertTargetPayload Configuration for the alert target
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AlertTargetsApi
       */
      createAlertTarget(accountId, alertId, createAlertTargetPayload, options) {
        return (0, exports2.AlertTargetsApiFp)(this.configuration).createAlertTarget(accountId, alertId, createAlertTargetPayload, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Delete an alert target from the Sign API
       * @param {number} accountId The ID of the account to delete the alert target from
       * @param {number} alertId The ID of the alert to delete the target from
       * @param {number} targetId The ID of the target to delete
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AlertTargetsApi
       */
      deleteAlertTarget(accountId, alertId, targetId, options) {
        return (0, exports2.AlertTargetsApiFp)(this.configuration).deleteAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * List all alert targets for a specific alert
       * @param {number} accountId The account that the alert belongs to
       * @param {number} alertId The alert to list targets for
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AlertTargetsApi
       */
      listAlertTargets(accountId, alertId, options) {
        return (0, exports2.AlertTargetsApiFp)(this.configuration).listAlertTargets(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Test an alert target
       * @param {number} accountId The account that the alert belongs to
       * @param {number} alertId The alert that the target belongs to
       * @param {number} targetId The target to test
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AlertTargetsApi
       */
      testAlertTarget(accountId, alertId, targetId, options) {
        return (0, exports2.AlertTargetsApiFp)(this.configuration).testAlertTarget(accountId, alertId, targetId, options).then((request) => request(this.axios, this.basePath));
      }
    };
    exports2.AlertTargetsApi = AlertTargetsApi;
    var AlertsApiAxiosParamCreator = function(configuration) {
      return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert: async (accountId, createAlertRequest, options = {}) => {
          (0, common_1.assertParamExists)("createAlert", "accountId", accountId);
          (0, common_1.assertParamExists)("createAlert", "createAlertRequest", createAlertRequest);
          const localVarPath = `/accounts/{account_id}/alerts/create`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          localVarHeaderParameter["Content-Type"] = "application/json";
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAlertRequest, localVarRequestOptions, configuration);
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert: async (accountId, alertId, options = {}) => {
          (0, common_1.assertParamExists)("deleteAlert", "accountId", accountId);
          (0, common_1.assertParamExists)("deleteAlert", "alertId", alertId);
          const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/delete`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId))).replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         *
         * @param {number} accountId
         * @param {number} [page]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts: async (accountId, page, options = {}) => {
          (0, common_1.assertParamExists)("listAlerts", "accountId", accountId);
          const localVarPath = `/accounts/{account_id}/alerts/list`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (page !== void 0) {
            localVarQueryParameter["page"] = page;
          }
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert: async (accountId, alertId, options = {}) => {
          (0, common_1.assertParamExists)("retrieveAlert", "accountId", accountId);
          (0, common_1.assertParamExists)("retrieveAlert", "alertId", alertId);
          const localVarPath = `/accounts/{account_id}/alerts/{alert_id}/retrieve`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId))).replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        }
      };
    };
    exports2.AlertsApiAxiosParamCreator = AlertsApiAxiosParamCreator;
    var AlertsApiFp = function(configuration) {
      const localVarAxiosParamCreator = (0, exports2.AlertsApiAxiosParamCreator)(configuration);
      return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAlert(accountId, createAlertRequest, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.createAlert(accountId, createAlertRequest, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AlertsApi.createAlert"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAlert(accountId, alertId, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAlert(accountId, alertId, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AlertsApi.deleteAlert"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {number} accountId
         * @param {number} [page]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAlerts(accountId, page, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.listAlerts(accountId, page, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AlertsApi.listAlerts"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAlert(accountId, alertId, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAlert(accountId, alertId, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AlertsApi.retrieveAlert"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
      };
    };
    exports2.AlertsApiFp = AlertsApiFp;
    var AlertsApiFactory = function(configuration, basePath, axios) {
      const localVarFp = (0, exports2.AlertsApiFp)(configuration);
      return {
        /**
         * Create a creator alert. These Alerts are used to notify users of a new livestream.
         * @param {number} accountId The ID of the account to create the alert for
         * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(accountId, createAlertRequest, options) {
          return localVarFp.createAlert(accountId, createAlertRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an alert from the Sign API
         * @param {number} accountId The ID of the account to delete the alert from
         * @param {number} alertId The ID of the alert to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert(accountId, alertId, options) {
          return localVarFp.deleteAlert(accountId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {number} accountId
         * @param {number} [page]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts(accountId, page, options) {
          return localVarFp.listAlerts(accountId, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific alert by its ID
         * @param {number} accountId The account that the alert belongs to
         * @param {number} alertId The ID of the alert to retrieve
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAlert(accountId, alertId, options) {
          return localVarFp.retrieveAlert(accountId, alertId, options).then((request) => request(axios, basePath));
        }
      };
    };
    exports2.AlertsApiFactory = AlertsApiFactory;
    var AlertsApi = class extends base_1.BaseAPI {
      /**
       * Create a creator alert. These Alerts are used to notify users of a new livestream.
       * @param {number} accountId The ID of the account to create the alert for
       * @param {CreateAlertRequest} createAlertRequest Configuration for the alert
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AlertsApi
       */
      createAlert(accountId, createAlertRequest, options) {
        return (0, exports2.AlertsApiFp)(this.configuration).createAlert(accountId, createAlertRequest, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Delete an alert from the Sign API
       * @param {number} accountId The ID of the account to delete the alert from
       * @param {number} alertId The ID of the alert to delete
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AlertsApi
       */
      deleteAlert(accountId, alertId, options) {
        return (0, exports2.AlertsApiFp)(this.configuration).deleteAlert(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @param {number} accountId
       * @param {number} [page]
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AlertsApi
       */
      listAlerts(accountId, page, options) {
        return (0, exports2.AlertsApiFp)(this.configuration).listAlerts(accountId, page, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Retrieve a specific alert by its ID
       * @param {number} accountId The account that the alert belongs to
       * @param {number} alertId The ID of the alert to retrieve
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AlertsApi
       */
      retrieveAlert(accountId, alertId, options) {
        return (0, exports2.AlertsApiFp)(this.configuration).retrieveAlert(accountId, alertId, options).then((request) => request(this.axios, this.basePath));
      }
    };
    exports2.AlertsApi = AlertsApi;
    var AnalyticsApiAxiosParamCreator = function(configuration) {
      return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents: async (options = {}) => {
          const localVarPath = `/analytics/agents`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts: async (options = {}) => {
          const localVarPath = `/analytics/hosts`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        }
      };
    };
    exports2.AnalyticsApiAxiosParamCreator = AnalyticsApiAxiosParamCreator;
    var AnalyticsApiFp = function(configuration) {
      const localVarAxiosParamCreator = (0, exports2.AnalyticsApiAxiosParamCreator)(configuration);
      return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAgents(options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.fetchAgents(options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AnalyticsApi.fetchAgents"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHosts(options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.getHosts(options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AnalyticsApi.getHosts"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
      };
    };
    exports2.AnalyticsApiFp = AnalyticsApiFp;
    var AnalyticsApiFactory = function(configuration, basePath, axios) {
      const localVarFp = (0, exports2.AnalyticsApiFp)(configuration);
      return {
        /**
         * Retrieve the currently connected agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAgents(options) {
          return localVarFp.fetchAgents(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the list of API hosts (used for horizontal scaling)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHosts(options) {
          return localVarFp.getHosts(options).then((request) => request(axios, basePath));
        }
      };
    };
    exports2.AnalyticsApiFactory = AnalyticsApiFactory;
    var AnalyticsApi = class extends base_1.BaseAPI {
      /**
       * Retrieve the currently connected agents
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AnalyticsApi
       */
      fetchAgents(options) {
        return (0, exports2.AnalyticsApiFp)(this.configuration).fetchAgents(options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Retrieve the list of API hosts (used for horizontal scaling)
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AnalyticsApi
       */
      getHosts(options) {
        return (0, exports2.AnalyticsApiFp)(this.configuration).getHosts(options).then((request) => request(this.axios, this.basePath));
      }
    };
    exports2.AnalyticsApi = AnalyticsApi;
    var AuthenticationApiAxiosParamCreator = function(configuration) {
      return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT: async (accountId, jWTCreateConfig, options = {}) => {
          (0, common_1.assertParamExists)("createJWT", "accountId", accountId);
          (0, common_1.assertParamExists)("createJWT", "jWTCreateConfig", jWTCreateConfig);
          const localVarPath = `/accounts/{account_id}/jwt/create`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          localVarHeaderParameter["Content-Type"] = "application/json";
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(jWTCreateConfig, localVarRequestOptions, configuration);
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey: async (accountId, createKeyPayload, options = {}) => {
          (0, common_1.assertParamExists)("createKey", "accountId", accountId);
          (0, common_1.assertParamExists)("createKey", "createKeyPayload", createKeyPayload);
          const localVarPath = `/accounts/{account_id}/api_keys/create`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          localVarHeaderParameter["Content-Type"] = "application/json";
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createKeyPayload, localVarRequestOptions, configuration);
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey: async (accountId, deleteBy, deleteParam, options = {}) => {
          (0, common_1.assertParamExists)("deleteKey", "accountId", accountId);
          (0, common_1.assertParamExists)("deleteKey", "deleteBy", deleteBy);
          (0, common_1.assertParamExists)("deleteKey", "deleteParam", deleteParam);
          const localVarPath = `/accounts/{account_id}/api_keys/delete`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "DELETE", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (deleteBy !== void 0) {
            localVarQueryParameter["delete_by"] = deleteBy;
          }
          if (deleteParam !== void 0) {
            localVarQueryParameter["delete_param"] = deleteParam;
          }
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey: async (accountId, retrieveParam, retrieveBy, options = {}) => {
          (0, common_1.assertParamExists)("getKey", "accountId", accountId);
          (0, common_1.assertParamExists)("getKey", "retrieveParam", retrieveParam);
          const localVarPath = `/accounts/{account_id}/api_keys/retrieve`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (retrieveBy !== void 0) {
            localVarQueryParameter["retrieve_by"] = retrieveBy;
          }
          if (retrieveParam !== void 0) {
            localVarQueryParameter["retrieve_param"] = retrieveParam;
          }
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys: async (accountId, options = {}) => {
          (0, common_1.assertParamExists)("listKeys", "accountId", accountId);
          const localVarPath = `/accounts/{account_id}/api_keys/list`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey: async (accountId, updateBy, updateParam, updateKeyPayload, options = {}) => {
          (0, common_1.assertParamExists)("updateKey", "accountId", accountId);
          (0, common_1.assertParamExists)("updateKey", "updateBy", updateBy);
          (0, common_1.assertParamExists)("updateKey", "updateParam", updateParam);
          (0, common_1.assertParamExists)("updateKey", "updateKeyPayload", updateKeyPayload);
          const localVarPath = `/accounts/{account_id}/api_keys/update`.replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (updateBy !== void 0) {
            localVarQueryParameter["update_by"] = updateBy;
          }
          if (updateParam !== void 0) {
            localVarQueryParameter["update_param"] = updateParam;
          }
          localVarHeaderParameter["Content-Type"] = "application/json";
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateKeyPayload, localVarRequestOptions, configuration);
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        }
      };
    };
    exports2.AuthenticationApiAxiosParamCreator = AuthenticationApiAxiosParamCreator;
    var AuthenticationApiFp = function(configuration) {
      const localVarAxiosParamCreator = (0, exports2.AuthenticationApiAxiosParamCreator)(configuration);
      return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJWT(accountId, jWTCreateConfig, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.createJWT(accountId, jWTCreateConfig, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AuthenticationApi.createJWT"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKey(accountId, createKeyPayload, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.createKey(accountId, createKeyPayload, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AuthenticationApi.createKey"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteKey(accountId, deleteBy, deleteParam, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.deleteKey(accountId, deleteBy, deleteParam, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AuthenticationApi.deleteKey"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKey(accountId, retrieveParam, retrieveBy, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.getKey(accountId, retrieveParam, retrieveBy, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AuthenticationApi.getKey"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeys(accountId, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.listKeys(accountId, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AuthenticationApi.listKeys"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKey(accountId, updateBy, updateParam, updateKeyPayload, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.updateKey(accountId, updateBy, updateParam, updateKeyPayload, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["AuthenticationApi.updateKey"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
      };
    };
    exports2.AuthenticationApiFp = AuthenticationApiFp;
    var AuthenticationApiFactory = function(configuration, basePath, axios) {
      const localVarFp = (0, exports2.AuthenticationApiFp)(configuration);
      return {
        /**
         * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
         * @param {number} accountId The ID of the account to create the JWT for
         * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJWT(accountId, jWTCreateConfig, options) {
          return localVarFp.createJWT(accountId, jWTCreateConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new API key
         * @param {number} accountId The ID of the account to create the key for
         * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKey(accountId, createKeyPayload, options) {
          return localVarFp.createKey(accountId, createKeyPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to delete the key for
         * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
         * @param {string} deleteParam The API key field value to delete by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteKey(accountId, deleteBy, deleteParam, options) {
          return localVarFp.deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {string} retrieveParam The API key field value to retrieve by
         * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKey(accountId, retrieveParam, retrieveBy, options) {
          return localVarFp.getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve an API key by its key value, name, or ID
         * @param {number} accountId The ID of the account to retrieve the key for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeys(accountId, options) {
          return localVarFp.listKeys(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an existing API key
         * @param {number} accountId The account to update the key for
         * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
         * @param {string} updateParam The API key field value to update by
         * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKey(accountId, updateBy, updateParam, updateKeyPayload, options) {
          return localVarFp.updateKey(accountId, updateBy, updateParam, updateKeyPayload, options).then((request) => request(axios, basePath));
        }
      };
    };
    exports2.AuthenticationApiFactory = AuthenticationApiFactory;
    var AuthenticationApi = class extends base_1.BaseAPI {
      /**
       * Create a JWT for a given API key. Note that these JWT keys are only valid for the non-authenticated Webcast endpoints. They function to attach the rate limits of the API key to the request for client-sided applications.
       * @param {number} accountId The ID of the account to create the JWT for
       * @param {JWTCreateConfig} jWTCreateConfig The configuration for the JWT
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AuthenticationApi
       */
      createJWT(accountId, jWTCreateConfig, options) {
        return (0, exports2.AuthenticationApiFp)(this.configuration).createJWT(accountId, jWTCreateConfig, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Create a new API key
       * @param {number} accountId The ID of the account to create the key for
       * @param {CreateKeyPayload} createKeyPayload The configuration for the new key
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AuthenticationApi
       */
      createKey(accountId, createKeyPayload, options) {
        return (0, exports2.AuthenticationApiFp)(this.configuration).createKey(accountId, createKeyPayload, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Delete an API key by its key value, name, or ID
       * @param {number} accountId The ID of the account to delete the key for
       * @param {DeleteKeyDeleteByEnum} deleteBy The API key field to delete by
       * @param {string} deleteParam The API key field value to delete by
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AuthenticationApi
       */
      deleteKey(accountId, deleteBy, deleteParam, options) {
        return (0, exports2.AuthenticationApiFp)(this.configuration).deleteKey(accountId, deleteBy, deleteParam, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Retrieve an API key by its key value, name, or ID
       * @param {number} accountId The ID of the account to retrieve the key for
       * @param {string} retrieveParam The API key field value to retrieve by
       * @param {GetKeyRetrieveByEnum} [retrieveBy] The API key field to retrieve by
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AuthenticationApi
       */
      getKey(accountId, retrieveParam, retrieveBy, options) {
        return (0, exports2.AuthenticationApiFp)(this.configuration).getKey(accountId, retrieveParam, retrieveBy, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Retrieve an API key by its key value, name, or ID
       * @param {number} accountId The ID of the account to retrieve the key for
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AuthenticationApi
       */
      listKeys(accountId, options) {
        return (0, exports2.AuthenticationApiFp)(this.configuration).listKeys(accountId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Update an existing API key
       * @param {number} accountId The account to update the key for
       * @param {UpdateKeyUpdateByEnum} updateBy The API key field to update by
       * @param {string} updateParam The API key field value to update by
       * @param {UpdateKeyPayload} updateKeyPayload The new configuration for the key
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof AuthenticationApi
       */
      updateKey(accountId, updateBy, updateParam, updateKeyPayload, options) {
        return (0, exports2.AuthenticationApiFp)(this.configuration).updateKey(accountId, updateBy, updateParam, updateKeyPayload, options).then((request) => request(this.axios, this.basePath));
      }
    };
    exports2.AuthenticationApi = AuthenticationApi;
    exports2.DeleteKeyDeleteByEnum = {
      Value: "value",
      Id: "id"
    };
    exports2.GetKeyRetrieveByEnum = {
      Value: "value",
      Id: "id"
    };
    exports2.UpdateKeyUpdateByEnum = {
      Value: "value",
      Id: "id"
    };
    var TikTokLIVEApiAxiosParamCreator = function(configuration) {
      return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [sessionId] Cookie - The account session ID from TikTok web
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {ProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL: async (client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options = {}) => {
          const localVarPath = `/webcast/fetch`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (client !== void 0) {
            localVarQueryParameter["client"] = client;
          }
          if (roomId !== void 0) {
            localVarQueryParameter["room_id"] = roomId;
          }
          if (uniqueId !== void 0) {
            localVarQueryParameter["unique_id"] = uniqueId;
          }
          if (cursor !== void 0) {
            localVarQueryParameter["cursor"] = cursor;
          }
          if (sessionId !== void 0) {
            localVarQueryParameter["session_id"] = sessionId;
          }
          if (userAgent !== void 0) {
            localVarQueryParameter["user_agent"] = userAgent;
          }
          if (ttTargetIdc !== void 0) {
            localVarQueryParameter["tt_target_idc"] = ttTargetIdc;
          }
          if (clientEnter !== void 0) {
            localVarQueryParameter["client_enter"] = clientEnter;
          }
          if (country !== void 0) {
            localVarQueryParameter["country"] = country;
          }
          if (platform !== void 0) {
            localVarQueryParameter["platform"] = platform;
          }
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits: async (options = {}) => {
          const localVarPath = `/webcast/rate_limits`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
         * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBulkLiveCheck: async (retrieveBulkLiveCheckPayload, options = {}) => {
          (0, common_1.assertParamExists)("retrieveBulkLiveCheck", "retrieveBulkLiveCheckPayload", retrieveBulkLiveCheckPayload);
          const localVarPath = `/webcast/bulk_live_check`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          localVarHeaderParameter["Content-Type"] = "application/json";
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(retrieveBulkLiveCheckPayload, localVarRequestOptions, configuration);
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Retrieve TikTok Live Room Gift List
         * @param {string} roomId The room ID of the TikTok LIVE session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGiftInfo: async (roomId, options = {}) => {
          (0, common_1.assertParamExists)("retrieveGiftInfo", "roomId", roomId);
          const localVarPath = `/webcast/gift_info`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (roomId !== void 0) {
            localVarQueryParameter["room_id"] = roomId;
          }
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomCover: async (uniqueId, options = {}) => {
          (0, common_1.assertParamExists)("retrieveRoomCover", "uniqueId", uniqueId);
          const localVarPath = `/webcast/room_cover`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (uniqueId !== void 0) {
            localVarQueryParameter["uniqueId"] = uniqueId;
          }
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId: async (uniqueId, options = {}) => {
          (0, common_1.assertParamExists)("retrieveRoomId", "uniqueId", uniqueId);
          const localVarPath = `/webcast/room_id`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (uniqueId !== void 0) {
            localVarQueryParameter["uniqueId"] = uniqueId;
          }
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo: async (uniqueId, options = {}) => {
          (0, common_1.assertParamExists)("retrieveRoomInfo", "uniqueId", uniqueId);
          const localVarPath = `/webcast/room_info`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (uniqueId !== void 0) {
            localVarQueryParameter["uniqueId"] = uniqueId;
          }
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomVideo: async (uniqueId, streamType, options = {}) => {
          (0, common_1.assertParamExists)("retrieveRoomVideo", "uniqueId", uniqueId);
          const localVarPath = `/webcast/room_video`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-jwt-key", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (uniqueId !== void 0) {
            localVarQueryParameter["uniqueId"] = uniqueId;
          }
          if (streamType !== void 0) {
            localVarQueryParameter["streamType"] = streamType;
          }
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         * Send a chat to a TikTok LIVE room.
         * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat: async (webcastRoomChatPayload, options = {}) => {
          (0, common_1.assertParamExists)("sendRoomChat", "webcastRoomChatPayload", webcastRoomChatPayload);
          const localVarPath = `/webcast/chat`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          localVarHeaderParameter["Content-Type"] = "application/json";
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(webcastRoomChatPayload, localVarRequestOptions, configuration);
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        },
        /**
         *
         * @param {SignTikTokUrlBody} signTikTokUrlBody
         * @param {string} [client]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl: async (signTikTokUrlBody, client, options = {}) => {
          (0, common_1.assertParamExists)("signWebcastUrl", "signTikTokUrlBody", signTikTokUrlBody);
          const localVarPath = `/webcast/sign_url`;
          const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
          let baseOptions;
          if (configuration) {
            baseOptions = configuration.baseOptions;
          }
          const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
          const localVarHeaderParameter = {};
          const localVarQueryParameter = {};
          await (0, common_1.setApiKeyToObject)(localVarQueryParameter, "apiKey", configuration);
          await (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "x-api-key", configuration);
          if (client !== void 0) {
            localVarQueryParameter["client"] = client;
          }
          localVarHeaderParameter["Content-Type"] = "application/json";
          (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
          localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(signTikTokUrlBody, localVarRequestOptions, configuration);
          return {
            url: (0, common_1.toPathString)(localVarUrlObj),
            options: localVarRequestOptions
          };
        }
      };
    };
    exports2.TikTokLIVEApiAxiosParamCreator = TikTokLIVEApiAxiosParamCreator;
    var TikTokLIVEApiFp = function(configuration) {
      const localVarAxiosParamCreator = (0, exports2.TikTokLIVEApiAxiosParamCreator)(configuration);
      return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [sessionId] Cookie - The account session ID from TikTok web
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {ProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["TikTokLIVEApi.fetchWebcastURL"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRateLimits(options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.getRateLimits(options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["TikTokLIVEApi.getRateLimits"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
         * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["TikTokLIVEApi.retrieveBulkLiveCheck"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve TikTok Live Room Gift List
         * @param {string} roomId The room ID of the TikTok LIVE session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveGiftInfo(roomId, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveGiftInfo(roomId, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["TikTokLIVEApi.retrieveGiftInfo"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomCover(uniqueId, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomCover(uniqueId, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["TikTokLIVEApi.retrieveRoomCover"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomId(uniqueId, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomId(uniqueId, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["TikTokLIVEApi.retrieveRoomId"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomInfo(uniqueId, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomInfo(uniqueId, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["TikTokLIVEApi.retrieveRoomInfo"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRoomVideo(uniqueId, streamType, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRoomVideo(uniqueId, streamType, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["TikTokLIVEApi.retrieveRoomVideo"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a chat to a TikTok LIVE room.
         * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendRoomChat(webcastRoomChatPayload, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.sendRoomChat(webcastRoomChatPayload, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["TikTokLIVEApi.sendRoomChat"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         *
         * @param {SignTikTokUrlBody} signTikTokUrlBody
         * @param {string} [client]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signWebcastUrl(signTikTokUrlBody, client, options) {
          const localVarAxiosArgs = await localVarAxiosParamCreator.signWebcastUrl(signTikTokUrlBody, client, options);
          const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
          const localVarOperationServerBasePath = base_1.operationServerMap["TikTokLIVEApi.signWebcastUrl"]?.[localVarOperationServerIndex]?.url;
          return (axios, basePath) => (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        }
      };
    };
    exports2.TikTokLIVEApiFp = TikTokLIVEApiFp;
    var TikTokLIVEApiFactory = function(configuration, basePath, axios) {
      const localVarFp = (0, exports2.TikTokLIVEApiFp)(configuration);
      return {
        /**
         * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
         * @param {string} [client] The client library identifier. Used for metrics.
         * @param {string} [roomId] The room ID to fetch the Webcast URL for.
         * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
         * @param {string} [cursor] Starting cursor for the webcast connection, if any
         * @param {string} [sessionId] Cookie - The account session ID from TikTok web
         * @param {string} [userAgent] Override the user agent used for signing and fetching
         * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
         * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
         * @param {ProxyRegion} [country] Country code to make the request from.
         * @param {WebcastFetchPlatform} [platform] Platform to connect with
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options) {
          return localVarFp.fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRateLimits(options) {
          return localVarFp.getRateLimits(options).then((request) => request(axios, basePath));
        },
        /**
         * A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
         * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options) {
          return localVarFp.retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve TikTok Live Room Gift List
         * @param {string} roomId The room ID of the TikTok LIVE session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGiftInfo(roomId, options) {
          return localVarFp.retrieveGiftInfo(roomId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomCover(uniqueId, options) {
          return localVarFp.retrieveRoomCover(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch Room ID for a given uniqueId & whether that user is live.
         * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomId(uniqueId, options) {
          return localVarFp.retrieveRoomId(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve TikTok Live Room Information
         * @param {string} uniqueId The unique identifier for the TikTok user or room
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomInfo(uniqueId, options) {
          return localVarFp.retrieveRoomInfo(uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch TikTok LIVE Stream video given a uniqueId.
         * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
         * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRoomVideo(uniqueId, streamType, options) {
          return localVarFp.retrieveRoomVideo(uniqueId, streamType, options).then((request) => request(axios, basePath));
        },
        /**
         * Send a chat to a TikTok LIVE room.
         * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendRoomChat(webcastRoomChatPayload, options) {
          return localVarFp.sendRoomChat(webcastRoomChatPayload, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {SignTikTokUrlBody} signTikTokUrlBody
         * @param {string} [client]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signWebcastUrl(signTikTokUrlBody, client, options) {
          return localVarFp.signWebcastUrl(signTikTokUrlBody, client, options).then((request) => request(axios, basePath));
        }
      };
    };
    exports2.TikTokLIVEApiFactory = TikTokLIVEApiFactory;
    var TikTokLIVEApi = class extends base_1.BaseAPI {
      /**
       * Fetch the WebSocket URL & first payload for a TikTok LIVE Room given a Room ID.
       * @param {string} [client] The client library identifier. Used for metrics.
       * @param {string} [roomId] The room ID to fetch the Webcast URL for.
       * @param {string} [uniqueId] The unique ID of the TikTok user. Send this instead of a Room ID, if you\&#39;re an Enterprise user.
       * @param {string} [cursor] Starting cursor for the webcast connection, if any
       * @param {string} [sessionId] Cookie - The account session ID from TikTok web
       * @param {string} [userAgent] Override the user agent used for signing and fetching
       * @param {string} [ttTargetIdc] Cookie - TikTok \&quot;Identity Data Center\&quot; which links a session_id to a region
       * @param {boolean} [clientEnter] Whether the client enters a room after connecting, or if it\&#39;s done by query parameters
       * @param {ProxyRegion} [country] Country code to make the request from.
       * @param {WebcastFetchPlatform} [platform] Platform to connect with
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof TikTokLIVEApi
       */
      fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options) {
        return (0, exports2.TikTokLIVEApiFp)(this.configuration).fetchWebcastURL(client, roomId, uniqueId, cursor, sessionId, userAgent, ttTargetIdc, clientEnter, country, platform, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Retrieve the rate limits for the provided API key (or the unauthenticated limits if no key is provided)
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof TikTokLIVEApi
       */
      getRateLimits(options) {
        return (0, exports2.TikTokLIVEApiFp)(this.configuration).getRateLimits(options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * A bulk-check endpoint to determine if a group of TikTok users (up to 50 at once) are live. It uses a highly optimized job-based system for checking large numbers of users quickly.
       * @param {RetrieveBulkLiveCheckPayload} retrieveBulkLiveCheckPayload The body of the request containing user numeric IDs.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof TikTokLIVEApi
       */
      retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options) {
        return (0, exports2.TikTokLIVEApiFp)(this.configuration).retrieveBulkLiveCheck(retrieveBulkLiveCheckPayload, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Retrieve TikTok Live Room Gift List
       * @param {string} roomId The room ID of the TikTok LIVE session
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof TikTokLIVEApi
       */
      retrieveGiftInfo(roomId, options) {
        return (0, exports2.TikTokLIVEApiFp)(this.configuration).retrieveGiftInfo(roomId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Fetch TikTok LIVE Stream Cover URL given a uniqueId.
       * @param {string} uniqueId The unique ID of the TikTok to fetch the cover for.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof TikTokLIVEApi
       */
      retrieveRoomCover(uniqueId, options) {
        return (0, exports2.TikTokLIVEApiFp)(this.configuration).retrieveRoomCover(uniqueId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Fetch Room ID for a given uniqueId & whether that user is live.
       * @param {string} uniqueId The unique ID of the TikTok user to fetch the data for.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof TikTokLIVEApi
       */
      retrieveRoomId(uniqueId, options) {
        return (0, exports2.TikTokLIVEApiFp)(this.configuration).retrieveRoomId(uniqueId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Retrieve TikTok Live Room Information
       * @param {string} uniqueId The unique identifier for the TikTok user or room
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof TikTokLIVEApi
       */
      retrieveRoomInfo(uniqueId, options) {
        return (0, exports2.TikTokLIVEApiFp)(this.configuration).retrieveRoomInfo(uniqueId, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Fetch TikTok LIVE Stream video given a uniqueId.
       * @param {string} uniqueId The unique ID of the TikTok to fetch the data for.
       * @param {StreamType} [streamType] The type of video stream to fetch. Default is HLS_SD.
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof TikTokLIVEApi
       */
      retrieveRoomVideo(uniqueId, streamType, options) {
        return (0, exports2.TikTokLIVEApiFp)(this.configuration).retrieveRoomVideo(uniqueId, streamType, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       * Send a chat to a TikTok LIVE room.
       * @param {WebcastRoomChatPayload} webcastRoomChatPayload The payload configuration for sending a chat
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof TikTokLIVEApi
       */
      sendRoomChat(webcastRoomChatPayload, options) {
        return (0, exports2.TikTokLIVEApiFp)(this.configuration).sendRoomChat(webcastRoomChatPayload, options).then((request) => request(this.axios, this.basePath));
      }
      /**
       *
       * @param {SignTikTokUrlBody} signTikTokUrlBody
       * @param {string} [client]
       * @param {*} [options] Override http request option.
       * @throws {RequiredError}
       * @memberof TikTokLIVEApi
       */
      signWebcastUrl(signTikTokUrlBody, client, options) {
        return (0, exports2.TikTokLIVEApiFp)(this.configuration).signWebcastUrl(signTikTokUrlBody, client, options).then((request) => request(this.axios, this.basePath));
      }
    };
    exports2.TikTokLIVEApi = TikTokLIVEApi;
  }
});

// node_modules/tiktok-live-connector/dist/lib/web/lib/http-client.js
var require_http_client = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/web/lib/http-client.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var axios_1 = __importDefault(require_axios());
    var utilities_1 = require_utilities();
    var cookie_jar_1 = __importDefault(require_cookie_jar());
    var config_1 = __importDefault(require_config());
    var api_1 = require_api();
    var lib_1 = require_lib3();
    var WebcastHttpClient = class {
      configuration;
      webSigner;
      // HTTP Request Client
      axiosInstance;
      // External Cookie Jar
      cookieJar;
      // Internal Client Parameter Store
      clientParams;
      constructor(configuration = {
        customHeaders: {},
        axiosOptions: {},
        clientParams: {},
        authenticateWs: false,
        signApiKey: void 0
      }, webSigner = new lib_1.EulerSigner(configuration.signApiKey ? { apiKey: configuration.signApiKey } : {})) {
        this.configuration = configuration;
        this.webSigner = webSigner;
        this.axiosInstance = axios_1.default.create({
          timeout: parseInt(process.env.TIKTOK_CLIENT_TIMEOUT || "10000"),
          headers: { ...config_1.default.DEFAULT_HTTP_CLIENT_HEADERS, ...this.configuration.customHeaders },
          ...this.configuration.axiosOptions
        });
        this.clientParams = {
          ...config_1.default.DEFAULT_HTTP_CLIENT_PARAMS,
          ...this.configuration.clientParams
        };
        this.cookieJar = new cookie_jar_1.default(this.axiosInstance);
        if (!!this.configuration.customHeaders?.Cookie) {
          const cookieHeader = this.configuration.customHeaders.Cookie;
          delete this.configuration.customHeaders["Cookie"];
          cookieHeader.split("; ").forEach((v) => this.cookieJar.processSetCookieHeader(v));
        }
      }
      /**
       * Set the Room ID for the client
       * @param roomId The client's Room ID
       */
      set roomId(roomId) {
        this.clientParams.room_id = roomId;
      }
      /**
       * Get the Room ID for the client
       */
      get roomId() {
        return this.clientParams.room_id || "";
      }
      /**
       * Build the URL for the request
       *
       * @param host The host for the request
       * @param path The path for the request
       * @param params The query parameters for the request
       * @param signRequest Whether to sign the request or not
       * @param method The HTTP method for the request
       * @param headers The headers for the request
       * @param extraOptions Additional axios request options
       * @protected
       */
      async request({ host, path, params, signRequest, method = "GET", headers, ...extraOptions }) {
        let secure = !(host.startsWith("127.0.0.1") || host.startsWith("localhost") || host.startsWith("::1"));
        let url = `http${secure ? "s" : ""}://${host}/${path}?${new URLSearchParams(params || {})}`;
        if (signRequest) {
          const signMethod = Object.values(api_1.SignTikTokUrlBodyMethodEnum).includes(method.toUpperCase());
          if (!signMethod) {
            throw new Error(`Invalid method for signing: ${method}. Must be one of ${Object.values(api_1.SignTikTokUrlBodyMethodEnum).join(", ")}`);
          }
          const signResponse = await this.webSigner.webcastSign(url, method.toUpperCase(), this.axiosInstance.defaults.headers["User-Agent"], this.cookieJar.sessionId, this.cookieJar.ttTargetIdc);
          url = signResponse.response.signedUrl;
          headers ||= {};
          headers["User-Agent"] = signResponse.response.userAgent;
        }
        return this.axiosInstance.request({
          url,
          headers: headers ?? void 0,
          method,
          ...extraOptions
        });
      }
      /**
       * Get HTML from TikTok website
       *
       * @param path Path to the HTML page
       * @param options Additional request options
       */
      async getHtmlFromTikTokWebsite(path, options = {}) {
        const fetchResponse = await this.request({
          host: config_1.default.TIKTOK_HOST_WEB,
          path,
          responseType: "text",
          signRequest: false,
          ...options
        });
        return fetchResponse.data;
      }
      /**
       * Get deserialized object from Webcast API
       *
       * @param path Path to the API endpoint
       * @param params Query parameters to be sent with the request
       * @param schemaName Schema name for deserialization
       * @param signRequest Whether to sign the request or not
       * @param options Additional request options
       */
      async getDeserializedObjectFromWebcastApi(path, params, schemaName, signRequest = false, options = {}) {
        const fetchResponse = await this.request({
          host: config_1.default.TIKTOK_HOST_WEBCAST,
          path: "webcast/" + path,
          params,
          signRequest,
          responseType: "arraybuffer",
          ...options
        });
        return (0, utilities_1.deserializeMessage)(schemaName, fetchResponse.data);
      }
      async postJsonObjectToWebcastApi(path, params, data, signRequest = false, options = {}) {
        options.headers ||= {};
        options.headers["Content-Type"] = "application/json; charset=UTF-8";
        const fetchResponse = await this.request({
          host: config_1.default.TIKTOK_HOST_WEBCAST,
          path: "webcast/" + path,
          data,
          params,
          responseType: "json",
          signRequest,
          method: "POST",
          ...options
        });
        return fetchResponse.data;
      }
      /**
       * Get JSON object from Webcast API
       *
       * @param path Path to the API endpoint
       * @param params Query parameters to be sent with the request
       * @param signRequest Whether to sign the request or not
       * @param options Additional request options
       */
      async getJsonObjectFromWebcastApi(path, params, signRequest = false, options = {}) {
        options.headers = {};
        const fetchResponse = await this.request({
          host: config_1.default.TIKTOK_HOST_WEBCAST,
          path: "webcast/" + path,
          params,
          responseType: "json",
          signRequest,
          headers: {
            ...options.headers
          },
          ...options
        });
        return fetchResponse.data;
      }
      /**
       * Get JSON object from TikTok API
       *
       * @param path Path to the API endpoint
       * @param params Query parameters to be sent with the request
       * @param signRequest Whether to sign the request or not
       * @param options Additional request options
       */
      async getJsonObjectFromTikTokApi(path, params, signRequest = false, options = {}) {
        const fetchResponse = await this.request({
          host: config_1.default.TIKTOK_HOST_WEB,
          path,
          params,
          responseType: "json",
          signRequest,
          ...options
        });
        return fetchResponse.data;
      }
    };
    exports2.default = WebcastHttpClient;
  }
});

// node_modules/tiktok-live-connector/dist/lib/web/routes/fetch-room-info.js
var require_fetch_room_info = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/web/routes/fetch-room-info.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FetchRoomInfoRoute = void 0;
    var route_1 = require_route();
    var errors_1 = require_errors();
    var FetchRoomInfoRoute = class extends route_1.Route {
      async call(params) {
        const { roomId } = params || this.webClient;
        if (roomId == null) {
          throw new errors_1.MissingRoomIdError("Missing roomId. Please provide a roomId to the HTTP client.");
        }
        try {
          return await this.webClient.getJsonObjectFromWebcastApi("room/info/", { ...this.webClient.clientParams, roomId }, false);
        } catch (err) {
          throw new errors_1.InvalidResponseError(`Failed to fetch room info. ${err.message}`, err);
        }
      }
    };
    exports2.FetchRoomInfoRoute = FetchRoomInfoRoute;
  }
});

// node_modules/tiktok-live-connector/dist/lib/web/routes/fetch-room-id-euler.js
var require_fetch_room_id_euler = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/web/routes/fetch-room-id-euler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FetchRoomIdFromEulerRoute = void 0;
    var route_1 = require_route();
    var FetchRoomIdFromEulerRoute = class extends route_1.Route {
      async call({ uniqueId, options }) {
        const fetchResponse = await this.webClient.webSigner.webcast.retrieveRoomId(uniqueId, options);
        return fetchResponse.data;
      }
    };
    exports2.FetchRoomIdFromEulerRoute = FetchRoomIdFromEulerRoute;
  }
});

// node_modules/tiktok-live-connector/dist/lib/web/routes/fetch-room-info-api-live.js
var require_fetch_room_info_api_live = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/web/routes/fetch-room-info-api-live.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FetchRoomInfoFromApiLiveRoute = void 0;
    var route_1 = require_route();
    var errors_1 = require_errors();
    var FetchRoomInfoFromApiLiveRoute = class extends route_1.Route {
      async call({ uniqueId }) {
        const roomData = await this.webClient.getJsonObjectFromTikTokApi("api-live/user/room/", {
          ...this.webClient.clientParams,
          uniqueId,
          sourceType: "54"
        });
        if (roomData.statusCode) {
          throw new errors_1.InvalidResponseError(`API Error ${roomData.statusCode} (${roomData.message || "Unknown Error"})`, void 0);
        }
        if (!roomData?.data?.user?.roomId) {
          throw new errors_1.InvalidResponseError(`Invalid response from API: ${JSON.stringify(roomData)}`, void 0);
        }
        return roomData;
      }
    };
    exports2.FetchRoomInfoFromApiLiveRoute = FetchRoomInfoFromApiLiveRoute;
  }
});

// node_modules/tiktok-live-connector/dist/lib/web/routes/fetch-room-info-euler.js
var require_fetch_room_info_euler = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/web/routes/fetch-room-info-euler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FetchRoomInfoFromEulerRoute = void 0;
    var route_1 = require_route();
    var FetchRoomInfoFromEulerRoute = class extends route_1.Route {
      async call({ uniqueId, options }) {
        const fetchResponse = await this.webClient.webSigner.webcast.retrieveRoomInfo(uniqueId, options);
        return fetchResponse.data;
      }
    };
    exports2.FetchRoomInfoFromEulerRoute = FetchRoomInfoFromEulerRoute;
  }
});

// node_modules/tiktok-live-connector/dist/lib/web/routes/fetch-room-info-html.js
var require_fetch_room_info_html = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/web/routes/fetch-room-info-html.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FetchRoomInfoFromHtmlRoute = void 0;
    var route_1 = require_route();
    var SIGI_PATTERN = /<script id="SIGI_STATE" type="application\/json">(.*?)<\/script>/;
    var FetchRoomInfoFromHtmlRoute = class extends route_1.Route {
      async call({ uniqueId }) {
        const html = await this.webClient.getHtmlFromTikTokWebsite(`@${uniqueId}/live`);
        const match = html.match(SIGI_PATTERN);
        if (!match || match.length < 2) {
          throw new Error("Failed to extract the SIGI_STATE HTML tag, you might be blocked by TikTok.");
        }
        let sigiState;
        try {
          sigiState = JSON.parse(match[1]);
        } catch (e) {
          throw new Error("Failed to parse SIGI_STATE into JSON. Are you captcha-blocked by TikTok?");
        }
        const liveRoom = sigiState?.LiveRoom.liveRoomUserInfo;
        if (!liveRoom) {
          throw new Error("Failed to extract the LiveRoom object from SIGI_STATE.");
        }
        return liveRoom;
      }
    };
    exports2.FetchRoomInfoFromHtmlRoute = FetchRoomInfoFromHtmlRoute;
  }
});

// node_modules/@eulerstream/euler-api-sdk/dist/sdk/configuration.js
var require_configuration = __commonJS({
  "node_modules/@eulerstream/euler-api-sdk/dist/sdk/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Configuration = void 0;
    var Configuration = class {
      /**
       * parameter for apiKey security
       * @param name security name
       * @memberof Configuration
       */
      apiKey;
      /**
       * parameter for basic security
       *
       * @type {string}
       * @memberof Configuration
       */
      username;
      /**
       * parameter for basic security
       *
       * @type {string}
       * @memberof Configuration
       */
      password;
      /**
       * parameter for oauth2 security
       * @param name security name
       * @param scopes oauth2 scope
       * @memberof Configuration
       */
      accessToken;
      /**
       * override base path
       *
       * @type {string}
       * @memberof Configuration
       */
      basePath;
      /**
       * override server index
       *
       * @type {number}
       * @memberof Configuration
       */
      serverIndex;
      /**
       * base options for axios calls
       *
       * @type {any}
       * @memberof Configuration
       */
      baseOptions;
      /**
       * The FormData constructor that will be used to create multipart form data
       * requests. You can inject this here so that execution environments that
       * do not support the FormData class can still run the generated client.
       *
       * @type {new () => FormData}
       */
      formDataCtor;
      constructor(param = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.serverIndex = param.serverIndex;
        this.baseOptions = {
          ...param.baseOptions,
          headers: {
            ...param.baseOptions?.headers
          }
        };
        this.formDataCtor = param.formDataCtor;
      }
      /**
       * Check if the given MIME is a JSON MIME.
       * JSON MIME examples:
       *   application/json
       *   application/json; charset=UTF8
       *   APPLICATION/JSON
       *   application/vnd.company+json
       * @param mime - MIME (Multipurpose Internet Mail Extensions)
       * @return True if the given MIME is JSON, false otherwise.
       */
      isJsonMime(mime) {
        const jsonMime = new RegExp("^(application/json|[^;/ 	]+/[^;/ 	]+[+]json)[ 	]*(;.*)?$", "i");
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === "application/json-patch+json");
      }
    };
    exports2.Configuration = Configuration;
  }
});

// node_modules/@eulerstream/euler-api-sdk/dist/sdk/index.js
var require_sdk = __commonJS({
  "node_modules/@eulerstream/euler-api-sdk/dist/sdk/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_api(), exports2);
    __exportStar(require_configuration(), exports2);
  }
});

// node_modules/@eulerstream/euler-api-sdk/dist/utils.js
var require_utils = __commonJS({
  "node_modules/@eulerstream/euler-api-sdk/dist/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildConfig = void 0;
    function buildConfig(baseConfig) {
      const config = {
        ...{
          basePath: "https://tiktok.eulerstream.com",
          baseOptions: { validateStatus: () => true },
          isJsonMime: (mime) => mime.toLowerCase().includes("application/json")
        },
        ...baseConfig
      };
      if (!config.apiKey) {
        return config;
      }
      const apiKey2 = config.apiKey;
      delete config.apiKey;
      config.baseOptions.headers ||= {};
      config.baseOptions.headers["X-Api-Key"] = apiKey2;
      return config;
    }
    exports2.buildConfig = buildConfig;
  }
});

// node_modules/@eulerstream/euler-api-sdk/dist/index.js
var require_dist = __commonJS({
  "node_modules/@eulerstream/euler-api-sdk/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sdk_1 = require_sdk();
    var utils_1 = require_utils();
    __exportStar(require_sdk(), exports2);
    __exportStar(require_utils(), exports2);
    var EulerStreamApiClient = class {
      webcast;
      accounts;
      authentication;
      analytics;
      alerts;
      alertTargets;
      configuration;
      /**
       * EulerStream API Client
       *
       * Configuration
       *
       *
       * API Instances
       *
       * @param config The configuration for the API client
       */
      constructor(config = {}) {
        this.configuration = (0, utils_1.buildConfig)(config);
        this.webcast = new sdk_1.TikTokLIVEApi(this.configuration);
        this.accounts = new sdk_1.AccountsApi(this.configuration);
        this.authentication = new sdk_1.AuthenticationApi(this.configuration);
        this.analytics = new sdk_1.AnalyticsApi(this.configuration);
        this.alerts = new sdk_1.AlertsApi(this.configuration);
        this.alertTargets = new sdk_1.AlertTargetsApi(this.configuration);
      }
    };
    exports2.default = EulerStreamApiClient;
  }
});

// node_modules/tiktok-live-connector/dist/lib/web/routes/fetch-signed-websocket-euler.js
var require_fetch_signed_websocket_euler = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/web/routes/fetch-signed-websocket-euler.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FetchSignedWebSocketFromEulerRoute = void 0;
    var route_1 = require_route();
    var errors_1 = require_errors();
    var config_1 = __importDefault(require_config());
    var lib_1 = require_lib3();
    var euler_api_sdk_1 = require_dist();
    var FetchSignedWebSocketFromEulerRoute = class extends route_1.Route {
      async call({ roomId, uniqueId, sessionId, ttTargetIdc, useMobile }) {
        if (!roomId && !uniqueId) {
          throw new errors_1.FetchSignedWebSocketIdentityParameterError("Either roomId or uniqueId must be provided.");
        }
        if (roomId && uniqueId) {
          throw new errors_1.FetchSignedWebSocketIdentityParameterError("Both roomId and uniqueId cannot be provided at the same time.");
        }
        let resolvedSessionId = sessionId || this.webClient.cookieJar.sessionId;
        let resolvedTtTargetIdc = ttTargetIdc || this.webClient.cookieJar.ttTargetIdc;
        if (resolvedSessionId && !resolvedTtTargetIdc) {
          throw new errors_1.FetchSignedWebSocketIdentityParameterError("ttTargetIdc must be set when sessionId is provided.");
        }
        if (this.webClient.configuration.authenticateWs && resolvedSessionId) {
          const envHost = process.env.WHITELIST_AUTHENTICATED_SESSION_ID_HOST;
          const expectedHost = new URL(this.webClient.webSigner.configuration.basePath).host;
          if (!envHost) {
            throw new errors_1.AuthenticatedWebSocketConnectionError(`authenticate_websocket is true, but no whitelist host defined. Set the env var WHITELIST_AUTHENTICATED_SESSION_ID_HOST to proceed.`);
          }
          if (envHost !== expectedHost) {
            throw new errors_1.AuthenticatedWebSocketConnectionError(`The env var WHITELIST_AUTHENTICATED_SESSION_ID_HOST "${envHost}" does not match sign server host "${expectedHost}".`);
          }
        } else {
          resolvedSessionId = void 0;
          resolvedTtTargetIdc = void 0;
        }
        let response;
        try {
          response = await this.webClient.webSigner.webcast.fetchWebcastURL(
            "ttlive-node",
            roomId,
            uniqueId,
            this.webClient.clientParams?.cursor ?? void 0,
            resolvedSessionId,
            config_1.default.DEFAULT_HTTP_CLIENT_HEADERS["User-Agent"],
            resolvedTtTargetIdc,
            // With the latest version, we now send the im_enter_room payload, so clientEnter should be true
            true,
            void 0,
            useMobile ? euler_api_sdk_1.WebcastFetchPlatform.Mobile : euler_api_sdk_1.WebcastFetchPlatform.Web,
            {
              // NOTE: NEVER REMOVE THIS BECAUSE FUCKING AXIOS WILL END UP TRYING TO INTERPRET THE RESPONSE
              // AS UTF-8 DATA AND YOU WILL FUCKING HATE YOUR LIFE
              responseType: "arraybuffer"
            }
          );
        } catch (err) {
          throw new errors_1.SignAPIError(errors_1.ErrorReason.CONNECT_ERROR, void 0, void 0, "Failed to connect to sign server.", null, err);
        }
        if (response.status === 429) {
          const data = JSON.parse(Buffer.from(response.data).toString("utf-8"));
          const message = process.env.SIGN_SERVER_MESSAGE_DISABLED ? null : data?.message;
          const label = data?.limit_label ? `(${data.limit_label}) ` : "";
          throw new errors_1.SignatureRateLimitError(message, `${label}Too many connections started, try again later.`, response);
        }
        if (response.status === 402) {
          const data = JSON.parse(Buffer.from(response.data).toString("utf-8"));
          const message = process.env.SIGN_SERVER_MESSAGE_DISABLED ? null : data?.message;
          throw new errors_1.PremiumFeatureError(message, "Error fetching the signed TikTok WebSocket");
        }
        const logId = response.headers["X-Request-Id"];
        const agentId = response.headers["X-Agent-Id"];
        if (response.status !== 200) {
          let payload;
          try {
            payload = Buffer.from(response.data).toString("utf-8");
          } catch {
            payload = `"${response.statusText}"`;
          }
          throw new errors_1.SignAPIError(errors_1.ErrorReason.SIGN_NOT_200, logId, agentId, `Unexpected sign server status ${response.status}. Payload:
${payload}`);
        }
        if (!response.headers["x-set-tt-cookie"]) {
          throw new errors_1.SignAPIError(errors_1.ErrorReason.EMPTY_COOKIES, logId, agentId, "No cookies received from sign server.");
        }
        this.webClient.cookieJar.processSetCookieHeader(response.headers["x-set-tt-cookie"] || "");
        this.webClient.roomId = response.headers["x-room-id"] || this.webClient.roomId;
        return (0, lib_1.deserializeMessage)("ProtoMessageFetchResult", Buffer.from(response.data));
      }
    };
    exports2.FetchSignedWebSocketFromEulerRoute = FetchSignedWebSocketFromEulerRoute;
  }
});

// node_modules/tiktok-live-connector/dist/lib/web/routes/send-room-chat-euler.js
var require_send_room_chat_euler = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/web/routes/send-room-chat-euler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SendRoomChatFromEulerRoute = void 0;
    var route_1 = require_route();
    var types_1 = require_types();
    var SendRoomChatFromEulerRoute = class extends route_1.Route {
      async call({ roomId, content, sessionId, ttTargetIdc, options }) {
        const resolvedSessionId = sessionId || this.webClient.cookieJar.sessionId;
        const resolvedTtTargetIdc = ttTargetIdc || this.webClient.cookieJar.ttTargetIdc;
        if (resolvedSessionId && !resolvedTtTargetIdc) {
          throw new types_1.FetchSignedWebSocketIdentityParameterError("ttTargetIdc must be set when sessionId is provided.");
        }
        const fetchResponse = await this.webClient.webSigner.webcast.sendRoomChat({
          roomId,
          content,
          sessionId: resolvedSessionId,
          ttTargetIdc: resolvedTtTargetIdc
        }, options);
        switch (fetchResponse.status) {
          case 401:
          case 403:
            throw new types_1.PremiumFeatureError("Sending chats requires an API key & a paid plan, as it uses cloud managed services.", fetchResponse.data.message, JSON.stringify(fetchResponse.data));
          case 200:
            return fetchResponse.data;
          default:
            throw new Error(`Failed to send chat: ${fetchResponse?.data?.message || "Unknown error"}`);
        }
      }
    };
    exports2.SendRoomChatFromEulerRoute = SendRoomChatFromEulerRoute;
  }
});

// node_modules/tiktok-live-connector/dist/lib/web/routes/index.js
var require_routes = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/web/routes/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_fetch_room_info(), exports2);
    __exportStar(require_fetch_room_id_euler(), exports2);
    __exportStar(require_fetch_room_info_api_live(), exports2);
    __exportStar(require_fetch_room_info_euler(), exports2);
    __exportStar(require_fetch_room_info_html(), exports2);
    __exportStar(require_fetch_signed_websocket_euler(), exports2);
    __exportStar(require_send_room_chat_euler(), exports2);
  }
});

// node_modules/tiktok-live-connector/dist/lib/web/lib/tiktok-signer.js
var require_tiktok_signer = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/web/lib/tiktok-signer.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.EulerSigner = void 0;
    var errors_1 = require_errors();
    var euler_api_sdk_1 = __importDefault(require_dist());
    var lib_1 = require_lib3();
    var EulerSigner = class extends euler_api_sdk_1.default {
      constructor(config = {}) {
        super({ ...lib_1.SignConfig, ...config });
      }
      /**
       * Sign a URL using the TikTok signature provider
       *
       * @param url The URL to sign
       * @param method The HTTP method to use (GET, POST, etc.)
       * @param userAgent The user agent to sign with
       * @param sessionId The session ID to use (optional)
       * @param ttTargetIdc The target IDC to use (optional)
       */
      async webcastSign(url, method, userAgent, sessionId, ttTargetIdc) {
        const mustRemoveParams = ["X-Bogus", "X-Gnarly", "msToken"];
        let cleanUrl = typeof url === "string" ? url : url.toString();
        for (const param of mustRemoveParams) {
          cleanUrl = cleanUrl.replace(new RegExp(`([&?])${param}=[^&]*`, "g"), "$1");
          cleanUrl = cleanUrl.replace(/[&?]$/, "");
        }
        if (sessionId && !ttTargetIdc) {
          throw new Error("ttTargetIdc must be set when sessionId is provided.");
        }
        const response = await this.webcast.signWebcastUrl({
          url: cleanUrl,
          method,
          userAgent,
          sessionId,
          ttTargetIdc
        });
        if (response.status === 403) {
          throw new errors_1.PremiumFeatureError("You do not have permission from the signature provider to sign this URL.", response.data.message, JSON.stringify(response.data));
        }
        if (!response.data || Object.keys(response.data.response.tokens || {}).length < 1) {
          throw new errors_1.SignatureMissingTokensError("Failed to sign a request due to missing tokens in response!");
        }
        if (response.status !== 200) {
          throw new errors_1.SignatureMissingTokensError(`Failed to sign a request: ${response?.data?.message || "Unknown error"}`);
        }
        return response.data;
      }
    };
    exports2.EulerSigner = EulerSigner;
  }
});

// node_modules/tiktok-live-connector/dist/lib/web/lib/index.js
var require_lib = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/web/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_cookie_jar(), exports2);
    __exportStar(require_http_client(), exports2);
    __exportStar(require_tiktok_signer(), exports2);
  }
});

// node_modules/tiktok-live-connector/dist/lib/web/index.js
var require_web = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/web/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TikTokWebClient = void 0;
    var http_client_1 = __importDefault(require_http_client());
    var routes_1 = require_routes();
    var fetch_room_info_html_1 = require_fetch_room_info_html();
    var fetch_signed_websocket_euler_1 = require_fetch_signed_websocket_euler();
    var fetch_room_id_euler_1 = require_fetch_room_id_euler();
    var fetch_room_info_euler_1 = require_fetch_room_info_euler();
    var fetch_room_info_api_live_1 = require_fetch_room_info_api_live();
    __exportStar(require_routes(), exports2);
    __exportStar(require_lib(), exports2);
    var TikTokWebClient = class extends http_client_1.default {
      // TikTok-based routes
      fetchRoomInfo;
      fetchRoomInfoFromApiLive;
      fetchRoomInfoFromHtml;
      // Euler-based routes
      fetchSignedWebSocketFromEuler;
      fetchRoomIdFromEuler;
      fetchRoomInfoFromEuler;
      sendRoomChatFromEuler;
      constructor(...params) {
        super(...params);
        this.fetchRoomInfo = new routes_1.FetchRoomInfoRoute(this);
        this.fetchRoomInfoFromHtml = new fetch_room_info_html_1.FetchRoomInfoFromHtmlRoute(this);
        this.fetchRoomInfoFromApiLive = new fetch_room_info_api_live_1.FetchRoomInfoFromApiLiveRoute(this);
        this.fetchSignedWebSocketFromEuler = new fetch_signed_websocket_euler_1.FetchSignedWebSocketFromEulerRoute(this);
        this.fetchRoomIdFromEuler = new fetch_room_id_euler_1.FetchRoomIdFromEulerRoute(this);
        this.fetchRoomInfoFromEuler = new fetch_room_info_euler_1.FetchRoomInfoFromEulerRoute(this);
        this.sendRoomChatFromEuler = new routes_1.SendRoomChatFromEulerRoute(this);
      }
    };
    exports2.TikTokWebClient = TikTokWebClient;
  }
});

// node_modules/tiktok-live-connector/dist/lib/client.js
var require_client2 = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/client.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TikTokLiveConnection = void 0;
    var errors_1 = require_errors();
    var node_events_1 = require("node:events");
    var ws_client_1 = __importDefault(require_ws_client());
    var config_1 = __importDefault(require_config());
    var utilities_1 = require_utilities();
    var web_1 = require_web();
    var events_1 = require_events();
    var types_1 = require_types();
    var TikTokLiveConnection = class extends node_events_1.EventEmitter {
      uniqueId;
      signer;
      // Public properties
      webClient;
      wsClient = null;
      // Protected properties
      _roomInfo = null;
      _availableGifts = null;
      _connectState = events_1.ConnectState.DISCONNECTED;
      options;
      /**
       * Create a new TikTokLiveConnection instance
       * @param {string} uniqueId TikTok username (from URL)
       * @param {object} [options] Connection options
       * @param {boolean} [options[].authenticateWs=false] Authenticate the WebSocket connection using the session ID from the "sessionid" cookie
       * @param {boolean} [options[].processInitialData=true] Process the initital data which includes messages of the last minutes
       * @param {boolean} [options[].fetchRoomInfoOnConnect=false] Fetch the room info (room status, streamer info, etc.) on connect (will be returned when calling connect())
       * @param {boolean} [options[].enableExtendedGiftInfo=false] Enable this option to get extended information on 'gift' events like gift name and cost
       * @param {boolean} [options[].enableRequestPolling=true] Use request polling if no WebSocket upgrade is offered. If `false` an exception will be thrown if TikTok does not offer a WebSocket upgrade.
       * @param {number} [options[].requestPollingIntervalMs=1000] Request polling interval if WebSocket is not used
       * @param {string} [options[].sessionId=null] The session ID from the "sessionid" cookie is required if you want to send automated messages in the chat.
       * @param {object} [options[].webClientParams={}] Custom client params for Webcast API
       * @param {object} [options[].webClientHeaders={}] Custom request headers for axios
       * @param {object} [options[].websocketHeaders={}] Custom request headers for websocket.client
       * @param {object} [options[].webClientOptions={}] Custom request options for axios. Here you can specify an `httpsAgent` to use a proxy and a `timeout` value for example.
       * @param {object} [options[].websocketOptions={}] Custom request options for websocket.client. Here you can specify an `agent` to use a proxy and a `timeout` value for example.
       * @param {boolean} [options[].connectWithUniqueId=false] Connect to the live stream using the unique ID instead of the room ID. If `true`, the room ID will be fetched from the TikTok API.
       * @param {boolean} [options[].logFetchFallbackErrors=false] Log errors when falling back to the API or Euler source
       * @param {function} [options[].signedWebSocketProvider] Custom function to fetch the signed WebSocket URL. If not specified, the default function will be used.
       * @param {EulerSigner} [signer] TikTok Signer instance. If not provided, a new instance will be created using the provided options
       */
      constructor(uniqueId, options, signer) {
        super();
        this.uniqueId = uniqueId;
        this.signer = signer;
        this.uniqueId = (0, utilities_1.validateAndNormalizeUniqueId)(uniqueId);
        this.options = {
          connectWithUniqueId: false,
          processInitialData: true,
          fetchRoomInfoOnConnect: true,
          enableExtendedGiftInfo: false,
          enableRequestPolling: true,
          requestPollingIntervalMs: 1e3,
          sessionId: null,
          ttTargetIdc: null,
          signApiKey: null,
          disableEulerFallbacks: false,
          // Override Http client params
          webClientParams: {},
          webClientHeaders: {},
          webClientOptions: {},
          // Override WebSocket params
          wsClientHeaders: {},
          wsClientOptions: {},
          wsClientParams: {},
          authenticateWs: false,
          signedWebSocketProvider: void 0,
          ...options
        };
        this.webClient = new web_1.TikTokWebClient({
          customHeaders: this.options?.webClientHeaders || {},
          axiosOptions: this.options?.webClientOptions,
          clientParams: this.options?.webClientParams || {},
          authenticateWs: this.options?.authenticateWs || false,
          signApiKey: this.options?.signApiKey ?? void 0
        }, signer);
        this.webClient.cookieJar.setSession(this.options.sessionId, this.options.ttTargetIdc);
        this.setDisconnected();
      }
      /**
       * Set the connection state to disconnected
       * @protected
       */
      setDisconnected() {
        this._connectState = events_1.ConnectState.DISCONNECTED;
        this._roomInfo = null;
        this.clientParams.cursor = "";
        this.clientParams.room_id = "";
        this.clientParams.internal_ext = "";
      }
      /**
       * Get the current Room Info
       */
      get roomInfo() {
        return this._roomInfo;
      }
      /**
       * Get the available gifts
       */
      get availableGifts() {
        return this._availableGifts;
      }
      /**
       * Get the current connection state
       */
      get isConnecting() {
        return this._connectState === events_1.ConnectState.CONNECTING;
      }
      /**
       * Check if the connection is established
       */
      get isConnected() {
        return this._connectState === events_1.ConnectState.CONNECTED;
      }
      /**
       * Get the current client parameters
       */
      get clientParams() {
        return this.webClient.clientParams;
      }
      /**
       * Get the current room ID
       */
      get roomId() {
        return this.webClient.roomId;
      }
      /**
       * Get the current connection state including the cached room info and all available gifts
       * (if `enableExtendedGiftInfo` option enabled)
       */
      get state() {
        return {
          isConnected: this.isConnected,
          roomId: this.roomId,
          roomInfo: this.roomInfo,
          availableGifts: this.availableGifts
        };
      }
      /**
       * Connects to the live stream of the specified streamer
       * @param roomId Room ID to connect to. If not specified, the room ID will be retrieved from the TikTok API
       * @returns The current connection state
       */
      async connect(roomId) {
        switch (this._connectState) {
          case events_1.ConnectState.CONNECTED:
            throw new errors_1.AlreadyConnectedError("Already connected!");
          case events_1.ConnectState.CONNECTING:
            throw new errors_1.AlreadyConnectingError("Already connecting!");
          default:
          case events_1.ConnectState.DISCONNECTED:
            try {
              this._connectState = events_1.ConnectState.CONNECTING;
              await this._connect(roomId);
              this._connectState = events_1.ConnectState.CONNECTED;
              this.emit(events_1.ControlEvent.CONNECTED, this.state);
              return this.state;
            } catch (err) {
              this._connectState = events_1.ConnectState.DISCONNECTED;
              this.handleError(err, "Error while connecting");
              throw err;
            }
        }
      }
      /**
       * Connects to the live stream of the specified streamer
       *
       * @param roomId Room ID to connect to. If not specified, the room ID will be retrieved from the TikTok API
       * @protected
       */
      async _connect(roomId) {
        if (!this.options.connectWithUniqueId || this.options.fetchRoomInfoOnConnect || this.options.enableExtendedGiftInfo) {
          this.clientParams.room_id = roomId || this.clientParams.room_id || await this.fetchRoomId();
        }
        if (this.options?.fetchRoomInfoOnConnect) {
          this._roomInfo = await this.fetchRoomInfo();
          if (this._roomInfo.data.status === 4) {
            throw new errors_1.UserOfflineError("The requested user isn't online :(");
          }
        }
        if (this.options?.enableExtendedGiftInfo) {
          this._availableGifts = await this.fetchAvailableGifts();
        }
        const protoMessageFetchResult = await (this.options.signedWebSocketProvider || this.webClient.fetchSignedWebSocketFromEuler)({
          roomId: roomId || !this.options.connectWithUniqueId ? this.roomId : void 0,
          uniqueId: this.options.connectWithUniqueId ? this.uniqueId : void 0,
          sessionId: this.options.authenticateWs ? this.options.sessionId : void 0,
          ttTargetIdc: this.options.authenticateWs ? this.options.ttTargetIdc : void 0,
          useMobile: this.options.useMobile
        });
        if (this.options?.processInitialData) {
          await this.processProtoMessageFetchResult(protoMessageFetchResult);
        }
        if (!protoMessageFetchResult.cursor) {
          throw new errors_1.InvalidResponseError("Missing cursor in initial fetch response.");
        }
        this.clientParams.cursor = protoMessageFetchResult.cursor;
        this.clientParams.internal_ext = protoMessageFetchResult.internalExt;
        const wsParams = {
          compress: "gzip",
          room_id: this.roomId,
          internal_ext: protoMessageFetchResult.internalExt,
          cursor: protoMessageFetchResult.cursor
        };
        for (const [key, value] of Object.entries(protoMessageFetchResult.wsParams || [])) {
          if (value)
            wsParams[key] = value;
        }
        this.wsClient = await this.setupWebsocket(protoMessageFetchResult.wsUrl, wsParams);
        this.wsClient.switchRooms(this.roomId);
        this.emit(events_1.ControlEvent.WEBSOCKET_CONNECTED, this.wsClient);
      }
      /**
       * Disconnects the connection to the live stream
       */
      async disconnect() {
        if (this.isConnected) {
          this.wsClient?.close();
        }
      }
      /**
       * Fetch the room ID from the TikTok API
       * @param uniqueId Optional unique ID to use instead of the current one
       */
      async fetchRoomId(uniqueId) {
        let errors = [];
        uniqueId ||= this.uniqueId;
        try {
          const roomInfo = await this.webClient.fetchRoomInfoFromHtml({ uniqueId });
          const roomId = roomInfo.user.roomId;
          if (!roomId)
            throw new Error("Failed to extract Room ID from HTML.");
          return roomId;
        } catch (ex) {
          this.handleError(ex, "Failed to retrieve Room ID from main page, falling back to API source...");
          errors.push(ex);
        }
        try {
          const roomData = await this.webClient.fetchRoomInfoFromApiLive({ uniqueId });
          const roomId = roomData?.data?.user?.roomId;
          if (!roomId)
            throw new Error("Failed to extract Room ID from API.");
          return roomId;
        } catch (ex) {
          this.handleError(ex, "Failed to retrieve Room ID from API source, falling back to Euler source...");
          errors.push(ex);
        }
        if (!this.options.disableEulerFallbacks) {
          try {
            const response = await this.webClient.fetchRoomIdFromEuler({ uniqueId });
            if ([403, 402, 401].includes(response.code)) {
              throw new Error("Failed to retrieve Room ID from Euler Stream, which was made as a last resort due to the previous methods failing. This happened due to a >>lack of permission<< for you to use Euler Stream's (https://www.eulerstream.com) fallback method. If you do not want to use Euler Stream, disable this fallback method by setting the 'disableEulerFallbacks' option to 'true'.");
            }
            if (!response.ok)
              throw new Error(`Failed to retrieve Room ID from Euler due to an error: ${response.message}`);
            if (!response.room_id)
              throw new Error("Failed to extract Room ID from Euler.");
            return response.room_id;
          } catch (err) {
            this.handleError(err, "Failed to retrieve Room ID from Euler source, no more sources available...");
            errors.push(err);
          }
        }
        const errMsg = "Failed to retrieve Room ID from all sources.";
        const failErr = new errors_1.FetchIsLiveError(errors, errMsg);
        this.handleError(failErr, errMsg);
        throw failErr;
      }
      async fetchIsLive() {
        const errors = [];
        const isOnline = (status) => status !== 4;
        try {
          const roomInfo = await this.webClient.fetchRoomInfoFromHtml({ uniqueId: this.uniqueId });
          if (roomInfo?.liveRoomUserInfo?.liveRoom?.status === void 0)
            throw new Error("Failed to extract status from HTML.");
          return isOnline(roomInfo?.liveRoomUserInfo?.liveRoom?.status);
        } catch (ex) {
          this.handleError(ex, "Failed to retrieve room info for live status from main page, falling back to API source...");
          errors.push(ex);
        }
        try {
          const roomData = await this.webClient.fetchRoomInfoFromApiLive({ uniqueId: this.uniqueId });
          if (roomData?.data?.liveRoom?.status === void 0)
            throw new Error("Failed to extract status from API.");
          return isOnline(roomData?.data?.liveRoom?.status);
        } catch (err) {
          this.handleError(err, "Failed to retrieve room info for live status from API source, falling back to Euler source...");
          errors.push(err);
        }
        if (!this.options.disableEulerFallbacks) {
          try {
            const roomData = await this.webClient.fetchRoomIdFromEuler({ uniqueId: this.uniqueId });
            if (roomData.code !== 200)
              throw new Error("Failed to extract status from Euler.");
            return roomData.is_live;
          } catch (err) {
            this.handleError(err, "Failed to retrieve room info for live status from Euler source, no more sources available...");
            errors.push(err);
          }
        }
        const errMsg = "Failed to retrieve live status rom all sources.";
        const failErr = new errors_1.FetchIsLiveError(errors, errMsg);
        this.handleError(failErr, errMsg);
        throw failErr;
      }
      /**
       * Wait until the streamer is live
       * @param seconds Number of seconds to wait before checking if the streamer is live again
       */
      async waitUntilLive(seconds = 60) {
        seconds = Math.max(30, seconds);
        return new Promise(async (resolve) => {
          const fetchIsLive = async () => {
            const isLive = await this.fetchIsLive();
            if (isLive) {
              clearInterval(interval);
              resolve();
            }
          };
          const interval = setInterval(async () => fetchIsLive(), seconds * 1e3);
          await fetchIsLive();
        });
      }
      /**
       * Get the current room info (including streamer info, room status and statistics)
       * @returns Promise that will be resolved when the room info has been retrieved from the API
       */
      async fetchRoomInfo() {
        if (!this.webClient.roomId)
          await this.fetchRoomId();
        this._roomInfo = await this.webClient.fetchRoomInfo();
        return this._roomInfo;
      }
      /**
       * Get the available gifts in the current room
       * @returns Promise that will be resolved when the available gifts have been retrieved from the API
       */
      async fetchAvailableGifts() {
        try {
          let response = await this.webClient.getJsonObjectFromWebcastApi("gift/list/", this.clientParams);
          return response.data.gifts;
        } catch (err) {
          throw new errors_1.InvalidResponseError(`Failed to fetch available gifts. ${err.message}`, err);
        }
      }
      /**
       * Send a message to a TikTok LIVE Room
       *
       * @param content Message content to send to the stream
       * @param options Optional parameters for the message (incl. parameter overrides)
       */
      async sendMessage(content, options) {
        const roomId = options?.roomId || this.roomId;
        if (!roomId) {
          throw new Error("Room ID is required to send a message.");
        }
        const sessionId = options?.sessionId || this.webClient.cookieJar.sessionId;
        if (!sessionId) {
          throw new Error("Session ID is required to send a message.");
        }
        const ttTargetIdc = options?.ttTargetIdc || this.webClient.cookieJar.ttTargetIdc;
        if (!ttTargetIdc) {
          throw new Error("ttTargetIdc is required to send a message.");
        }
        return this.webClient.sendRoomChatFromEuler({
          content,
          roomId,
          sessionId,
          ttTargetIdc
        });
      }
      /**
       * Set up the WebSocket connection
       *
       * @param wsUrl WebSocket URL
       * @param wsParams WebSocket parameters
       * @returns Promise that will be resolved when the WebSocket connection is established
       * @protected
       */
      async setupWebsocket(wsUrl, wsParams) {
        return new Promise((resolve, reject) => {
          const wsClient = new ws_client_1.default(wsUrl, this.webClient.cookieJar, { ...config_1.default.DEFAULT_WS_CLIENT_PARAMS, ...this.options.wsClientParams, ...wsParams }, { ...config_1.default.DEFAULT_WS_CLIENT_HEADERS, ...this.options?.wsClientHeaders }, this.options?.wsClientOptions);
          wsClient.on("open", () => {
            clearTimeout(connectTimeout);
            wsClient.on("error", (e) => this.handleError(e, "WebSocket Error"));
            wsClient.on("close", (code, reason) => {
              this.setDisconnected();
              this.emit(events_1.ControlEvent.DISCONNECTED, { code, reason: reason?.toString() });
            });
            resolve(wsClient);
          });
          wsClient.on("error", (err) => reject(`Websocket connection failed, ${err}`));
          wsClient.on("protoMessageFetchResult", this.processProtoMessageFetchResult.bind(this));
          wsClient.on("imEnteredRoom", (data) => this.emit(events_1.ControlEvent.ENTER_ROOM, data));
          wsClient.on("webSocketData", (data) => this.emit(events_1.ControlEvent.WEBSOCKET_DATA, data));
          wsClient.on("messageDecodingFailed", (err) => this.handleError(err, "Websocket message decoding failed"));
          const connectTimeout = setTimeout(() => reject("Websocket not responding"), 2e4);
        });
      }
      async processProtoMessageFetchResult(protoMessageFetchResult) {
        for (const message of protoMessageFetchResult.messages) {
          if (!message.decodedData) {
            continue;
          }
          this.emit(events_1.ControlEvent.DECODED_DATA, message.type, message.decodedData, message.payload);
          try {
            await this.processDecodedData(message.decodedData);
          } catch (ex) {
            this.handleError(ex, "Failed to process decoded data");
          }
        }
      }
      async processDecodedData({ data, type }) {
        switch (type) {
          case "WebcastSocialMessage":
            if (data.common.displayText.displayType?.includes("follow")) {
              return this.emit(events_1.WebcastEvent.FOLLOW, data);
            }
            if (data.common.displayText.displayType?.includes("share")) {
              return this.emit(events_1.WebcastEvent.SHARE, data);
            }
            return this.emit(events_1.WebcastEvent.SOCIAL, data);
          case "WebcastControlMessage":
            this.emit(events_1.WebcastEvent.CONTROL_MESSAGE, data);
            if (data.action === types_1.ControlAction.CONTROL_ACTION_STREAM_ENDED || data.action === types_1.ControlAction.CONTROL_ACTION_STREAM_SUSPENDED) {
              this.emit(events_1.WebcastEvent.STREAM_END, { action: data.action });
              await this.disconnect();
            }
            return;
          case "WebcastGiftMessage":
            if (Array.isArray(this.availableGifts) && data.giftId) {
              data.extendedGiftInfo = this.availableGifts.find((x) => x.id === data.giftId);
            }
            return this.emit(events_1.WebcastEvent.GIFT, data);
          case "WebcastBarrageMessage":
            if (data.content?.displayType?.includes("ttlive_superFan")) {
              this.emit(events_1.WebcastEvent.SUPER_FAN, data);
            }
            return this.emit(events_1.WebcastEvent.BARRAGE, data);
          default:
            const basicEvent = events_1.WebcastEventMap[type];
            return basicEvent && this.emit(basicEvent, data);
        }
      }
      /**
       * Handle the error event
       *
       * @param exception Exception object
       * @param info Additional information about the error
       * @protected
       */
      handleError(exception, info) {
        if (this.listenerCount(events_1.ControlEvent.ERROR) < 1) {
          return;
        }
        this.emit(events_1.ControlEvent.ERROR, { info, exception });
      }
    };
    exports2.TikTokLiveConnection = TikTokLiveConnection;
  }
});

// node_modules/tiktok-live-connector/dist/lib/ws/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/ws/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_ws_client(), exports2);
  }
});

// node_modules/tiktok-live-connector/dist/lib/ws/index.js
var require_ws2 = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/ws/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_lib2(), exports2);
  }
});

// node_modules/tiktok-live-connector/dist/lib/_legacy/data-converter.js
var require_data_converter = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/_legacy/data-converter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getPreferredPictureFormat = exports2.mapBadges = exports2.getTopViewerAttributes = exports2.getEventAttributes = exports2.simplifyObject = void 0;
    function simplifyObject(type, originalObject) {
      const simplify = (fn) => fn(originalObject);
      if (originalObject.user) {
        originalObject = simplify((webcastObject) => {
          Object.assign(webcastObject, getUserAttributes(webcastObject.user));
          delete webcastObject.user;
          return webcastObject;
        });
      }
      if (originalObject.common) {
        originalObject = simplify((webcastObject) => {
          Object.assign(webcastObject, webcastObject.common.displayText);
          delete webcastObject.common.displayText;
          Object.assign(webcastObject, webcastObject.common);
          delete webcastObject.common;
          return webcastObject;
        });
      }
      switch (type) {
        case "WebcastQuestionNewMessage": {
          originalObject = simplify((webcastObject) => {
            Object.assign(webcastObject, webcastObject.details);
            delete webcastObject.details;
            return webcastObject;
          });
          break;
        }
        case "WebcastRoomUserSeqMessage": {
          originalObject = simplify((webcastObject) => {
            webcastObject.topViewers = getTopViewerAttributes(webcastObject.ranksList);
            delete webcastObject.ranksList;
            return webcastObject;
          });
          break;
        }
        case "WebcastLinkMicBattle": {
          originalObject = simplify((webcastObject) => {
            const battleUsers = [];
            Object.values(webcastObject.anchorInfo).forEach((anchor) => {
              if (anchor.user) {
                battleUsers.push(getUserAttributes(anchor.user));
              }
            });
            webcastObject.battleUsers = battleUsers;
            return webcastObject;
          });
          break;
        }
        case "WebcastGiftMessage": {
          originalObject = simplify((webcastObject) => {
            webcastObject.repeatEnd = !!webcastObject.repeatEnd;
            webcastObject.gift = {
              gift_id: webcastObject.giftId,
              repeat_count: webcastObject.repeatCount,
              repeat_end: webcastObject.repeatEnd ? 1 : 0,
              gift_type: webcastObject.giftDetails?.giftType
            };
            if (webcastObject.giftDetails?.giftImage?.url?.length) {
              webcastObject.giftPictureUrl = webcastObject.giftDetails.giftImage.url[0];
            }
            if (webcastObject.giftDetails) {
              Object.assign(webcastObject, webcastObject.giftDetails);
              delete webcastObject.giftDetails;
            }
            if (webcastObject.giftExtra) {
              if (webcastObject.giftExtra.toUserId) {
                webcastObject.receiverUserId = webcastObject.giftExtra.toUserId;
                delete webcastObject.giftExtra.toUserId;
              }
              if (webcastObject.giftExtra.sendGiftSendMessageSuccessMs) {
                webcastObject.timestamp = parseInt(webcastObject.giftExtra.sendGiftSendMessageSuccessMs);
                delete webcastObject.giftExtra.sendGiftSendMessageSuccessMs;
              }
              Object.assign(webcastObject, webcastObject.giftExtra);
              delete webcastObject.giftExtra;
            }
            if (webcastObject.monitorExtra?.indexOf("{") === 0) {
              try {
                webcastObject.monitorExtra = JSON.parse(webcastObject.monitorExtra);
              } catch (err) {
                console.warn("Failed to parse monitorExtra JSON:", err);
              }
            }
            return webcastObject;
          });
          break;
        }
        case "WebcastChatMessage": {
          originalObject = simplify((webcastObject) => {
            webcastObject.emotes = webcastObject.emotes.map((emote) => ({
              emoteId: emote.emote.emoteId,
              emoteImageUrl: emote.emote.image.imageUrl,
              placeInComment: emote.placeInComment
            }));
            return webcastObject;
          });
          break;
        }
        case "WebcastEmoteChatMessage": {
          originalObject = simplify((webcastObject) => {
            webcastObject.emotes = webcastObject.emoteList.map((emote) => ({
              emoteId: emote.emoteId,
              emoteImageUrl: emote.image.url[0]
            }));
            return webcastObject;
          });
          break;
        }
      }
      return originalObject;
    }
    exports2.simplifyObject = simplifyObject;
    function getUserAttributes(webcastUser) {
      webcastUser ||= {};
      const userAttributes = {
        userId: webcastUser.userId?.toString(),
        secUid: webcastUser.secUid?.toString(),
        uniqueId: webcastUser.uniqueId !== "" ? webcastUser.uniqueId : void 0,
        nickname: webcastUser.nickname !== "" ? webcastUser.nickname : void 0,
        profilePictureUrl: getPreferredPictureFormat(webcastUser.profilePicture?.url),
        followRole: webcastUser.followInfo?.followStatus,
        userBadges: mapBadges(webcastUser.badges),
        userSceneTypes: webcastUser.badges?.map((x) => x?.badgeScene || 0),
        userDetails: {
          createTime: webcastUser.createTime?.toString(),
          bioDescription: webcastUser.bioDescription,
          profilePictureUrls: webcastUser.profilePicture?.url
        }
      };
      if (webcastUser.followInfo) {
        userAttributes.followInfo = {
          followingCount: webcastUser.followInfo.followingCount,
          followerCount: webcastUser.followInfo.followerCount,
          followStatus: webcastUser.followInfo.followStatus,
          pushStatus: webcastUser.followInfo.pushStatus
        };
      }
      userAttributes.isModerator = userAttributes.userBadges.some((x) => x.type && x.type.toLowerCase().includes("moderator") || x.badgeSceneType === 1);
      userAttributes.isNewGifter = userAttributes.userBadges.some((x) => x.type && x.type.toLowerCase().includes("live_ng_"));
      userAttributes.isSubscriber = userAttributes.userBadges.some((x) => x.url && x.url.toLowerCase().includes("/sub_") || x.badgeSceneType === 4 || x.badgeSceneType === 7);
      userAttributes.topGifterRank = userAttributes.userBadges.find((x) => x.url && x.url.includes("/ranklist_top_gifter_"))?.url.match(/(?<=ranklist_top_gifter_)(\d+)(?=.png)/g)?.map(Number)[0] ?? null;
      userAttributes.gifterLevel = userAttributes.userBadges.find((x) => x.badgeSceneType === 8)?.level || 0;
      userAttributes.teamMemberLevel = userAttributes.userBadges.find((x) => x.badgeSceneType === 10)?.level || 0;
      return userAttributes;
    }
    function getEventAttributes(event) {
      if (event.msgId)
        event.msgId = event.msgId.toString();
      if (event.createTime)
        event.createTime = event.createTime.toString();
      return event;
    }
    exports2.getEventAttributes = getEventAttributes;
    function getTopViewerAttributes(topViewers) {
      return topViewers.map((viewer) => {
        return {
          user: viewer.user ? getUserAttributes(viewer.user) : null,
          coinCount: viewer.coinCount ? parseInt(viewer.coinCount) : 0
        };
      });
    }
    exports2.getTopViewerAttributes = getTopViewerAttributes;
    function mapBadges(badges) {
      let simplifiedBadges = [];
      if (Array.isArray(badges)) {
        badges.forEach((innerBadges) => {
          let badgeSceneType = innerBadges.badgeSceneType;
          if (Array.isArray(innerBadges.badges)) {
            innerBadges.badges.forEach((badge) => {
              simplifiedBadges.push(Object.assign({ badgeSceneType }, badge));
            });
          }
          if (Array.isArray(innerBadges.imageBadges)) {
            innerBadges.imageBadges.forEach((badge) => {
              if (badge && badge.image && badge.image.url) {
                simplifiedBadges.push({
                  type: "image",
                  badgeSceneType,
                  displayType: badge.displayType,
                  url: badge.image.url
                });
              }
            });
          }
          if (innerBadges.privilegeLogExtra?.level && innerBadges.privilegeLogExtra?.level !== "0") {
            simplifiedBadges.push({
              type: "privilege",
              privilegeId: innerBadges.privilegeLogExtra.privilegeId,
              level: parseInt(innerBadges.privilegeLogExtra.level),
              badgeSceneType: innerBadges.badgeSceneType
            });
          }
        });
      }
      return simplifiedBadges;
    }
    exports2.mapBadges = mapBadges;
    function getPreferredPictureFormat(pictureUrls) {
      if (!pictureUrls || !Array.isArray(pictureUrls) || !pictureUrls.length) {
        return null;
      }
      return pictureUrls.find((x) => x.includes("100x100") && x.includes(".webp")) || pictureUrls.find((x) => x.includes("100x100") && x.includes(".jpeg")) || pictureUrls.find((x) => !x.includes("shrink")) || pictureUrls[0];
    }
    exports2.getPreferredPictureFormat = getPreferredPictureFormat;
  }
});

// node_modules/tiktok-live-connector/dist/lib/_legacy/legacy-client.js
var require_legacy_client = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/_legacy/legacy-client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebcastPushConnection = void 0;
    var data_converter_1 = require_data_converter();
    var lib_1 = require_lib3();
    var events_1 = require_events();
    var WebcastPushConnection2 = class extends lib_1.TikTokLiveConnection {
      async processProtoMessageFetchResult(fetchResult) {
        fetchResult.messages.forEach((message) => {
          this.emit(events_1.ControlEvent.RAW_DATA, message.type, message.payload);
        });
        fetchResult.messages.forEach((message) => {
          let simplifiedObj = (0, data_converter_1.simplifyObject)(message.type, message.decodedData?.data || {});
          this.emit(events_1.ControlEvent.DECODED_DATA, message.type, simplifiedObj, message.payload);
          switch (message.type) {
            case "WebcastControlMessage":
              const action = message.decodedData.data.action;
              if ([3, 4].includes(action)) {
                this.emit(events_1.WebcastEvent.STREAM_END, { action });
                this.disconnect();
              }
              break;
            case "WebcastRoomUserSeqMessage":
              this.emit(events_1.WebcastEvent.ROOM_USER, simplifiedObj);
              break;
            case "WebcastChatMessage":
              this.emit(events_1.WebcastEvent.CHAT, simplifiedObj);
              break;
            case "WebcastMemberMessage":
              this.emit(events_1.WebcastEvent.MEMBER, simplifiedObj);
              break;
            case "WebcastGiftMessage":
              if (Array.isArray(this.availableGifts) && simplifiedObj.giftId) {
                simplifiedObj.extendedGiftInfo = this.availableGifts.find((x) => x.id === simplifiedObj.giftId);
              }
              this.emit(events_1.WebcastEvent.GIFT, simplifiedObj);
              break;
            case "WebcastSocialMessage":
              this.emit(events_1.WebcastEvent.SOCIAL, simplifiedObj);
              if (simplifiedObj.displayType?.includes("follow")) {
                this.emit(events_1.WebcastEvent.FOLLOW, simplifiedObj);
              }
              if (simplifiedObj.displayType?.includes("share")) {
                this.emit(events_1.WebcastEvent.SHARE, simplifiedObj);
              }
              break;
            case "WebcastLikeMessage":
              this.emit(events_1.WebcastEvent.LIKE, simplifiedObj);
              break;
            case "WebcastQuestionNewMessage":
              this.emit(events_1.WebcastEvent.QUESTION_NEW, simplifiedObj);
              break;
            case "WebcastLinkMicBattle":
              this.emit(events_1.WebcastEvent.LINK_MIC_BATTLE, simplifiedObj);
              break;
            case "WebcastLinkMicArmies":
              this.emit(events_1.WebcastEvent.LINK_MIC_ARMIES, simplifiedObj);
              break;
            case "WebcastLiveIntroMessage":
              this.emit(events_1.WebcastEvent.LIVE_INTRO, simplifiedObj);
              break;
            case "WebcastEmoteChatMessage":
              this.emit(events_1.WebcastEvent.EMOTE, simplifiedObj);
              break;
            case "WebcastEnvelopeMessage":
              this.emit(events_1.WebcastEvent.ENVELOPE, simplifiedObj);
              break;
          }
        });
      }
    };
    exports2.WebcastPushConnection = WebcastPushConnection2;
  }
});

// node_modules/tiktok-live-connector/dist/lib/_legacy/index.js
var require_legacy = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/_legacy/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_data_converter(), exports2);
    __exportStar(require_legacy_client(), exports2);
  }
});

// node_modules/tiktok-live-connector/dist/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/tiktok-live-connector/dist/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_client2(), exports2);
    __exportStar(require_utilities(), exports2);
    __exportStar(require_web(), exports2);
    __exportStar(require_ws2(), exports2);
    __exportStar(require_legacy(), exports2);
    __exportStar(require_config(), exports2);
  }
});

// node_modules/tiktok-live-connector/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/tiktok-live-connector/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_lib3(), exports2);
    __exportStar(require_types(), exports2);
    __exportStar(require_version(), exports2);
  }
});

// server.js
var { WebcastPushConnection, SignConfig } = require_dist2();
var WebSocket = require_ws();
var apiKey = process.env.EULER_API_KEY || process.argv[3] || "";
if (apiKey) {
  SignConfig.apiKey = apiKey;
  console.log("[Server] \u5DF2\u8A2D\u5B9A Eulerstream API Key");
} else {
  console.log("[Server] \u8B66\u544A: \u672A\u8A2D\u5B9A API Key\uFF0C\u9023\u63A5\u53EF\u80FD\u4E0D\u7A69\u5B9A");
}
var CONFIG = {
  port: parseInt(process.env.WS_PORT) || 10010,
  tiktokUsername: process.argv[2] || ""
};
var wss = null;
var tiktokConnection = null;
var isConnected = false;
var clients = /* @__PURE__ */ new Set();
var userCache = /* @__PURE__ */ new Map();
var giftDedup = /* @__PURE__ */ new Map();
function startWebSocketServer() {
  wss = new WebSocket.Server({ port: CONFIG.port });
  console.log(`[Server] WebSocket \u670D\u52D9\u5668\u5DF2\u555F\u52D5: ws://127.0.0.1:${CONFIG.port}`);
  wss.on("connection", (ws) => {
    console.log("[Server] \u5BA2\u6236\u7AEF\u5DF2\u9023\u63A5");
    clients.add(ws);
    ws.send(JSON.stringify({
      type: "status",
      connected: isConnected,
      username: CONFIG.tiktokUsername
    }));
    ws.on("message", (message) => {
      try {
        const data = JSON.parse(message);
        handleClientMessage(data, ws);
      } catch (e) {
        console.error("[Server] \u89E3\u6790\u5BA2\u6236\u7AEF\u8A0A\u606F\u5931\u6557:", e);
      }
    });
    ws.on("close", () => {
      console.log("[Server] \u5BA2\u6236\u7AEF\u5DF2\u65B7\u958B");
      clients.delete(ws);
    });
    ws.on("error", (err) => {
      console.error("[Server] WebSocket \u932F\u8AA4:", err);
      clients.delete(ws);
    });
  });
}
function handleClientMessage(data, ws) {
  if (data.type === "connect" && data.username) {
    console.log(`[Server] \u6536\u5230\u9023\u63A5\u8ACB\u6C42: ${data.username}`);
    connectToTikTok(data.username);
  } else if (data.type === "disconnect") {
    console.log("[Server] \u6536\u5230\u65B7\u958B\u8ACB\u6C42");
    disconnectFromTikTok();
  }
}
function broadcast(data) {
  const message = JSON.stringify(data);
  clients.forEach((client) => {
    if (client.readyState === WebSocket.OPEN) {
      client.send(message);
    }
  });
}
async function connectToTikTok(username) {
  if (tiktokConnection) {
    await disconnectFromTikTok();
  }
  CONFIG.tiktokUsername = username;
  console.log(`[TikTok] \u6B63\u5728\u9023\u63A5: @${username}`);
  tiktokConnection = new WebcastPushConnection(username, {
    processInitialData: false,
    enableExtendedGiftInfo: true,
    enableWebsocketUpgrade: true,
    requestPollingIntervalMs: 1e3,
    sessionId: void 0,
    fetchRoomInfoOnConnect: true,
    clientParams: {
      "app_language": "zh-Hant",
      "device_platform": "web",
      "browser_language": "zh-TW",
      "browser_platform": "Win32",
      "browser_name": "Mozilla",
      "browser_version": "5.0"
    },
    requestHeaders: {
      "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    }
  });
  tiktokConnection.on("connected", (state) => {
    console.log(`[TikTok] \u5DF2\u9023\u63A5\u5230\u76F4\u64AD\u9593! roomId: ${state.roomId}`);
    isConnected = true;
    broadcast({
      type: "connected",
      roomId: state.roomId,
      username
    });
  });
  tiktokConnection.on("websocketConnected", () => {
    console.log("[TikTok] WebSocket \u5DF2\u9023\u63A5");
  });
  tiktokConnection.on("rawData", (messageTypeName, binary) => {
    if (messageTypeName === "WebcastBarrageMessage") {
      try {
        const textContent = binary.toString("utf8");
        const userIdMatch = textContent.match(/(\d{15,20})/);
        let levelMatch = textContent.match(/grade_badge_lv(\d+)/i);
        if (!levelMatch) levelMatch = textContent.match(/grade[_]?(\d+)/i);
        if (!levelMatch) levelMatch = textContent.match(/level[_\-\s]?(\d+)/i);
        if (!levelMatch) levelMatch = textContent.match(/lv[_\-\s]?(\d+)/i);
        if (!levelMatch) levelMatch = textContent.match(/\blv(\d{1,3})\b/i);
        if (!levelMatch) levelMatch = textContent.match(/user_grade[^\d]*(\d+)/i);
        if (!levelMatch) {
          const urlLevelMatch = textContent.match(/level[_]?(\d+)\.png/i) || textContent.match(/lv(\d+)\.png/i) || textContent.match(/grade[_]?(\d+)\.png/i);
          if (urlLevelMatch) levelMatch = urlLevelMatch;
        }
        const joinedMatch = textContent.includes("joined") || textContent.includes("join_animation") || textContent.includes("entrance") || textContent.includes("enter") || textContent.includes("room") || textContent.includes("welcome");
        if (joinedMatch) {
          const userId = userIdMatch ? userIdMatch[1] : "";
          const level = levelMatch ? levelMatch[1] : "?";
          let extractedNickname = "";
          let extractedUniqueId = "";
          const strings = [];
          let currentStr = "";
          for (let i = 0; i < binary.length; i++) {
            const byte = binary[i];
            if (byte >= 32 && byte < 127) {
              currentStr += String.fromCharCode(byte);
            } else if (byte >= 192) {
              let charBytes = [byte];
              let bytesNeeded = byte >= 240 ? 3 : byte >= 224 ? 2 : 1;
              for (let j = 0; j < bytesNeeded && i + j + 1 < binary.length; j++) {
                charBytes.push(binary[i + j + 1]);
              }
              try {
                currentStr += Buffer.from(charBytes).toString("utf8");
                i += bytesNeeded;
              } catch (e) {
                if (currentStr.length >= 2) strings.push(currentStr);
                currentStr = "";
              }
            } else {
              if (currentStr.length >= 2) strings.push(currentStr);
              currentStr = "";
            }
          }
          if (currentStr.length >= 2) strings.push(currentStr);
          const filteredStrings = strings.filter(
            (s) => s.length >= 2 && s.length <= 30 && !s.includes("http") && !s.includes("tiktok") && !s.includes("grade_") && !s.includes("badge") && !s.includes("png") && !s.includes("webp") && !s.includes("animation") && !s.includes("Webcast") && !s.includes("ffffffff") && !s.includes("#") && !s.match(/^\d+$/)
          );
          const excludeKeywords = ["joined", "join", "live", "room", "user", "gift", "like", "share", "follow", "comment", "chat"];
          for (const s of filteredStrings) {
            if (/[\u4e00-\u9fff\u3400-\u4dbf]/.test(s)) {
              const match = s.match(/[\u4e00-\u9fff\u3400-\u4dbfa-zA-Z0-9_\-\.\s\u00c0-\u024f\u1e00-\u1eff\u3040-\u30ff\uac00-\ud7af\p{Extended_Pictographic}]+/gu);
              if (match) {
                let best = "";
                for (const m of match) {
                  if (/[\u4e00-\u9fff\u3400-\u4dbf]/.test(m) && m.length > best.length) {
                    best = m;
                  }
                }
                if (best.length >= 2) {
                  let cleaned = best;
                  const cjkPattern = /[\u4e00-\u9fff\u3400-\u4dbf\u3040-\u30ff\uac00-\ud7af]/;
                  if (/^[A-Za-z]/.test(cleaned) && cjkPattern.test(cleaned.charAt(1))) {
                    cleaned = cleaned.substring(1);
                  }
                  while (cleaned.length > 2 && /[A-Za-z]$/.test(cleaned) && cjkPattern.test(cleaned.charAt(cleaned.length - 2))) {
                    cleaned = cleaned.slice(0, -1);
                  }
                  cleaned = cleaned.replace(/[Jj]oined?$/i, "").replace(/[Ee]nter$/i, "").replace(/[Rr]oom$/i, "").trim();
                  extractedNickname = cleaned.trim();
                  if (extractedNickname.length >= 2) break;
                }
              }
            }
          }
          if (!extractedNickname) {
            for (const s of filteredStrings) {
              if (/^[a-zA-Z][a-zA-Z0-9_\-\.\s]{2,19}$/.test(s) && !excludeKeywords.includes(s.toLowerCase()) && !s.includes("user") && !s.includes("entrance")) {
                extractedNickname = s;
                break;
              }
            }
          }
          for (const s of filteredStrings) {
            const lower = s.toLowerCase();
            if (/^[a-z][a-z0-9_]{2,23}$/.test(s) && s !== extractedNickname && !excludeKeywords.includes(lower)) {
              extractedUniqueId = s;
              break;
            }
          }
          const cachedUser = userCache.get(userId);
          const nickname = extractedNickname || cachedUser?.nickname || `Lv${level}\u7528\u6236`;
          const uniqueId = extractedUniqueId || cachedUser?.uniqueId || "";
          console.log(`[\u9AD8\u7B49\u7D1A\u9032\u5834] Lv${level} ${nickname}`);
          if (userId && (extractedNickname || extractedUniqueId)) {
            userCache.set(userId, {
              nickname: extractedNickname || cachedUser?.nickname || "",
              uniqueId: extractedUniqueId || cachedUser?.uniqueId || ""
            });
          }
          broadcast({
            type: "MemberMessage",
            nickname,
            uniqueId,
            userId,
            isVIP: true,
            level: parseInt(level) || 0,
            fromBarrageRaw: true
          });
          broadcast({
            type: "BarrageMessage",
            nickname,
            uniqueId,
            userId,
            level: parseInt(level) || 0,
            isVIP: true
          });
        }
      } catch (e) {
      }
    }
  });
  tiktokConnection.on("envelope", (msg) => {
    if (msg) {
      broadcast({ type: "EnvelopeMessage", ...msg });
    }
  });
  tiktokConnection.on("social", (msg) => {
    broadcast({
      type: "SocialMessage",
      nickname: msg.nickname,
      uniqueId: msg.uniqueId,
      userId: msg.userId,
      displayType: msg.displayType,
      label: msg.label
    });
    if (msg.displayType === "pm_mt_join_message" || msg.label && msg.label.includes("joined")) {
      broadcast({
        type: "MemberMessage",
        nickname: msg.nickname,
        uniqueId: msg.uniqueId,
        userId: msg.userId,
        fromSocial: true
      });
    }
  });
  tiktokConnection.on("barrage", (msg) => {
    const msgStr = JSON.stringify(msg);
    const user = msg.user || msg;
    const nickname = user.nickname || user.uniqueId || "VIP\u7528\u6236";
    const uniqueId = user.uniqueId || "";
    const userId = user.userId || user.uid || "";
    let level = 0;
    if (user.level) level = Math.max(level, parseInt(user.level) || 0);
    if (user.grade) level = Math.max(level, parseInt(user.grade) || 0);
    if (user.userBadges && Array.isArray(user.userBadges)) {
      for (const badge of user.userBadges) {
        if (badge.level) level = Math.max(level, parseInt(badge.level) || 0);
        const badgeStr = JSON.stringify(badge);
        const lvMatch2 = badgeStr.match(/lv(\d+)/i) || badgeStr.match(/level[_]?(\d+)/i);
        if (lvMatch2) level = Math.max(level, parseInt(lvMatch2[1]) || 0);
      }
    }
    const lvMatch = msgStr.match(/grade_badge_lv(\d+)/i) || msgStr.match(/"level"\s*:\s*(\d+)/i) || msgStr.match(/lv(\d+)/i);
    if (lvMatch) level = Math.max(level, parseInt(lvMatch[1]) || 0);
    if (userId && nickname && nickname !== "VIP\u7528\u6236") {
      userCache.set(userId, { nickname, uniqueId });
    }
    broadcast({
      type: "BarrageMessage",
      nickname,
      uniqueId,
      userId,
      level,
      isVIP: true
    });
    broadcast({
      type: "MemberMessage",
      nickname,
      uniqueId,
      userId,
      level,
      isVIP: true,
      fromBarrage: true
    });
  });
  tiktokConnection.on("superFan", (msg) => {
    const user = msg.user || msg;
    const nickname = user.nickname || user.uniqueId || "\u8D85\u7D1A\u7C89\u7D72";
    const uniqueId = user.uniqueId || "";
    const userId = user.userId || "";
    broadcast({ type: "SuperFanMessage", nickname, uniqueId, userId });
    broadcast({
      type: "MemberMessage",
      nickname,
      uniqueId,
      userId,
      isSuperFan: true,
      fromSuperFan: true
    });
  });
  tiktokConnection.on("disconnected", () => {
    console.log("[TikTok] \u9023\u63A5\u5DF2\u65B7\u958B");
    isConnected = false;
    broadcast({ type: "disconnected" });
  });
  tiktokConnection.on("error", (err) => {
    console.error("[TikTok] \u932F\u8AA4:", err.message);
    broadcast({ type: "error", message: err.message });
  });
  tiktokConnection.on("streamEnd", (actionId) => {
    console.log("[TikTok] \u76F4\u64AD\u5DF2\u7D50\u675F");
    isConnected = false;
    broadcast({ type: "streamEnd", actionId });
  });
  tiktokConnection.on("chat", (msg) => {
    if (msg.userId) {
      userCache.set(msg.userId, { nickname: msg.nickname, uniqueId: msg.uniqueId });
    }
    console.log(`[Chat] ${msg.nickname}: ${msg.comment}`);
    broadcast({
      type: "ChatMessage",
      nickname: msg.nickname,
      uniqueId: msg.uniqueId,
      userId: msg.userId,
      comment: msg.comment,
      followRole: msg.followRole,
      userBadges: msg.userBadges
    });
  });
  tiktokConnection.on("gift", (msg) => {
    if (msg.userId) {
      userCache.set(msg.userId, { nickname: msg.nickname, uniqueId: msg.uniqueId });
    }
    const giftCount = msg.repeatCount || 1;
    if (msg.giftType === 1 && !msg.repeatEnd) {
      console.log(`[Gift] ${msg.nickname} \u6B63\u5728\u9023\u9001 ${msg.giftName}... (${giftCount})`);
      return;
    }
    const dedupKey = `${msg.userId}_${msg.giftId}_${giftCount}`;
    const now = Date.now();
    const lastTime = giftDedup.get(dedupKey) || 0;
    if (now - lastTime < 2e3) {
      console.log(`[Gift] \u91CD\u8907\u79AE\u7269\u5DF2\u5FFD\u7565: ${dedupKey}`);
      return;
    }
    giftDedup.set(dedupKey, now);
    for (const [key, time] of giftDedup.entries()) {
      if (now - time > 1e4) {
        giftDedup.delete(key);
      }
    }
    console.log(`[Gift] ${msg.nickname} \u9001\u4E86 ${giftCount}x ${msg.giftName} (repeatEnd: ${msg.repeatEnd})`);
    broadcast({
      type: "GiftMessage",
      nickname: msg.nickname,
      uniqueId: msg.uniqueId,
      userId: msg.userId,
      giftId: msg.giftId,
      giftName: msg.giftName,
      repeatCount: giftCount,
      diamondCount: msg.diamondCount,
      giftType: msg.giftType
    });
  });
  tiktokConnection.on("like", (msg) => {
    broadcast({
      type: "LikeMessage",
      nickname: msg.nickname,
      uniqueId: msg.uniqueId,
      userId: msg.userId,
      likeCount: msg.likeCount,
      totalLikeCount: msg.totalLikeCount
    });
  });
  tiktokConnection.on("member", (msg) => {
    if (msg.userId) {
      userCache.set(msg.userId, { nickname: msg.nickname, uniqueId: msg.uniqueId });
    }
    let level = 0;
    if (msg.userBadges && Array.isArray(msg.userBadges)) {
      for (const badge of msg.userBadges) {
        if (badge.level) level = Math.max(level, parseInt(badge.level) || 0);
        if (badge.displayType && typeof badge.displayType === "string") {
          const lvMatch = badge.displayType.match(/lv(\d+)/i) || badge.displayType.match(/level[_]?(\d+)/i);
          if (lvMatch) level = Math.max(level, parseInt(lvMatch[1]) || 0);
        }
        if (badge.url && typeof badge.url === "string") {
          const urlMatch = badge.url.match(/grade_badge_lv(\d+)/) || badge.url.match(/lv(\d+)/i);
          if (urlMatch) level = Math.max(level, parseInt(urlMatch[1]) || 0);
        }
        if (badge.badgeSceneType === 1 && badge.imageInfo) {
          const imgUrl = badge.imageInfo.url || "";
          const imgMatch = imgUrl.match(/grade_badge_lv(\d+)/) || imgUrl.match(/lv(\d+)/i);
          if (imgMatch) level = Math.max(level, parseInt(imgMatch[1]) || 0);
        }
        const badgeName = badge.name || badge.text || "";
        if (badgeName) {
          const nameMatch = badgeName.match(/lv[_\-\s]?(\d+)/i) || badgeName.match(/level[_\-\s]?(\d+)/i);
          if (nameMatch) level = Math.max(level, parseInt(nameMatch[1]) || 0);
        }
      }
    }
    broadcast({
      type: "MemberMessage",
      nickname: msg.nickname,
      uniqueId: msg.uniqueId,
      userId: msg.userId,
      followRole: msg.followRole,
      userBadges: msg.userBadges,
      level,
      isVIP: level >= 20,
      profilePictureUrl: msg.profilePictureUrl
    });
  });
  tiktokConnection.on("follow", (msg) => {
    console.log(`[Follow] ${msg.nickname} \u95DC\u6CE8\u4E86\u4E3B\u64AD`);
    broadcast({
      type: "FollowMessage",
      nickname: msg.nickname,
      uniqueId: msg.uniqueId,
      userId: msg.userId
    });
  });
  tiktokConnection.on("share", (msg) => {
    broadcast({
      type: "ShareMessage",
      nickname: msg.nickname,
      uniqueId: msg.uniqueId,
      userId: msg.userId
    });
  });
  tiktokConnection.on("roomUser", (msg) => {
    broadcast({
      type: "RoomUserMessage",
      viewerCount: msg.viewerCount,
      topViewers: msg.topViewers
    });
  });
  tiktokConnection.on("subscribe", (msg) => {
    console.log(`[Subscribe] ${msg.nickname} \u8A02\u95B1\u4E86\u4E3B\u64AD`);
    broadcast({
      type: "SubscribeMessage",
      nickname: msg.nickname,
      uniqueId: msg.uniqueId,
      userId: msg.userId
    });
  });
  try {
    await tiktokConnection.connect();
  } catch (err) {
    console.error("[TikTok] \u9023\u63A5\u5931\u6557:", err.message);
    broadcast({ type: "error", message: `\u9023\u63A5\u5931\u6557: ${err.message}` });
  }
}
async function disconnectFromTikTok() {
  if (tiktokConnection) {
    try {
      tiktokConnection.disconnect();
    } catch (e) {
    }
    tiktokConnection = null;
  }
  isConnected = false;
  console.log("[TikTok] \u5DF2\u65B7\u958B\u9023\u63A5");
}
async function main() {
  console.log("=".repeat(50));
  console.log("TikTok Live WebSocket Server");
  console.log("=".repeat(50));
  startWebSocketServer();
  if (CONFIG.tiktokUsername) {
    console.log(`[Server] \u81EA\u52D5\u9023\u63A5: @${CONFIG.tiktokUsername}`);
    setTimeout(() => {
      connectToTikTok(CONFIG.tiktokUsername);
    }, 1e3);
  } else {
    console.log("[Server] \u7B49\u5F85\u5BA2\u6236\u7AEF\u9023\u63A5...");
  }
}
process.on("SIGINT", async () => {
  console.log("\n[Server] \u6B63\u5728\u95DC\u9589...");
  await disconnectFromTikTok();
  if (wss) {
    wss.close();
  }
  process.exit(0);
});
main();
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

axios/dist/node/axios.cjs:
  (*! Axios v1.13.2 Copyright (c) 2025 Matt Zabriskie and contributors *)
*/
